<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>高並發編程通用概念（跨 Java/C++/Rust/Go）</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ascii-diagram.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">高並發編程通用概念（跨 Java/C++/Rust/Go）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言如何讀這本並發書"><a class="header" href="#前言如何讀這本並發書">前言：如何讀這本並發書</a></h1>
<p>這本書雖然以 Java 展開，但大部分核心概念都不是 Java 專屬，而是所有高並發系統都要面對的通用問題。</p>
<h2 id="三句話抓重點"><a class="header" href="#三句話抓重點">三句話抓重點</a></h2>
<ol>
<li>並發問題的根源是「多執行單元同時碰同一份資料」。</li>
<li>解法分三層：語言層（原子/鎖）、執行時層（排程/執行緒池）、架構層（分散式鎖/削峰）。</li>
<li>高吞吐不是只靠語法，而是整條鏈路一起優化。</li>
</ol>
<h2 id="統一心智模型"><a class="header" href="#統一心智模型">統一心智模型</a></h2>
<pre><code class="language-text">請求 -&gt; 任務切分 -&gt; 排隊 -&gt; 執行 -&gt; 寫回資料
           |         |       |
         分工      背壓    一致性
</code></pre>
<h2 id="語言對照最小表"><a class="header" href="#語言對照最小表">語言對照最小表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>通用概念</th><th>Java</th><th>C/C++</th><th>Rust</th><th>Go</th></tr></thead><tbody>
<tr><td>執行單元</td><td>Thread</td><td>std::thread/pthread</td><td>std::thread</td><td>goroutine</td></tr>
<tr><td>互斥</td><td>synchronized/Lock</td><td>mutex</td><td>Mutex<T></td><td>sync.Mutex</td></tr>
<tr><td>原子</td><td>Atomic*</td><td>std::atomic</td><td>Atomic*</td><td>sync/atomic</td></tr>
<tr><td>可見性順序</td><td>JMM</td><td>C++ memory model</td><td>同 C++ 原子語義</td><td>Go memory model</td></tr>
</tbody></table>
</div>
<h2 id="閱讀建議"><a class="header" href="#閱讀建議">閱讀建議</a></h2>
<ul>
<li>先讀第 1~6 章建立底層觀念。</li>
<li>再讀第 7~14 章看語言與框架實作。</li>
<li>最後讀第 15~20 章把概念落到工程。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第1章-作業系統與線程調度"><a class="header" href="#第1章-作業系統與線程調度">第1章 作業系統與線程調度</a></h1>
<h2 id="11-計算機基礎對應-111112"><a class="header" href="#11-計算機基礎對應-111112">1.1 計算機基礎（對應 1.1.1~1.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖"><a class="header" href="#本小節示意圖">本小節示意圖</a></h3>
<pre><code class="language-text">馮諾伊曼架構：CPU ↔ 記憶體 ↔ I/O

  ┌──────────────────────────────────────────────────────────────────────────┐
  │                        CPU                                               │
  │  ┌──────────┐  ┌──────────┐  ┌────────────────────────────────────────┐  │
  │  │ 控制單元  │  │ 算術邏輯  │  │      暫存器組                        │  │
  │  │  (CU)   │  │ 單元(ALU)│  │  R0 R1 R2 ... R15                       │  │
  │  └────┬─────┘  └────┬─────┘  └────────────────────────────────────────┘  │
  └───────┼─────────────┼────────────────────────────────────────────────────┘
                                                               │             │
          └──────┬───────────────────────────────────────────────────────────┘
                 │  系統匯流排（System Bus）
    ┌────────────┴───────────────────────────────────────────────────────────┐
                                   │                                         │
    ▼                                         ▼
┌──────────┐                          ┌──────────────────────────────────────┐
│  記憶體   │                          │   I/O 裝置                          │
│  (RAM)   │                          │  磁碟/網路/鍵盤                      │
└──────────┘                          └──────────────────────────────────────┘

快取層次（速度由快到慢，容量由小到大）：

  ┌──────────────────────────────────────────────────────────────────────────┐
  │  速度: 最快 ◄──────────────────────────────────► 最慢                    │
  │  容量: 最小 ◄──────────────────────────────────► 最大                    │
  └──────────────────────────────────────────────────────────────────────────┘

  ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   ┌──────────┐   ┌───────┐
  │Register│──▶│  L1$   │──▶│  L2$   │──▶│  L3$   │──▶│   RAM    │──▶│ Disk  │
  │  ~1ns  │   │  ~4ns  │   │ ~12ns  │   │ ~30ns  │   │ ~100ns   │   │~10ms  │
  │  &lt;1KB  │   │  64KB  │   │  512KB │   │   8MB  │   │  GB 級別  │   │ TB級 │
  └────────┘   └────────┘   └────────┘   └────────┘   └──────────┘   └───────┘
   核心獨享      核心獨享      核心獨享      插槽共享        DRAM         持久化
</code></pre>
<p>重點：CPU 做計算，記憶體放資料，I/O 負責進出。</p>
<p>白話例子：廚房裡，廚師=CPU，冰箱=記憶體，外送窗口=I/O。快取好比廚師的備料台，常用食材放在手邊，不用每次跑去冰箱。</p>
<h2 id="12-多核與多-cpu對應-121125"><a class="header" href="#12-多核與多-cpu對應-121125">1.2 多核與多 CPU（對應 1.2.1~1.2.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-1"><a class="header" href="#本小節示意圖-1">本小節示意圖</a></h3>
<pre><code class="language-text">單核時間切片（Concurrency，並發但非並行）：

時間軸 ──────────────────────────────────────────────►
       ┌─────┬─────┬─────┬─────┬─────┬─────┬────────────────────────────────────────┐
Core0  │  T1 │  T2 │  T1 │  T3 │  T2 │  T1 │  T3                                    │
       └─────┴─────┴─────┴─────┴─────┴─────┴────────────────────────────────────────┘
        ▲                               ▲
     Context Switch               Context Switch
     （上下文切換，有額外成本）

多核真並行（Parallelism）：

時間軸 ──────────────────────────────────────────────►
       ┌────────────────────────────────────────────────────────────────────────────┐
Core0  │  T1 │  T1 │  T1 │  T1 │  T1 │  T1                                      │   │
       ├────────────────────────────────────────────────────────────────────────────┤
Core1  │  T2 │  T2 │  T2 │  T2 │  T2 │  T2                                      │   │
       ├────────────────────────────────────────────────────────────────────────────┤
Core2  │  T3 │  T3 │  T3 │  T3 │  T3 │  T3                                      │   │
       ├────────────────────────────────────────────────────────────────────────────┤
Core3  │  T4 │  T4 │  T4 │  T4 │  T4 │  T4                                      │   │
       └────────────────────────────────────────────────────────────────────────────┘
        真正同時執行，吞吐量 ≈ 單核 × 核心數

NUMA 多插槽架構（跨 Socket 成本警示）：

  ┌────────────── Socket 0 ──────────────┐   ┌────────────── Socket 1 ──────────────┐
  │  ┌────────┐  ┌────────┐             │   │  ┌────────┐  ┌──────────┐             │
  │  │ Core0  │  │ Core1  │  ...        │   │  │ Core4  │  │ Core5  │  ...          │
  │  └────────┘  └────────┘             │   │  └────────┘  └──────────┘             │
  │       └──────────┘                  │   │       └────────────┘                  │
  │           L3 Cache (共享)            │   │           L3 Cache (共享)            │
  │           Local RAM                 │   │           Local RAM                   │
  └──────────────┬──────────────────────┘   └──────────────┬────────────────────────┘
                                          │                                         │
                 └──────────── QPI / UPI 互連 ──────────────────────────────────────┘
                               （跨 Socket 延遲 ≈ 本地 RAM 的 2~3 倍）
  ⚠ 跨 Socket 存取 Remote RAM 比 Local RAM 慢得多，設計時盡量讓執行緒存取本地記憶體
</code></pre>
<p>重點：</p>
<ul>
<li>單核：同時只能真做一件事，靠時間切換看起來像同時。</li>
<li>多核：可真並行。</li>
<li>多 CPU：更多插槽，但跨 Socket 總線協調成本高。</li>
</ul>
<h2 id="13-線程模型對應-131133"><a class="header" href="#13-線程模型對應-131133">1.3 線程模型（對應 1.3.1~1.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-2"><a class="header" href="#本小節示意圖-2">本小節示意圖</a></h3>
<pre><code class="language-text">三種線程模型對比：

┌─────────────────────────────────────────────────────────────────────────────────┐
│  模型 1：1:1 模型（Java / C++ / Rust 標準線程）                                 │
    │                                                                             │
│  User Space   [Thread A] [Thread B] [Thread C]                                  │
│                    │          │          │         每個用戶線程                 │
│  Kernel Space  [KThread]  [KThread]  [KThread]    直接對應一個核心線程          │
   │                    │          │          │                                   │
│  CPU Core      [Core 0]   [Core 1]   [Core 2]                                   │
    │                                                                             │
│  優點：OS 直接調度，真正並行；阻塞不影響其他線程                                │
│  缺點：線程創建/切換成本高（syscall），線程數受 OS 限制                         │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│  模型 2：M:1 模型（舊版 Green Thread / 早期 JVM）                               │
    │                                                                             │
│  User Space  [Thread A][Thread B][Thread C][Thread D][Thread E]                 │
    │                  │         │         │         │         │                  │
│              └───┴─────────┴─────────┴─────────┴──────────────┘                 │
│                              User-Level Scheduler                               │
    │                                       │                                     │
│  Kernel Space                     [KThread]  ← 只有一個核心線程                 │
    │                                       │                                     │
│  CPU Core                         [Core 0]                                      │
    │                                                                             │
│  優點：切換快（不需要 syscall）                                                 │
│  缺點：任一線程阻塞 → 整個進程卡住；無法利用多核                                │
└─────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────┐
│  模型 3：M:N 模型（Go goroutine / Erlang process）                              │
    │                                                                             │
│  User Space  [G1][G2][G3][G4][G5][G6][G7][G8]  ← N 個 goroutine（可達百萬）     │
│               └──┬──┘  └──┬──┘  └──┬──┘  └───────┘                              │
│              [P0 Queue] [P1 Queue] [P2 Queue]  ← M 個邏輯處理器（≈CPU核數）     │
    │                  │          │          │                                    │
│  Kernel Space [KThread0] [KThread1] [KThread2] ← K 個核心線程                   │
    │                  │          │          │                                    │
│  CPU Core     [Core 0]   [Core 1]   [Core 2]                                    │
    │                                                                             │
│  優點：輕量（goroutine ~2KB），阻塞自動切換，真並行                             │
│  缺點：Runtime 複雜；Work Stealing 調度有額外開銷                               │
└─────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>使用者線程：切換快，但碰到阻塞可能整批卡住。</li>
<li>核心線程：由 OS 調度，隔離好，成本較高。</li>
<li>混合模型：兩者折衷，Go 是最成功的 M:N 實作之一。</li>
</ul>
<h2 id="14-java-線程與-os-線程映射"><a class="header" href="#14-java-線程與-os-線程映射">1.4 Java 線程與 OS 線程映射</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-3"><a class="header" href="#本小節示意圖-3">本小節示意圖</a></h3>
<pre><code class="language-text">Java 線程完整映射鏈：

  Java 層                  JVM 層               OS 層          硬體層
  ─────────                ──────               ─────          ──────
  new Thread()
                                                                        │
      │ Java API
      ▼
  thread.start()
                                                                        │
      │ JNI 呼叫
      ▼
  ┌─────────────────────────────────────────────────────────────────────┐
  │  JVM Native  │ ──────────────────► pthread_create()
  │  Thread Code                             │                          │
  └──────────────┘                          │ Linux syscall
                                            ▼
                                    ┌───────────────────────────────────┐
                                    │  OS Kernel                        │
                                    │  pthread /                        │
                                    │  clone()                          │
                                    └───────┬───────────────────────────┘
                                            │ 調度
                                            ▼
                                    ┌───────────────────────────────────┐
                                    │   CPU Core                        │
                                    │  執行機器碼                       │
                                    └───────────────────────────────────┘

Java 線程狀態機：

         ┌──────────────────────────────────────────────────────────────┐
                      │                                                 │
  start()│                                                 │run() 結束
         ▼                                                              │
  ┌─────────┐   OS 分配時間片    ┌────────────────────────┐             │
  │   NEW   │──────────────────►│ RUNNABLE  │─────────────►│ TERMINATED │
  └─────────┘                   └─────┬──────┘             │            │
                                      │                   └─────────────┘
                      synchronized/IO │阻塞
                      ┌───────────────┼─────────────────────────────────┐
                      ▼               ▼               ▼
               ┌──────────┐  ┌──────────────┐  ┌────────────────────────┐
               │ BLOCKED  │  │   WAITING    │  │TIMED_WAITING           │
               │(等待鎖)   │  │(wait/join/   │  │(sleep/                │
               └────┬─────┘  │ park 無超時)  │  │ wait有超時)           │
                    │        └──────┬───────┘  └──────┬─────────────────┘
                                     │               │                  │
                    │  鎖釋放        │ notify/          │ 超時/
                    │               │ unpark           │ interrupt
                    └───────────────┴───────────────────────────────────┘
                                                                        │
                                    ▼
                               RUNNABLE（重新競爭）
</code></pre>
<p>Java 的 <code>Thread</code> 最終也要跑在 OS 調度上。C/C++/Rust/Go 一樣，差別主要在 runtime 包裝方式。</p>
<h2 id="跨語言對照"><a class="header" href="#跨語言對照">跨語言對照</a></h2>
<div class="table-wrapper"><table><thead><tr><th>概念</th><th>C</th><th>C++</th><th>Rust</th><th>Go</th></tr></thead><tbody>
<tr><td>執行單元</td><td>pthread</td><td>std::thread</td><td>std::thread</td><td>goroutine（M:N）</td></tr>
<tr><td>啟動方式</td><td>pthread_create</td><td>thread.detach/join</td><td>thread::spawn</td><td>go func()</td></tr>
<tr><td>核數查詢</td><td>sysconf</td><td>thread::hardware_concurrency</td><td>num_cpus crate</td><td>runtime.NumCPU()</td></tr>
<tr><td>線程模型</td><td>1:1（OS pthread）</td><td>1:1（OS pthread）</td><td>1:1（OS pthread）</td><td>M:N（Go runtime）</td></tr>
</tbody></table>
</div>
<h2 id="示意圖"><a class="header" href="#示意圖">示意圖</a></h2>
<pre><code class="language-text">多核並行執行示意（兩核四線程）：

時間軸 ────────────────────────────────────────────►
       ┌──────┬──────┬──────┬──────┬──────┬────────┐
Core0  │  T1  │  T1  │  T1  │  T3  │  T3  │  T3    │
       ├──────┼──────┼──────┼──────┼──────┼────────┤
Core1  │  T2  │  T2  │  T2  │  T4  │  T4  │  T4    │
       └──────┴──────┴──────┴──────┴──────┴────────┘
                           ▲
                      Context Switch
        （T1/T2 → T3/T4，OS 調度器決定切換時機）
</code></pre>
<h2 id="跨語言完整範例"><a class="header" href="#跨語言完整範例">跨語言完整範例</a></h2>
<p>建立 2 個執行緒各自打印 tick，並印出 CPU 核心數。</p>
<h3 id="cpthread"><a class="header" href="#cpthread">C（pthread）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

struct args { const char *name; int ticks; };

void *tick_worker(void *arg) {
    struct args *a = (struct args *)arg;
    for (int i = 0; i &lt; a-&gt;ticks; i++) {
        printf("%s tick %d\n", a-&gt;name, i);
        usleep(50000);
    }
    return NULL;
}

int main(void) {
    long cpu_count = sysconf(_SC_NPROCESSORS_ONLN);
    printf("cpu_count = %ld\n", cpu_count);

    pthread_t t1, t2;
    struct args a1 = {"T1", 3}, a2 = {"T2", 3};
    pthread_create(&amp;t1, NULL, tick_worker, &amp;a1);
    pthread_create(&amp;t2, NULL, tick_worker, &amp;a2);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -o tick tick.c -lpthread &amp;&amp; ./tick
</code></pre>
<h3 id="cstdthread"><a class="header" href="#cstdthread">C++（std::thread）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

void tick_worker(const std::string &amp;name, int ticks) {
    for (int i = 0; i &lt; ticks; i++) {
        std::cout &lt;&lt; name &lt;&lt; " tick " &lt;&lt; i &lt;&lt; "\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

int main() {
    unsigned int cores = std::thread::hardware_concurrency();
    std::cout &lt;&lt; "cpu_count = " &lt;&lt; cores &lt;&lt; "\n";

    std::thread t1(tick_worker, "T1", 3);
    std::thread t2(tick_worker, "T2", 3);
    t1.join();
    t2.join();
    return 0;
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o tick tick.cpp -lpthread &amp;&amp; ./tick
</code></pre>
<h3 id="ruststdthread"><a class="header" href="#ruststdthread">Rust（std::thread）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn tick_worker(name: &amp;str, ticks: u32) {
    for i in 0..ticks {
        println!("{} tick {}", name, i);
        thread::sleep(Duration::from_millis(50));
    }
}

fn main() {
    let cpu_count = std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(1);
    println!("cpu_count = {}", cpu_count);

    let t1 = thread::spawn(|| tick_worker("T1", 3));
    let t2 = thread::spawn(|| tick_worker("T2", 3));
    t1.join().unwrap();
    t2.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine"><a class="header" href="#gogoroutine">Go（goroutine）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func tickWorker(name string, ticks int, wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i &lt; ticks; i++ {
        fmt.Printf("%s tick %d\n", name, i)
        time.Sleep(50 * time.Millisecond)
    }
}

func main() {
    fmt.Printf("cpu_count = %d\n", runtime.NumCPU())

    var wg sync.WaitGroup
    wg.Add(2)
    go tickWorker("T1", 3, &amp;wg)
    go tickWorker("T2", 3, &amp;wg)
    wg.Wait()
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonthreading"><a class="header" href="#pythonthreading">Python（threading）</a></h3>
<pre><code class="language-python">import os
import threading
import time

def tick_worker(name: str, ticks: int):
    for i in range(ticks):
        print(f"{name} tick {i}")
        time.sleep(0.05)

if __name__ == "__main__":
    print(f"cpu_count = {os.cpu_count()}")
    t1 = threading.Thread(target=tick_worker, args=("T1", 3))
    t2 = threading.Thread(target=tick_worker, args=("T2", 3))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
</code></pre>
<pre><code class="language-bash">python3 tick.py
</code></pre>
<h2 id="完整專案級範例python"><a class="header" href="#完整專案級範例python">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch01.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch01.py
</code></pre>
<pre><code class="language-python">"""Chapter 01: OS scheduling and threads.

展示：
1. 印出 CPU 核心數
2. 建立 2 個執行緒各自打印 tick
3. 觀察執行緒交錯輸出（並發）
"""
import os
import threading
import time


def work(name: str, ticks: int = 3):
    for i in range(ticks):
        print(f"{name} tick {i}", flush=True)
        time.sleep(0.05)


if __name__ == "__main__":
    print(f"cpu_count = {os.cpu_count()}")
    t1 = threading.Thread(target=work, args=("T1",))
    t2 = threading.Thread(target=work, args=("T2",))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print("done")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第2章-並發基礎概念與風險"><a class="header" href="#第2章-並發基礎概念與風險">第2章 並發基礎概念與風險</a></h1>
<h2 id="21-基本名詞對應-211219"><a class="header" href="#21-基本名詞對應-211219">2.1 基本名詞（對應 2.1.1~2.1.9）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-4"><a class="header" href="#本小節示意圖-4">本小節示意圖</a></h3>
<pre><code class="language-text">進程 vs 線程：

  ┌─────────────────────────────────────────────────────────────────────┐
  │  Process 進程（資源容器）                                           │
  │  ┌─────────────────────────────────────────────────────────────┐    │
  │  │  虛擬記憶體空間 / 檔案描述符 / 信號處理器                   │    │
  │  └─────────────────────────────────────────────────────────────┘    │
                 │                                                      │
  │  ┌────────────┐  ┌────────────┐  ┌────────────────────────────┐     │
  │  │  Thread A  │  │  Thread B  │  │  Thread C                  │     │
  │  │ (執行單位)  │  │ (執行單位)  │  │ (執行單位)               │     │
  │  │  Stack     │  │  Stack     │  │  Stack                     │     │
  │  │  PC/暫存器  │  │  PC/暫存器  │  │  PC/暫存器               │     │
  │  └────────────┘  └────────────┘  └────────────────────────────┘     │
  │       └──────────────┴──────────────────────────────┘               │
  │                   共享 Heap / 全域變數                              │
  └─────────────────────────────────────────────────────────────────────┘

並發 Concurrency（交錯推進，不一定同時）：

  時間軸 ─────────────────────────────────────────────►
         ┌───┬───┬───┬───┬───┬───┬───┬───┬──────────────────────────────┐
  Core0  │ A │ B │ A │ C │ B │ C │ A │ B │ C                            │
         └───┴───┴───┴───┴───┴───┴───┴───┴──────────────────────────────┘
          ▲   ▲
        切換  切換（Context Switch）

並行 Parallelism（真正同時，需要多核）：

  時間軸 ──────────────────────────────────────────────►
         ┌──────────────────────────────────────────────────────────────┐
  Core0  │  A  │  A  │  A  │  A  │  A  │  A                        │    │
         ├──────────────────────────────────────────────────────────────┤
  Core1  │  B  │  B  │  B  │  B  │  B  │  B                        │    │
         └──────────────────────────────────────────────────────────────┘

同步 Sync（呼叫後阻塞等待結果）：

  caller ──► [發出請求] ──► [等待中...] ──► [得到結果] ──► 繼續往下

異步 Async（呼叫後立即返回，結果晚點通知）：

  caller ──► [發出請求] ──► 繼續做其他事情 ...
                  └──────────────────────────► [callback/future 收到結果]

阻塞 Blocking（等待期間執行流停住）：

  T1: ──► [發出 I/O 請求] ──► ░░░░░░░░ WAIT ░░░░░░░░ ──► [繼續]
                               ▲ 這段時間 CPU 不執行此線程

非阻塞 Non-blocking（不停住，改輪詢或事件驅動）：

  T1: ──► [發出 I/O 請求] ──► [做其他工作] ──► [輪詢/事件] ──► [繼續]
</code></pre>
<ul>
<li>進程：資源容器。</li>
<li>線程：執行單位。</li>
<li>並發：交錯進行。</li>
<li>並行：同時進行。</li>
<li>同步/異步：拿結果的方式。</li>
<li>阻塞/非阻塞：等待時是否卡住執行流。</li>
</ul>
<h2 id="22-三大風險對應-221223"><a class="header" href="#22-三大風險對應-221223">2.2 三大風險（對應 2.2.1~2.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-5"><a class="header" href="#本小節示意圖-5">本小節示意圖</a></h3>
<pre><code class="language-text">並發三大風險三角形：

                        ┌─────────────────────────────────────────┐
                        │    安全性（Safety）                     │
                        │    結果正確性                           │
                                           │                      │
                        │  典型症狀：                             │
                        │  ・counter 結果偏小                     │
                        │  ・資料庫記錄重複                       │
                        │  ・賬戶餘額計算錯誤                     │
                        └──────────┬──────────────────────────────┘
                                                                  │
                         三者往往互相影響
                        ┌──────────┴──────────────────────────────┐
                                           │                      │
           ┌────────────┴──────────┐  ┌────────┴──────────────────┐
           │   活躍性（Liveness）   │  │   效能（Performance）    │
           │   程式能繼續推進       │  │   速度是否夠快           │
               │                      │  │                        │
           │  典型症狀：           │  │  典型症狀：               │
           │  ・死鎖 Deadlock      │  │  ・鎖競爭（Contention）   │
           │    T1 等 T2 的鎖      │  │  ・上下文切換過多         │
           │    T2 等 T1 的鎖      │  │  ・快取失效（Cache Miss） │
           │  ・飢餓 Starvation    │  │  ・假共享（False Sharing）│
           │    低優先級線程永遠      │  │                        │
           │    搶不到鎖           │  │  解法：鎖粒度、CAS、      │
           │  ・活鎖 Livelock      │  │  無鎖結構、線程池調優     │
           │    雙方都在讓步但都      │  │                        │
           │    無法推進              │  │                        │
           └──────────────────────┘  └────────────────────────────┘

三者關係：
  ・過度加鎖 → 安全性高，但效能差
  ・不加鎖   → 效能好，但安全性崩潰
  ・鎖粒度錯 → 可能同時損失效能和活躍性（死鎖）

死鎖示意（T1/T2 互等）：

  T1: ──► [持有 Lock A] ──► [等待 Lock B] ─► 永久阻塞
  T2: ──► [持有 Lock B] ──► [等待 Lock A] ─► 永久阻塞
                    ▲                  ▲
                    └──── 循環等待 ───────────────────────────────┘
</code></pre>
<ul>
<li>安全性：結果錯（資料競爭）。</li>
<li>活躍性：做不完（死鎖/飢餓/活鎖）。</li>
<li>效能：做得慢（鎖競爭、上下文切換）。</li>
</ul>
<h2 id="23-鎖分類對應-231238"><a class="header" href="#23-鎖分類對應-231238">2.3 鎖分類（對應 2.3.1~2.3.8）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-6"><a class="header" href="#本小節示意圖-6">本小節示意圖</a></h3>
<pre><code class="language-text">鎖分類樹狀圖：

                              ┌─────────────────────────────────────────┐
                              │   鎖                                    │
                              └────┬────────────────────────────────────┘
         ┌──────────┬──────────────┼──────────────┬─────────────────────┐
         ▼          ▼              ▼              ▼              ▼
    ┌─────────┐ ┌─────────┐ ┌───────────┐ ┌──────────┐ ┌────────────────┐
    │悲觀/樂觀 │ │公平/非公平│ │可重入/不可│ │共享/獨占 │ │  自旋/阻塞  │
    └────┬────┘ └────┬────┘ │重入       │ └────┬─────┘ └──────┬─────────┘
         │           │      └─────┬──────────────┘       │              │
    ┌────┴────┐  ┌───┴────┐  ┌───┴────┐    ┌───┴────┐    ┌───┴──────────┐
    │悲觀鎖   │  │公平鎖   │  │可重入鎖│    │共享鎖  │    │自旋鎖       │
    │先鎖再操作│  │FIFO 排隊│  │同線程可│    │多讀者  │    │忙等        │
    │         │  │         │  │多次獲得│    │同時持有│    │適合短臨     │
    │例：     │  │例：     │  │        │    │        │    │界區         │
    │Mutex    │  │Java     │  │例：    │    │例：         │    │        │
    │         │  │ReentrantLock│Java  │    │RWLock        │    │        │
    │         │  │(fair=true)│ Reentrant│  │ReadLock      │    │        │
    └─────────┘  └─────────┘  │Lock   │    └────────┘    └──────────────┘
    ┌─────────┐  ┌─────────┐  └────────┘   ┌────────┐    ┌──────────────┐
    │樂觀鎖   │  │非公平鎖  │  ┌────────┐   │獨占鎖  │    │阻塞鎖       │
    │先操作後  │  │可插隊   │  │不可重入│   │同時只有│    │掛起線程     │
    │校驗衝突  │  │         │  │同線程再│   │一個持有│    │適合長臨     │
    │         │  │例：     │  │次獲取  │   │        │    │界區          │
    │例：CAS/ │  │Java     │  │→ 死鎖  │   │例：          │    │        │
    │MVCC     │  │Reentrant│  │        │   │Mutex/  │    │例：OS        │
    │         │  │Lock     │  │        │   │WriteLock│   │futex         │
    └─────────┘  │(預設)   │  └────────┘   └────────┘    └──────────────┘
                 └──────────────────────────────────────────────────────┘

各鎖使用場景選擇指引：

  ┌────────────────┬────────────────────────────────────────────────────┐
  │  場景           │  推薦鎖類型                                       │
  ├────────────────┼────────────────────────────────────────────────────┤
  │  讀多寫少       │  共享讀鎖（RWLock）                               │
  │  衝突少         │  樂觀鎖（CAS/MVCC）                               │
  │  衝突多         │  悲觀鎖（Mutex）                                  │
  │  臨界區極短     │  自旋鎖（SpinLock）                               │
  │  臨界區較長     │  阻塞鎖（OS Mutex）                               │
  │  需要遞迴獲取   │  可重入鎖（ReentrantLock）                        │
  └────────────────┴────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>悲觀/樂觀</li>
<li>公平/非公平</li>
<li>可重入/不可重入</li>
<li>可中斷/不可中斷</li>
<li>共享/獨占</li>
<li>自旋/阻塞</li>
</ul>
<p>白話例子：</p>
<ul>
<li>公平鎖像銀行抽號，先到先得。</li>
<li>非公平鎖像空位誰搶到誰先辦。</li>
<li>可重入鎖像房間主人可以再進自己的房間；不可重入則會把自己鎖在外面。</li>
</ul>
<h2 id="示意圖-1"><a class="header" href="#示意圖-1">示意圖</a></h2>
<pre><code class="language-text">競態條件（Race Condition）導致丟失更新：

  時間軸 ─────────────────────────────────────────────────►
         Step 1          Step 2          Step 3
  T1: ──►[read x=0] ──► [計算 0+1=1] ──►           [write x=1] ──►
  T2: ──►[read x=0] ────────────────────►[計算 0+1=1] ──► [write x=1]

  預期：x = 2
  實際：x = 1  ← T1 的更新被 T2 覆蓋，丟失一次遞增！
</code></pre>
<h2 id="跨語言完整範例-1"><a class="header" href="#跨語言完整範例-1">跨語言完整範例</a></h2>
<p>無鎖版 vs 加鎖版 counter++（展示 race condition）。</p>
<h3 id="cpthread--無鎖加鎖對比"><a class="header" href="#cpthread--無鎖加鎖對比">C（pthread + 無鎖/加鎖對比）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define THREADS 4
#define ITER    100000

long unsafe_counter = 0;
long safe_counter = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *unsafe_inc(void *arg) {
    for (int i = 0; i &lt; ITER; i++)
        unsafe_counter++;   /* 非原子，有競態 */
    return NULL;
}

void *safe_inc(void *arg) {
    for (int i = 0; i &lt; ITER; i++) {
        pthread_mutex_lock(&amp;lock);
        safe_counter++;     /* 加鎖保護，結果正確 */
        pthread_mutex_unlock(&amp;lock);
    }
    return NULL;
}

int main(void) {
    pthread_t tid[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, unsafe_inc, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("unsafe_counter = %ld (expected %d)\n", unsafe_counter, THREADS * ITER);

    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, safe_inc, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("safe_counter   = %ld (expected %d)\n", safe_counter, THREADS * ITER);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -O0 -o race race.c -lpthread &amp;&amp; ./race
</code></pre>
<h3 id="cstdthread--stdmutex"><a class="header" href="#cstdthread--stdmutex">C++（std::thread + std::mutex）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

const int THREADS = 4, ITER = 100000;
long unsafe_counter = 0;
long safe_counter = 0;
std::mutex lock;

void unsafe_inc() {
    for (int i = 0; i &lt; ITER; i++)
        unsafe_counter++;
}

void safe_inc() {
    for (int i = 0; i &lt; ITER; i++) {
        std::lock_guard&lt;std::mutex&gt; g(lock);
        safe_counter++;
    }
}

void run(void(*fn)()) {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) ts.emplace_back(fn);
    for (auto &amp;t : ts) t.join();
}

int main() {
    run(unsafe_inc);
    std::cout &lt;&lt; "unsafe: " &lt;&lt; unsafe_counter &lt;&lt; " (expected " &lt;&lt; THREADS*ITER &lt;&lt; ")\n";
    run(safe_inc);
    std::cout &lt;&lt; "safe:   " &lt;&lt; safe_counter   &lt;&lt; " (expected " &lt;&lt; THREADS*ITER &lt;&lt; ")\n";
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -O0 -o race race.cpp -lpthread &amp;&amp; ./race
</code></pre>
<h3 id="ruststdthread--mutex-vs-atomici64"><a class="header" href="#ruststdthread--mutex-vs-atomici64">Rust（std::thread + Mutex vs AtomicI64）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::sync::atomic::{AtomicI64, Ordering};
use std::thread;

const THREADS: usize = 4;
const ITER: i64 = 100_000;

fn main() {
    // 加鎖版：結果正確
    let safe = Arc::new(Mutex::new(0i64));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;safe);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { *c.lock().unwrap() += 1; }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("safe (mutex):  {} (expected {})", *safe.lock().unwrap(), THREADS as i64 * ITER);

    // 原子版：無鎖且正確
    let atomic = Arc::new(AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;atomic);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { c.fetch_add(1, Ordering::Relaxed); }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("safe (atomic): {} (expected {})", atomic.load(Ordering::SeqCst), THREADS as i64 * ITER);
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine--syncmutex-vs-atomic"><a class="header" href="#gogoroutine--syncmutex-vs-atomic">Go（goroutine + sync.Mutex vs atomic）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

const threads, iter = 4, 100_000

func main() {
    // 無鎖（競態，結果通常偏小）
    var unsafe_counter int64
    var wg sync.WaitGroup
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                unsafe_counter++ // data race!
            }
        }()
    }
    wg.Wait()
    fmt.Printf("unsafe:  %d (expected %d)\n", unsafe_counter, threads*iter)

    // 原子版（無鎖且正確）
    var safe_counter int64
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                atomic.AddInt64(&amp;safe_counter, 1)
            }
        }()
    }
    wg.Wait()
    fmt.Printf("safe:    %d (expected %d)\n", safe_counter, threads*iter)
}
</code></pre>
<pre><code class="language-bash">go run main.go
# 加 -race 旗標可偵測競態：
go run -race main.go
</code></pre>
<h3 id="pythonthreading--lock-對比"><a class="header" href="#pythonthreading--lock-對比">Python（threading + Lock 對比）</a></h3>
<pre><code class="language-python">import threading

THREADS, ITER = 4, 100_000

unsafe_counter = 0
safe_counter = 0
lock = threading.Lock()

def unsafe_inc():
    global unsafe_counter
    for _ in range(ITER):
        unsafe_counter += 1   # Python GIL 下通常安全，但不保證

def safe_inc():
    global safe_counter
    for _ in range(ITER):
        with lock:
            safe_counter += 1

def run_threads(fn):
    ts = [threading.Thread(target=fn) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()

run_threads(unsafe_inc)
print(f"unsafe: {unsafe_counter} (expected {THREADS * ITER})")
run_threads(safe_inc)
print(f"safe:   {safe_counter} (expected {THREADS * ITER})")
</code></pre>
<pre><code class="language-bash">python3 race.py
</code></pre>
<h2 id="完整專案級範例python-1"><a class="header" href="#完整專案級範例python-1">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch02.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch02.py
</code></pre>
<pre><code class="language-python">"""Chapter 02: race risk and lock.

展示：
1. 無鎖版 counter（可能有競態，Python GIL 有時會掩蓋，但 C/Rust/Go 明確可見）
2. 有鎖版 counter（結果正確，永遠等於 THREADS * ITER）
"""
import threading

THREADS = 4
ITER = 50_000

counter = 0
lock = threading.Lock()


def inc(n: int):
    global counter
    for _ in range(n):
        with lock:
            counter += 1


if __name__ == "__main__":
    threads = [threading.Thread(target=inc, args=(ITER,)) for _ in range(THREADS)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    print(f"counter = {counter} (expected {THREADS * ITER})")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第3章-三大核心問題分工同步互斥"><a class="header" href="#第3章-三大核心問題分工同步互斥">第3章 三大核心問題：分工、同步、互斥</a></h1>
<h2 id="31-分工對應-311312"><a class="header" href="#31-分工對應-311312">3.1 分工（對應 3.1.1~3.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-7"><a class="header" href="#本小節示意圖-7">本小節示意圖</a></h3>
<pre><code class="language-text">任務切分流水線（Pipeline 分工）：

  原始任務（序列）：
  ┌──────────────────────────────────────────────────────────────────────────────┐
  │  Input ──► Parse ──► Compute ──► Store  （全部串行，吞吐量受限）             │
  └──────────────────────────────────────────────────────────────────────────────┘

  分工並行化（三個執行緒分擔不同角色）：

  資料流向：

  ┌─────────────┐     Queue1      ┌──────────────┐     Queue2     ┌──────────────┐
  │   Input     │ ─────────────► │   Parse      │ ─────────────► │   Compute     │
  │  (讀取資料)  │                │  Thread T1   │                │  Thread T2   │
  └─────────────┘                └──────────────┘                └──────┬────────┘
                                                                         │  Queue3
                                                                         ▼
                                                                ┌────────────────┐
                                                                │   Store        │
                                                                │  Thread T3     │
                                                                └────────────────┘

  時間軸對比：

  串行（總時間 = T_parse + T_compute + T_store）：
  ┌────────┬─────────┬───────────────────────────────────────────────────────────┐
  │ Parse  │ Compute │ Store                                                     │
  └────────┴─────────┴───────────────────────────────────────────────────────────┘

  流水線並行（穩態吞吐量 ≈ max(T_parse, T_compute, T_store) 決定瓶頸）：
  Time: 1  2  3  4  5  6
  T1:  [P1][P2][P3][P4][P5][P6]  ← Parse
  T2:     [C1][C2][C3][C4][C5]   ← Compute（等 P1 完）
  T3:        [S1][S2][S3][S4]    ← Store（等 C1 完）
              ▲
           穩態後三個階段同時跑，吞吐量 ≈ 串行的 3 倍

  ⚠ 注意：Stage 之間必須用 Queue 緩衝（解耦速率差異）
  ⚠ 注意：最慢的 Stage 決定整個 Pipeline 的上限（木桶效應）
</code></pre>
<p>把任務切成可平行的小任務，減少單點瓶頸。</p>
<h2 id="32-同步對應-321322"><a class="header" href="#32-同步對應-321322">3.2 同步（對應 3.2.1~3.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-8"><a class="header" href="#本小節示意圖-8">本小節示意圖</a></h3>
<pre><code class="language-text">同步：因果關係約束（T1 完成 → T2 才能開始）

  因果關係圖：

  Thread T1                           Thread T2
  ──────────                          ──────────
  [計算數據]
  [準備結果]
                                                                     │
       │  signal / notify / set()
       ▼
  ┌────────────┐ ─────────────────────► ┌────────────────────────────┐
  │ done 事件  │                         │ 等待 done                 │
  │ (已發出)   │                         │ wait() 阻塞               │
  └────────────┘                         └─────┬─────────────────────┘
                                               │ 收到通知
                                               ▼
                                         [開始消費結果]
                                         [繼續往下執行]

  時間軸視角（等待/喚醒機制）：

  時間 ──────────────────────────────────────────────────►
  T1:  [工作][工作][工作] ──► signal ──────────────────────
  T2:  [wait...]░░░░░░░░░░░░░░░░░░░░░░░░ ──► [繼續執行]
                ▲                            ▲
           T2 被阻塞                     T1 發出信號後 T2 喚醒

  常見同步原語對比：

  ┌──────────────┬───────────────────────────────────────────────────┐
  │  原語         │  語意                                            │
  ├──────────────┼───────────────────────────────────────────────────┤
  │  Event/Flag  │  1:N 通知，一次性或可重置                         │
  │  Semaphore   │  計數信號量，允許 N 個執行緒同時通過              │
  │  Barrier     │  所有參與者都到達後才一起放行                     │
  │  CountDown   │  計數到 0 後通知等待者                            │
  │  Condition   │  wait/notify，配合鎖使用                          │
  └──────────────┴───────────────────────────────────────────────────┘
</code></pre>
<p>約束「先後順序」，避免讀到半成品。</p>
<h2 id="33-互斥對應-331332"><a class="header" href="#33-互斥對應-331332">3.3 互斥（對應 3.3.1~3.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-9"><a class="header" href="#本小節示意圖-9">本小節示意圖</a></h3>
<pre><code class="language-text">互斥：臨界區保護（同一時間只有一個執行緒進入）

  ┌───────────────────────────────────────────────────────────────────┐
  │                       臨界區（Critical Section）                  │
    │                                                                 │
  │  ┌──────────┐     lock()    ┌──────────────────────┐              │
  │  │ Thread 1 │ ─────────────►│  正在執行            │              │
  │  └──────────┘   成功，進入   │  counter++          │              │
  │                             └──────────────────────┘              │
  │  ┌──────────┐     lock()    ┌──────────────────────┐              │
  │  │ Thread 2 │ ─────────────►│  阻塞等待...         │              │
  │  └──────────┘   失敗，排隊   │  ░░░░░░░░░░░░░░     │              │
  │                             └──────────────────────┘              │
  │  ┌──────────┐     lock()    ┌──────────────────────┐              │
  │  │ Thread 3 │ ─────────────►│  阻塞等待...         │              │
  │  └──────────┘   失敗，排隊   │  ░░░░░░░░░░░░░░     │              │
  │                             └──────────────────────┘              │
  └───────────────────────────────────────────────────────────────────┘

  鎖的生命週期：

  Thread 1:  ──► lock() ──► [臨界區] ──► unlock() ──►
                                           │                          │
                  │ 獲取鎖（進入）            │ 釋放鎖
                  ▼                          ▼
  Thread 2:  ──► lock() ── 阻塞....... ──► [臨界區] ──► unlock() ──►
                           ▲               ▲
                        T1 持有鎖時        T1 unlock 後
                        T2 被阻塞          T2 被喚醒

  互斥保護的是「操作的不可分性」，確保中間狀態不被其他執行緒看見。
</code></pre>
<p>同一時間只允許一個執行單元修改共享資料。</p>
<p>白話例子：結帳金額是共享資源，兩個收銀機同時改同筆訂單會亂掉；互斥鎖好比「正在服務中，請稍候」的牌子。</p>
<h2 id="示意圖-2"><a class="header" href="#示意圖-2">示意圖</a></h2>
<pre><code class="language-text">三大核心問題綜合示意（Pipeline + 同步 + 互斥）：

  ┌──────────┐       Queue        ┌──────────────┐      Queue      ┌──────────────┐
  │ Producer │ ──────────────────►│    Buffer    │───────────────► │ Consumer     │
  │  Thread  │  (互斥：每次只有   │  (同步：      │ (互斥：每次只有  │  Thread    │
  │ 生產資料  │   一個寫入者)      │  Buffer 非空  │  一個讀取者)     │ 消費資料  │
  └──────────┘                    │  才能消費）   │                 └─────────────┘
                                  └───────────────────────────────────────────────┘

  分工：Producer 和 Consumer 各自獨立執行（分工）
  同步：Consumer 等待 Buffer 有資料（同步）
  互斥：Buffer 的讀寫必須互斥，防止資料損毀（互斥）
</code></pre>
<h2 id="跨語言完整範例-2"><a class="header" href="#跨語言完整範例-2">跨語言完整範例</a></h2>
<p>三執行緒 Pipeline（Producer → Buffer → Consumer），展示分工 + 同步 + 互斥。</p>
<h3 id="cpthread--condition-variable"><a class="header" href="#cpthread--condition-variable">C（pthread + condition variable）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define BUFFER_SIZE 8
#define ITEMS 10

int buffer[BUFFER_SIZE];
int head = 0, tail = 0, count = 0;
int done = 0;

pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full  = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;

void *producer(void *arg) {
    for (int i = 0; i &lt; ITEMS; i++) {
        pthread_mutex_lock(&amp;mu);
        while (count == BUFFER_SIZE)
            pthread_cond_wait(&amp;not_full, &amp;mu);
        buffer[tail] = i;
        tail = (tail + 1) % BUFFER_SIZE;
        count++;
        printf("[Producer] put %d\n", i);
        pthread_cond_signal(&amp;not_empty);
        pthread_mutex_unlock(&amp;mu);
    }
    pthread_mutex_lock(&amp;mu);
    done = 1;
    pthread_cond_signal(&amp;not_empty);
    pthread_mutex_unlock(&amp;mu);
    return NULL;
}

void *consumer(void *arg) {
    while (1) {
        pthread_mutex_lock(&amp;mu);
        while (count == 0 &amp;&amp; !done)
            pthread_cond_wait(&amp;not_empty, &amp;mu);
        if (count == 0 &amp;&amp; done) { pthread_mutex_unlock(&amp;mu); break; }
        int val = buffer[head];
        head = (head + 1) % BUFFER_SIZE;
        count--;
        printf("[Consumer] got %d\n", val);
        pthread_cond_signal(&amp;not_full);
        pthread_mutex_unlock(&amp;mu);
    }
    return NULL;
}

int main(void) {
    pthread_t p, c;
    pthread_create(&amp;p, NULL, producer, NULL);
    pthread_create(&amp;c, NULL, consumer, NULL);
    pthread_join(p, NULL);
    pthread_join(c, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -o pipeline pipeline.c -lpthread &amp;&amp; ./pipeline
</code></pre>
<h3 id="cstdthread--condition_variable"><a class="header" href="#cstdthread--condition_variable">C++（std::thread + condition_variable）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;queue&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

const int ITEMS = 10;
std::queue&lt;int&gt; buffer;
std::mutex mu;
std::condition_variable not_empty;
bool producer_done = false;

void producer() {
    for (int i = 0; i &lt; ITEMS; i++) {
        std::unique_lock&lt;std::mutex&gt; lock(mu);
        buffer.push(i);
        std::cout &lt;&lt; "[Producer] put " &lt;&lt; i &lt;&lt; "\n";
        not_empty.notify_one();
    }
    std::unique_lock&lt;std::mutex&gt; lock(mu);
    producer_done = true;
    not_empty.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock&lt;std::mutex&gt; lock(mu);
        not_empty.wait(lock, [] { return !buffer.empty() || producer_done; });
        if (buffer.empty()) break;
        int val = buffer.front(); buffer.pop();
        std::cout &lt;&lt; "[Consumer] got " &lt;&lt; val &lt;&lt; "\n";
    }
}

int main() {
    std::thread p(producer), c(consumer);
    p.join(); c.join();
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o pipeline pipeline.cpp -lpthread &amp;&amp; ./pipeline
</code></pre>
<h3 id="ruststdsyncmpsc-channel"><a class="header" href="#ruststdsyncmpsc-channel">Rust（std::sync::mpsc channel）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

const ITEMS: i32 = 10;

fn main() {
    let (tx, rx) = mpsc::channel::&lt;i32&gt;();

    let producer = thread::spawn(move || {
        for i in 0..ITEMS {
            println!("[Producer] put {}", i);
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(10));
        }
        // tx 在此 drop，channel 自動關閉
    });

    let consumer = thread::spawn(move || {
        for val in rx {   // rx 迭代到 channel 關閉為止
            println!("[Consumer] got {}", val);
        }
        println!("[Consumer] done");
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine--channel"><a class="header" href="#gogoroutine--channel">Go（goroutine + channel）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

const items = 10

func producer(ch chan&lt;- int) {
    for i := 0; i &lt; items; i++ {
        fmt.Printf("[Producer] put %d\n", i)
        ch &lt;- i
        time.Sleep(10 * time.Millisecond)
    }
    close(ch)
}

func consumer(ch &lt;-chan int) {
    for val := range ch {
        fmt.Printf("[Consumer] got %d\n", val)
    }
    fmt.Println("[Consumer] done")
}

func main() {
    ch := make(chan int, 4)  // 緩衝 channel 作為 buffer
    go producer(ch)
    consumer(ch)             // 主 goroutine 當 consumer
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonqueuequeue--threading"><a class="header" href="#pythonqueuequeue--threading">Python（queue.Queue + threading）</a></h3>
<pre><code class="language-python">import queue
import threading

ITEMS = 10
buf: queue.Queue[int] = queue.Queue(maxsize=4)

def producer():
    for i in range(ITEMS):
        buf.put(i)                   # 滿了就阻塞（同步）
        print(f"[Producer] put {i}")
    buf.put(None)                    # 哨兵值通知結束

def consumer():
    while True:
        val = buf.get()              # 空了就阻塞（同步）
        if val is None:
            break
        print(f"[Consumer] got {val}")
    print("[Consumer] done")

if __name__ == "__main__":
    t_prod = threading.Thread(target=producer)
    t_cons = threading.Thread(target=consumer)
    t_prod.start()
    t_cons.start()
    t_prod.join()
    t_cons.join()
</code></pre>
<pre><code class="language-bash">python3 pipeline.py
</code></pre>
<h2 id="完整專案級範例python-2"><a class="header" href="#完整專案級範例python-2">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch03.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch03.py
</code></pre>
<pre><code class="language-python">"""Chapter 03: split work + sync.

展示三大核心問題：
1. 分工：Producer 和 Consumer 各自獨立執行
2. 同步：Consumer 等待 Buffer 有資料（queue.Queue 內建阻塞語意）
3. 互斥：Queue 內部使用鎖保護 Buffer 讀寫
"""
import queue
import threading

buf: queue.Queue[int] = queue.Queue()
barrier = threading.Barrier(3)


def worker(name: str):
    s = 0
    while True:
        try:
            s += buf.get_nowait()
        except queue.Empty:
            break
    print(name, "partial=", s)
    barrier.wait()


if __name__ == "__main__":
    for i in range(1, 11):
        buf.put(i)
    ts = [threading.Thread(target=worker, args=(f"W{i}",)) for i in (1, 2)]
    for t in ts:
        t.start()
    barrier.wait()
    print("all workers reached sync point")
    for t in ts:
        t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4章-本質問題原子性可見性有序性"><a class="header" href="#第4章-本質問題原子性可見性有序性">第4章 本質問題：原子性、可見性、有序性</a></h1>
<h2 id="41-背景對應-411415"><a class="header" href="#41-背景對應-411415">4.1 背景（對應 4.1.1~4.1.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-10"><a class="header" href="#本小節示意圖-10">本小節示意圖</a></h3>
<pre><code class="language-text">程式從源碼到執行的完整路徑，每個階段都可能引入問題：

  ┌────────────────────────────────────────────────────────────────────────────┐
  │  源碼（Source Code）                                                       │
  │  int x = 0;                                                                │
  │  x++;                                                                      │
  └───────────────────────────┬────────────────────────────────────────────────┘
                                                                               │
                    ┌─────────▼────────────────────────────────────────────────┐
                    │  編譯器優化          │  ← 潛在問題：指令重排、死碼刪除
                    │  (Compiler)         │     volatile/memory_order 可控制
                    └─────────┬────────────────────────────────────────────────┘
                                                                               │
                    ┌─────────▼────────────────────────────────────────────────┐
                    │  機器碼              │  ← 一條 x++ 變成三條指令：
                    │  (Machine Code)     │     LOAD r1, [x]
                    └─────────┬──────────┘     ADD r1, 1
                              │                STORE [x], r1
                    ┌─────────▼────────────────────────────────────────────────┐
                    │  CPU 亂序執行        │  ← 潛在問題：Out-of-Order Execution
                    │  (OoOE Pipeline)    │     CPU 可調整指令執行順序提升效率
                    └─────────┬────────────────────────────────────────────────┘
                                                                               │
              ┌───────────────┼────────────────────────────────────────────────┐
                                               │               │               │
    ┌─────────▼──────┐ ┌──────▼─────┐ ┌──────▼─────────────────────────────────┐
    │  Store Buffer  │ │  L1 Cache  │ │  L2 Cache  │  ← 潛在問題：可見性
    │  (寫入緩衝)     │ │  (核心私有) │ │  (核心私有) │     一個核心的寫入
    └────────────────┘ └────────────┘ └────────────┘     對其他核心不立即可見
                                                                               │
                    ┌─────────▼────────────────────────────────────────────────┐
                    │  L3 Cache           │  ← 所有核心共享，但同步有延遲
                    └─────────┬────────────────────────────────────────────────┘
                                                                               │
                    ┌─────────▼────────────────────────────────────────────────┐
                    │  Main Memory (RAM)  │  ← 最終一致，但時序不保證
                    └──────────────────────────────────────────────────────────┘

  結論：你以為的「按順序、立即可見」在並發環境中都是假設！
</code></pre>
<p>CPU、快取、編譯器優化都會讓「你以為的順序」和實際執行不同。</p>
<h2 id="42-原子性對應-421424"><a class="header" href="#42-原子性對應-421424">4.2 原子性（對應 4.2.1~4.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-11"><a class="header" href="#本小節示意圖-11">本小節示意圖</a></h3>
<pre><code class="language-text">x++ 非原子性拆解（Read-Modify-Write 三步）：

  高層語義（你寫的）：
  ┌─────────────────────────────────────────────────────────────┐
  │    x++          │  ← 看起來是一個操作
  └─────────────────────────────────────────────────────────────┘

  實際機器碼（三個獨立步驟）：
  ┌──────────┐    ┌──────────┐    ┌─────────────────────────────┐
  │ LOAD(x)  │──► │ ADD(1)   │──► │ STORE(x)                    │
  │ r1 = x   │    │ r1 = r1+1│    │ x = r1                      │
  └──────────┘    └──────────┘    └─────────────────────────────┘
       ①               ②               ③
       ▲               ▲               ▲
  任何兩步之間都可能被其他執行緒打斷！

  兩個執行緒交錯導致丟失更新（Lost Update）：

  初始狀態：x = 0

  時間  Thread T1                    Thread T2
  ──── ──────────────────────────── ────────────────────────────
   t1  ① LOAD  r1_T1 = x = 0
   t2                               ① LOAD  r1_T2 = x = 0
   t3  ② ADD   r1_T1 = 0 + 1 = 1
   t4                               ② ADD   r1_T2 = 0 + 1 = 1
   t5  ③ STORE x = r1_T1 = 1
   t6                               ③ STORE x = r1_T2 = 1

  預期結果：x = 2
  實際結果：x = 1  ← T1 的遞增被 T2 覆蓋，一次更新永久丟失！

  解法：原子指令（LOCK XADD / fetch_add）確保三步不可分割
  ┌─────────────────────────────────────────────────────────────┐
  │  LOCK XADD [x], 1  ← 一條不可分割的原子指令                 │
  │  等價於：原子地 x = x + 1，中間態對其他 CPU 不可見          │
  └─────────────────────────────────────────────────────────────┘
</code></pre>
<p><code>x++</code> 不是原子，實際是讀、改、寫三步。</p>
<h2 id="43-可見性對應-431434"><a class="header" href="#43-可見性對應-431434">4.3 可見性（對應 4.3.1~4.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-12"><a class="header" href="#本小節示意圖-12">本小節示意圖</a></h3>
<pre><code class="language-text">快取不一致導致可見性問題：

  ┌─────────────────────────────┐     ┌────────────────────────────────────┐
  │         Core 0              │     │         Core 1                     │
         │                             │     │                             │
  │  Thread T1（寫入方）         │     │  Thread T2（讀取方）              │
         │                             │     │                             │
  │  x = 42;                    │     │  while (x == 0) { }                │
  │                             │     │  // 期望讀到 42                    │
  │  ┌─────────────────────┐    │     │    ┌────────────────────────────┐  │
  │  │  L1 Cache           │    │     │    │  L1 Cache                  │  │
  │  │  ┌───────────────┐  │    │     │    │  ┌──────────────────────┐  │  │
  │  │  │  x = 42  (新) │  │    │     │    │  │  x = 0   (舊)        │  │  │
  │  │  └───────────────┘  │    │     │    │  └──────────────────────┘  │  │
  │  └─────────────────────┘    │     │    └────────────────────────────┘  │
  └──────────────┬──────────────┘     └────────────────────────────────────┘
                 │                                  ▲
                 │  cache coherence 協議             │  Core1 讀到的是舊值！
                 │  （MESI 狀態機）                  │  可能永遠看不到 x=42
                                        │                                  │
                 └─────────────────────────────────────────────────────────┘
                        需要 memory barrier 刷新

  MESI 快取一致性協議狀態：

  ┌────────────┬───────────────────────────────────────────────────────────┐
  │  狀態      │  含義                                                     │
  ├────────────┼───────────────────────────────────────────────────────────┤
  │  Modified  │  本核心有最新值，其他核心的副本無效                       │
  │  Exclusive │  只有本核心有此快取行，且與記憶體一致                     │
  │  Shared    │  多個核心都有此快取行，且與記憶體一致                     │
  │  Invalid   │  此快取行無效，需要重新從記憶體/其他核心讀取              │
  └────────────┴───────────────────────────────────────────────────────────┘

  解法：使用 volatile（Java）/ atomic store（C++/Rust/Go）
  強制寫入時刷到記憶體，讀取時從記憶體重新讀。
</code></pre>
<p>A 執行緒改值，B 不一定立刻看得到，可能讀到舊快取。</p>
<h2 id="44-有序性對應-441444"><a class="header" href="#44-有序性對應-441444">4.4 有序性（對應 4.4.1~4.4.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-13"><a class="header" href="#本小節示意圖-13">本小節示意圖</a></h3>
<pre><code class="language-text">指令重排導致有序性問題：

  程式員視角（期望的執行順序）：

  Writer 執行緒             Reader 執行緒
  ──────────────────────    ───────────────────────
  ① data = 42              ③ if (ready == true)
  ② ready = true           ④     print(data)  // 期望印出 42

  CPU/編譯器重排後（實際可能的執行順序）：

  Writer 執行緒             Reader 執行緒
  ──────────────────────    ───────────────────────
  ② ready = true    ←─ ① 和 ② 被重排！
  ①' data = 42             ③ if (ready == true)   ← 看到 ready=true
                           ④     print(data)       ← 但 data 還是舊值！

  時間軸視角：

  時間 ─────────────────────────────────────────────────────►

  Writer: [ready=true] ...... [data=42]  ← 重排後 ready 先寫
                ↓
  Reader:       [讀到 ready=true] → [讀 data] ← 此時 data 可能還是 0！

  為什麼 CPU 會重排？
  ┌───────────────────────────────────────────────────────────────┐
  │  CPU 保證：單執行緒內的語義不變（as-if-serial）               │
  │  CPU 不保證：跨執行緒的全域可見順序                           │
     │                                                            │
  │  data 和 ready 在單執行緒內沒有依賴關係                       │
  │  → CPU/編譯器認為可以任意調換順序                             │
  └───────────────────────────────────────────────────────────────┘

  解法：Memory Barrier（記憶體屏障）

  Writer:  data = 42
           ┌──────────────────────────────────────────────────────┐
           │  StoreStore Barrier（禁止跨屏障的寫重排）            │
           └──────────────────────────────────────────────────────┘
           ready = true

  Reader:  if (ready)
           ┌──────────────────────────────────────────────────────┐
           │  LoadLoad Barrier（禁止跨屏障的讀重排）              │
           └──────────────────────────────────────────────────────┘
           print(data)   ← 現在保證讀到正確的 data
</code></pre>
<p>指令可能重排，只要單執行緒語義不變，編譯器就可能調整。</p>
<h2 id="45-綜合解法對應-451452"><a class="header" href="#45-綜合解法對應-451452">4.5 綜合解法（對應 4.5.1~4.5.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-14"><a class="header" href="#本小節示意圖-14">本小節示意圖</a></h3>
<pre><code class="language-text">三種問題 vs 三種解法對比：

  ┌──────────────────┬───────────────────────────────────────────────────────────────┐
  │  解法             │  原子性 ✓/✗   可見性 ✓/✗   有序性 ✓/✗   適用場景             │
  ├──────────────────┼───────────────────────────────────────────────────────────────┤
  │  原子類型          │    ✓           ✓           部分✓         計數器、狀態旗標   │
  │  (atomic int等)  │  CAS/fetch_add  強制刷新   依 memory_order  無鎖演算法        │
  ├──────────────────┼───────────────────────────────────────────────────────────────┤
  │  互斥鎖            │    ✓           ✓            ✓           複雜臨界區          │
  │  (mutex/lock)    │  鎖保護整段     解鎖時刷新   鎖保證 HB 關係  讀寫都有的情況   │
  ├──────────────────┼───────────────────────────────────────────────────────────────┤
  │  記憶體屏障         │    ✗           ✓            ✓           底層程式庫開發     │
  │  (memory_order)  │  不解決原子性   禁止快取優化  禁止重排       硬體驅動開發     │
  └──────────────────┴───────────────────────────────────────────────────────────────┘

  選擇指引：

  需要原子計數/旗標？
      └──► 優先選 atomic（零鎖開銷）

  臨界區有多個操作需要一起保護？
      └──► 必須選 mutex（原子類型只能保護單個變數）

  寫底層庫、需要精細控制記憶體順序？
      └──► 結合 atomic + 精確的 memory_order

  producer-consumer 資料傳遞？
      └──► atomic flag（ready） + 適當 memory_order，或直接用 channel/queue
</code></pre>
<ul>
<li>原子類 + CAS</li>
<li>鎖</li>
<li>記憶體屏障/語言記憶體模型規則</li>
</ul>
<h2 id="示意圖-3"><a class="header" href="#示意圖-3">示意圖</a></h2>
<pre><code class="language-text">完整問題場景（寫端/讀端的可見性與有序性）：

  Writer:
    data = 42;     // Step 1：寫資料
    ready = true;  // Step 2：設旗標

  Reader:
    if (ready)     // Step 3：讀旗標
        print(data) // Step 4：讀資料

  若重排/不可見：可能讀到 ready=true 但 data=舊值（0 或垃圾值）
  解法：ready 使用 atomic，並在 writer 側加 release 屏障，reader 側加 acquire 屏障
</code></pre>
<h2 id="跨語言完整範例-3"><a class="header" href="#跨語言完整範例-3">跨語言完整範例</a></h2>
<p>用 atomic flag 安全地在兩個執行緒間傳遞數據（producer-consumer with ready flag）。</p>
<h3 id="cgcc-__atomic-內建函式"><a class="header" href="#cgcc-__atomic-內建函式">C（GCC __atomic 內建函式）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;unistd.h&gt;

int data = 0;
atomic_int ready = 0;

void *writer(void *arg) {
    data = 42;                                       /* 先寫資料 */
    atomic_store_explicit(&amp;ready, 1,                 /* 再設旗標，release 語意 */
                          memory_order_release);
    return NULL;
}

void *reader(void *arg) {
    while (!atomic_load_explicit(&amp;ready,             /* 等待旗標，acquire 語意 */
                                 memory_order_acquire))
        ;                                            /* 自旋等待 */
    printf("reader got data = %d\n", data);          /* 保證看到 data=42 */
    return NULL;
}

int main(void) {
    pthread_t w, r;
    pthread_create(&amp;r, NULL, reader, NULL);
    usleep(10000);
    pthread_create(&amp;w, NULL, writer, NULL);
    pthread_join(w, NULL);
    pthread_join(r, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -std=c11 -o ready ready.c -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="cstdatomic-with-memory_order"><a class="header" href="#cstdatomic-with-memory_order">C++（std::atomic with memory_order）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;

int data = 0;
std::atomic&lt;bool&gt; ready{false};

void writer() {
    data = 42;                                     // 先寫資料
    ready.store(true, std::memory_order_release);  // release：之前的寫對 acquire 端可見
}

void reader() {
    while (!ready.load(std::memory_order_acquire)) // acquire：保證讀到 writer 的所有寫入
        std::this_thread::yield();
    std::cout &lt;&lt; "reader got data = " &lt;&lt; data &lt;&lt; "\n";
}

int main() {
    std::thread r(reader);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::thread w(writer);
    w.join();
    r.join();
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o ready ready.cpp -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="ruststdsyncatomic-with-ordering"><a class="header" href="#ruststdsyncatomic-with-ordering">Rust（std::sync::atomic with Ordering）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

static mut DATA: i32 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn main() {
    let reader = thread::spawn(|| {
        while !READY.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let val = unsafe { DATA };
        println!("reader got data = {}", val);
    });

    thread::sleep(Duration::from_millis(10));

    let writer = thread::spawn(|| {
        unsafe { DATA = 42; }                       // 先寫資料
        READY.store(true, Ordering::Release);        // release 屏障後設旗標
    });

    writer.join().unwrap();
    reader.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gosyncatomic--channel-作為-ready-信號"><a class="header" href="#gosyncatomic--channel-作為-ready-信號">Go（sync/atomic + channel 作為 ready 信號）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

var (
    data  int32
    ready atomic.Bool
)

func writer() {
    atomic.StoreInt32(&amp;data, 42)  // 寫資料
    ready.Store(true)             // 設旗標（Go atomic 已包含適當 memory barrier）
}

func reader() {
    for !ready.Load() {           // 等待旗標
        time.Sleep(time.Microsecond)
    }
    fmt.Printf("reader got data = %d\n", atomic.LoadInt32(&amp;data))
}

func main() {
    go reader()
    time.Sleep(10 * time.Millisecond)
    go writer()
    time.Sleep(100 * time.Millisecond) // 等兩個 goroutine 完成
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonthreadingevent-作為-ready-信號"><a class="header" href="#pythonthreadingevent-作為-ready-信號">Python（threading.Event 作為 ready 信號）</a></h3>
<pre><code class="language-python">import threading
import time

data = {"value": None}
ready = threading.Event()   # Event 內建 happens-before 語意

def writer():
    data["value"] = 42      # 先寫資料
    ready.set()             # 設旗標（Event.set() 保證可見性）

def reader():
    ready.wait()            # 阻塞等待旗標（比自旋更節省 CPU）
    print(f"reader got data = {data['value']}")

if __name__ == "__main__":
    t_reader = threading.Thread(target=reader)
    t_reader.start()
    time.sleep(0.02)
    t_writer = threading.Thread(target=writer)
    t_writer.start()
    t_writer.join()
    t_reader.join()
</code></pre>
<pre><code class="language-bash">python3 ready.py
</code></pre>
<h2 id="完整專案級範例python-3"><a class="header" href="#完整專案級範例python-3">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch04.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch04.py
</code></pre>
<pre><code class="language-python">"""Chapter 04: visibility/order via event.

展示：
1. Writer 先寫資料，再設旗標（模擬正確的 release 語意）
2. Reader 等待旗標後讀資料（模擬正確的 acquire 語意）
3. threading.Event 內建 happens-before 保證，確保讀到正確值
"""
import threading
import time

ready = threading.Event()
data = {"value": None}


def writer():
    data["value"] = 42      # Step 1：先寫資料
    ready.set()             # Step 2：設旗標（之後的 reader 保證看到 data=42）


def reader():
    ready.wait()            # 等待旗標（阻塞直到 writer 呼叫 set()）
    print("read value =", data["value"])   # 保證印出 42


if __name__ == "__main__":
    t1 = threading.Thread(target=writer)
    t2 = threading.Thread(target=reader)
    t2.start()
    time.sleep(0.02)
    t1.start()
    t1.join()
    t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第5章-原子性底層"><a class="header" href="#第5章-原子性底層">第5章 原子性底層</a></h1>
<h2 id="51-原子性定義"><a class="header" href="#51-原子性定義">5.1 原子性定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-15"><a class="header" href="#本小節示意圖-15">本小節示意圖</a></h3>
<pre><code class="language-text">原子性定義：「不可被拆開觀察，要嘛全成功，要嘛回到原狀」

  骰子比喻（原子操作的語意）：

  ┌──────────────────────────────────────────────────────────────────────┐
  │  原子操作（Atomic）                                                  │
      │                                                                  │
  │  狀態 A ──────────────────────────────────────► 狀態 B               │
  │   (x=0)         不可見中間態                     (x=1)               │
      │                                                                  │
  │  其他執行緒只能看到 A 或 B，永遠看不到「介於中間的半完成狀態」       │
  │                           ✓ 成功                                     │
  └──────────────────────────────────────────────────────────────────────┘

  非原子操作（Non-Atomic）：x++ 的危險：

  ┌──────────────────────────────────────────────────────────────────────┐
  │  非原子操作（x++）                                                   │
      │                                                                  │
  │  狀態 A         中間態（可被觀察！）           狀態 B                │
  │   (x=0)                                        (x=1)                 │
       │     │                                            │              │
  │     ▼                                            ▼                   │
  │  ① LOAD r1=0  ─────────────────────────►  ③ STORE x=1                │
  │                     ▲                                                │
       │                     │                                           │
  │              ② ADD r1=r1+1                                           │
  │              （r1 在暫存器，                                         │
  │               此刻 x 仍是 0）                                        │
  │                     ▲                                                │
  │              其他執行緒在 ① 和 ③ 之間可以讀取 x=0 的舊值！           │
  └──────────────────────────────────────────────────────────────────────┘

  比喻：銀行轉帳必須是原子的
  ┌──────────────────────────────────────────────────────────────────────┐
  │  轉帳 $100：扣款 A 帳戶 + 入款 B 帳戶                                │
        │                                                                │
  │  原子（正確）：                                                      │
  │  [A=1000, B=500] ──► [A=900, B=600]   ← 只有這兩種狀態               │
        │                                                                │
  │  非原子（危險）：                                                    │
  │  [A=1000, B=500]                                                     │
  │      ↓ 扣款 A                                                        │
  │  [A=900,  B=500]  ← 此刻系統崩潰，$100 憑空消失！                    │
  └──────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>一個操作不可被拆開觀察，要嘛全成，要嘛全不成。</p>
<h2 id="52-cpu-如何做原子對應-521523"><a class="header" href="#52-cpu-如何做原子對應-521523">5.2 CPU 如何做原子（對應 5.2.1~5.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-16"><a class="header" href="#本小節示意圖-16">本小節示意圖</a></h3>
<pre><code class="language-text">CPU 實現原子操作的三種方式：

┌──────────────────────────────────────────────────────────────────────────────────┐
│  方式 1：總線鎖（Bus Lock）—— 老方法，代價高                                     │
     │                                                                             │
│  CPU0   CPU1   CPU2   CPU3                                                       │
     │   │      │      │      │                                                    │
│   └──────┴──────┴───────────┘                                                    │
     │              │                                                              │
│         系統匯流排（Bus）                                                        │
     │              │                                                              │
│           記憶體（RAM）                                                          │
     │                                                                             │
│  CPU0 執行 LOCK 指令時：                                                         │
│  ① 拉低 LOCK# 信號線，獨占整條匯流排                                             │
│  ② 其他 CPU 的記憶體存取全部被阻塞                                               │
│  ③ 完成操作後釋放 LOCK# 信號線                                                   │
     │                                                                             │
│  缺點：鎖住整條匯流排，其他無關的記憶體操作也被阻塞，性能差                      │
└──────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────┐
│  方式 2：快取鎖（Cache Lock）+ MESI 協議 —— 現代主流                             │
     │                                                                             │
│  ┌──────────────────┐     ┌────────────────────────┐                             │
│  │      CPU0        │     │      CPU1              │                             │
│  │  ┌────────────┐  │     │  ┌──────────────────┐  │                             │
│  │  │ L1 Cache   │  │     │  │ L1 Cache         │  │                             │
│  │  │ [x] M ─────┼──┼─────┼──┼─[x] I     │  │  M=Modified, I=Invalid             │
│  │  └────────────┘  │     │  └──────────────────┘  │                             │
│  └──────────────────┘     └────────────────────────┘                             │
     │                                                                             │
│  CPU0 對 x 做原子操作時：                                                        │
│  ① CPU0 將 x 所在的快取行標記為 Modified（獨占修改）                             │
│  ② 通過 MESI 協議，通知 CPU1 其快取行變為 Invalid（無效）                        │
│  ③ CPU0 完成修改後，數據透過快取一致性協議同步                                   │
     │                                                                             │
│  優點：只鎖定快取行，不鎖整條匯流排，範圍更小、性能更好                          │
│  限制：跨快取行（Cache Line Boundary）的操作仍需要總線鎖                         │
└──────────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────────┐
│  方式 3：CAS 指令（Compare-And-Swap）—— 無鎖演算法基石                           │
     │                                                                             │
│  x86 指令：CMPXCHG（Compare and Exchange）                                       │
     │                                                                             │
│  偽代碼（原子執行，不可被中斷）：                                                │
│  ┌───────────────────────────────────────────────────────────────┐               │
│  │  atomic {                                                     │               │
│  │      if (*addr == expected) {                                 │               │
│  │          *addr = new_value;                                   │               │
│  │          return SUCCESS;                                      │               │
│  │      } else {                                                 │               │
│  │          return FAIL;      // 呼叫方通常自旋重試              │               │
│  │      }                                                        │               │
│  │  }                                                            │               │
│  └───────────────────────────────────────────────────────────────┘               │
     │                                                                             │
│  優點：無鎖、輕量；缺點：ABA 問題（需加版本號解決）                              │
└──────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>總線鎖（老方法）</li>
<li>快取鎖（現代常見）</li>
<li>原子指令（如 CAS）</li>
</ul>
<h2 id="53-互斥鎖模型對應-531532"><a class="header" href="#53-互斥鎖模型對應-531532">5.3 互斥鎖模型（對應 5.3.1~5.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-17"><a class="header" href="#本小節示意圖-17">本小節示意圖</a></h3>
<pre><code class="language-text">互斥鎖完整生命週期（含 OS 阻塞/喚醒路徑）：

  Thread 1 時間軸：
  ──────────────────────────────────────────────────────────────────────────►
  [正常執行] ──► [lock()] ──► [臨界區工作] ──► [unlock()] ──► [正常執行]
                                             │                              │
                  │ 成功獲取鎖（快路徑，             │ 釋放鎖
                  │ futex 不陷入核心）                                      │
                  ▼                              ▼
            進入臨界區                      喚醒等待佇列中的 Thread 2

  Thread 2 時間軸（競爭失敗的情況）：
  ──────────────────────────────────────────────────────────────────────────►
  [正常執行] ──► [lock()] ──► ░░░░░░░░░░░░░░░░░░░░░░ ──► [臨界區工作] ──►
                  │           ▲                  ▲
                  │    阻塞等待（OS 掛起 Thread 2）│ 被喚醒，重新競爭
                  ▼                                                         │
          ┌──────────────────────────────────────────────┐                  │
          │  OS 核心層                                   │                  │
                                      │                  │                  │
          │  futex 系統呼叫                              │                  │
          │  Thread2 進入                                │                  │
          │  等待佇列（睡眠）  │────────────────────────────────────────────┘
          │                  │    Thread1 unlock() 後
          └──────────────────┘    OS 喚醒 Thread2

  鎖的兩個路徑：

  快路徑（Fast Path）—— 無競爭：
  lock() ──► CAS 操作成功 ──► 進入臨界區         （不需要 syscall，最快）

  慢路徑（Slow Path）—— 有競爭：
  lock() ──► CAS 失敗 ──► futex_wait（陷入核心）
           ──► 睡眠等待 ──► 被 unlock 方的 futex_wake 喚醒
           ──► 重新嘗試 CAS ──► 進入臨界區

  ⚠ 每次 syscall（陷入核心）大約耗時 1000~5000 ns
  ⚠ 高競爭下鎖的開銷可能超過臨界區本身的工作量
</code></pre>
<p>鎖把臨界區包起來，保證同時只有一個執行緒改共享資料。</p>
<h2 id="54-cas"><a class="header" href="#54-cas">5.4 CAS</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-18"><a class="header" href="#本小節示意圖-18">本小節示意圖</a></h3>
<pre><code class="language-text">CAS（Compare-And-Swap）完整流程：

  呼叫：CAS(addr, expected=10, new=11)

  ┌─────────────────────────────────────────────────────────────────────────┐
      │                                                                     │
  │  ① Load old value                                                       │
  │     old = *addr   → old = 10                                            │
      │                          │                                          │
  │  ② Compare                                                              │
  │     old == expected?  10 == 10 ?                                        │
      │                          │                                          │
  │              ┌───────────┴───────────────┐                              │
  │              │ YES（匹配）            │ NO（不匹配）                    │
  │              ▼                       ▼                                  │
  │  ③a Swap new value      ③b 返回 FAIL                                    │
  │     *addr = new = 11        呼叫方重試                                  │
  │     返回 SUCCESS                  │                                     │
      │              │                │                                     │
  │              └───────────┬───────┘                                      │
  │                          ▼                                              │
  │                   整個步驟由 CPU 原子執行                               │
  │                   其他 CPU 看不到中間狀態                               │
  └─────────────────────────────────────────────────────────────────────────┘

  CAS 自旋重試模式（無鎖計數器的典型用法）：

  ┌─────────────────────────────────────────────────────────────────────────┐
  │  loop {                                                                 │
  │      old = atomic_load(counter)   ← 讀取當前值                          │
      │                                                                     │
  │      new = old + 1                ← 計算期望新值                        │
      │                                                                     │
  │      if CAS(counter, old, new) {  ← 原子地「確認沒人改過再寫入」        │
  │          break                    ← 成功，退出                          │
  │      }                                                                  │
  │      // 失敗：說明 counter 已被其他執行緒改變，重新讀取再試             │
  │  }                                                                      │
  └─────────────────────────────────────────────────────────────────────────┘

  ABA 問題（CAS 的已知陷阱）：

  時間  執行緒 T1              執行緒 T2
  ──── ────────────────────── ──────────────────────────────────────
   t1  load: old = A
   t2                         CAS(A → B) 成功，值改為 B
   t3                         CAS(B → A) 成功，值又改回 A
   t4  CAS(A → C) 成功！      ← T1 誤以為沒人動過，但其實發生了 A→B→A

  解法：使用帶版本號的 CAS（如 Java AtomicStampedReference）
  CAS(addr, (expected_val, expected_stamp), (new_val, new_stamp + 1))
</code></pre>
<p>先比對舊值，符合才寫入新值，不符合就重試。</p>
<h2 id="示意圖-4"><a class="header" href="#示意圖-4">示意圖</a></h2>
<pre><code class="language-text">CAS 成功/失敗對比：

  初始：counter = 10

  情況 A（CAS 成功）：
  T1: load=10 → CAS(addr, expect=10, new=11) → 10==10 → swap → counter=11 ✓

  情況 B（CAS 失敗，觸發重試）：
  T1: load=10 → [T2 搶先改成 11] → CAS(addr, expect=10, new=11) → 10≠11 → FAIL
  T1: load=11 → CAS(addr, expect=11, new=12) → 11==11 → swap → counter=12 ✓
</code></pre>
<h2 id="跨語言完整範例-4"><a class="header" href="#跨語言完整範例-4">跨語言完整範例</a></h2>
<p>CAS 自旋計數器（多執行緒安全遞增，無鎖實作）。</p>
<h3 id="cgcc-atomic--cas-自旋"><a class="header" href="#cgcc-atomic--cas-自旋">C（GCC atomic + CAS 自旋）</a></h3>
<pre><code class="language-c">#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define ITER    100000

atomic_long counter = 0;

long cas_increment(atomic_long *c) {
    long old, new_val;
    do {
        old = atomic_load_explicit(c, memory_order_relaxed);
        new_val = old + 1;
    } while (!atomic_compare_exchange_weak_explicit(
                 c, &amp;old, new_val,
                 memory_order_release,
                 memory_order_relaxed));
    return new_val;
}

void *worker(void *arg) {
    for (int i = 0; i &lt; ITER; i++)
        cas_increment(&amp;counter);
    return NULL;
}

int main(void) {
    pthread_t tid[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("counter = %ld (expected %d)\n", counter, THREADS * ITER);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -std=c11 -O2 -o cas_counter cas_counter.c -lpthread &amp;&amp; ./cas_counter
</code></pre>
<h3 id="cstdatomic-compare_exchange_weak"><a class="header" href="#cstdatomic-compare_exchange_weak">C++（std::atomic compare_exchange_weak）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;vector&gt;

const int THREADS = 4, ITER = 100000;
std::atomic&lt;long&gt; counter{0};

void cas_increment(std::atomic&lt;long&gt; &amp;c) {
    long old_val = c.load(std::memory_order_relaxed);
    while (!c.compare_exchange_weak(
               old_val, old_val + 1,
               std::memory_order_release,
               std::memory_order_relaxed))
        ;   // old_val 自動被更新為最新值，繼續重試
}

void worker() {
    for (int i = 0; i &lt; ITER; i++)
        cas_increment(counter);
}

int main() {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) ts.emplace_back(worker);
    for (auto &amp;t : ts) t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * ITER &lt;&lt; ")\n";
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -O2 -o cas_counter cas_counter.cpp -lpthread &amp;&amp; ./cas_counter
</code></pre>
<h3 id="rustatomici64--compare_exchange"><a class="header" href="#rustatomici64--compare_exchange">Rust（AtomicI64 + compare_exchange）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicI64, Ordering};
use std::thread;

const THREADS: usize = 4;
const ITER: i64 = 100_000;

fn cas_increment(counter: &amp;AtomicI64) {
    loop {
        let old = counter.load(Ordering::Relaxed);
        match counter.compare_exchange_weak(
            old, old + 1,
            Ordering::Release,
            Ordering::Relaxed,
        ) {
            Ok(_) =&gt; break,
            Err(_) =&gt; continue,   // 失敗，重試（old 已自動更新）
        }
    }
}

fn main() {
    let counter = Arc::new(AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { cas_increment(&amp;c); }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})", counter.load(Ordering::SeqCst), THREADS as i64 * ITER);
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gosyncatomic-compareandswap"><a class="header" href="#gosyncatomic-compareandswap">Go（sync/atomic CompareAndSwap）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

const threads, iter = 4, 100_000

func casIncrement(counter *int64) {
    for {
        old := atomic.LoadInt64(counter)
        if atomic.CompareAndSwapInt64(counter, old, old+1) {
            break   // 成功
        }
        // 失敗：counter 已被其他 goroutine 改變，重試
    }
}

func main() {
    var counter int64
    var wg sync.WaitGroup
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                casIncrement(&amp;counter)
            }
        }()
    }
    wg.Wait()
    fmt.Printf("counter = %d (expected %d)\n", counter, threads*iter)
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="python模擬-casthreadinglock-實作"><a class="header" href="#python模擬-casthreadinglock-實作">Python（模擬 CAS，threading.Lock 實作）</a></h3>
<pre><code class="language-python">import threading

class AtomicInt:
    """模擬 CAS 語意的原子整數（Python 無原生 CAS，用鎖模擬語意）"""
    def __init__(self, value: int = 0):
        self._value = value
        self._lock = threading.Lock()

    def compare_and_swap(self, expected: int, new: int) -&gt; bool:
        with self._lock:
            if self._value == expected:
                self._value = new
                return True
            return False

    def load(self) -&gt; int:
        with self._lock:
            return self._value

def cas_increment(counter: AtomicInt):
    while True:
        old = counter.load()
        if counter.compare_and_swap(old, old + 1):
            break

THREADS, ITER = 4, 100_000
counter = AtomicInt(0)

def worker():
    for _ in range(ITER):
        cas_increment(counter)

if __name__ == "__main__":
    threads = [threading.Thread(target=worker) for _ in range(THREADS)]
    for t in threads: t.start()
    for t in threads: t.join()
    print(f"counter = {counter.load()} (expected {THREADS * ITER})")
</code></pre>
<pre><code class="language-bash">python3 cas_counter.py
</code></pre>
<h2 id="完整專案級範例python-4"><a class="header" href="#完整專案級範例python-4">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch05.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch05.py
</code></pre>
<pre><code class="language-python">"""Chapter 05: atomicity with CAS-like primitive.

展示：
1. CAS（Compare-And-Swap）的語意：比對舊值，符合才寫入新值
2. 多執行緒安全遞增（無鎖計數器模擬）
3. CAS 失敗時重試機制
"""
import threading


class AtomicInt:
    def __init__(self, value: int = 0):
        self._v = value
        self._m = threading.Lock()

    def compare_and_swap(self, expect: int, new: int) -&gt; bool:
        with self._m:
            if self._v == expect:
                self._v = new
                return True
            return False

    def get(self) -&gt; int:
        with self._m:
            return self._v


def cas_increment(a: AtomicInt):
    """CAS 自旋重試直到成功。"""
    while True:
        old = a.get()
        if a.compare_and_swap(old, old + 1):
            break


if __name__ == "__main__":
    a = AtomicInt(10)
    print("cas 10-&gt;11", a.compare_and_swap(10, 11), "now", a.get())
    print("cas 10-&gt;12", a.compare_and_swap(10, 12), "now", a.get())  # 失敗，值已是 11

    # 多執行緒 CAS 計數器
    counter = AtomicInt(0)
    THREADS, ITER = 4, 10000
    ts = [threading.Thread(target=lambda: [cas_increment(counter) for _ in range(ITER)])
          for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"final counter = {counter.get()} (expected {THREADS * ITER})")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第6章-可見性與有序性底層"><a class="header" href="#第6章-可見性與有序性底層">第6章 可見性與有序性底層</a></h1>
<h2 id="61-多級快取對應-611613"><a class="header" href="#61-多級快取對應-611613">6.1 多級快取（對應 6.1.1~6.1.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-19"><a class="header" href="#本小節示意圖-19">本小節示意圖</a></h3>
<pre><code class="language-text">  多核 CPU 多級快取延遲金字塔
  ════════════════════════════════════════════════════════

           ┌─────────────────────────────────────────────┐
           │           CPU Die                           │
                   │                                     │
           │  ┌──────────┐    ┌──────────────────┐       │
           │  │  Core 0  │    │  Core 1          │       │
                   │  │          │    │          │       │
           │  │ ┌──────┐ │    │ ┌──────────────┐ │       │
           │  │ │  L1  │ │    │ │  L1          │ │       │
           │  │ │32-64K│ │    │ │32-64K        │ │       │
           │  │ │~4 cy │ │    │ │~4 cy         │ │       │
           │  │ └──┬───┘ │    │ └──┬───────────┘ │       │
                    │  │   │     │    │    │     │       │
           │  │ ┌──▼───┐ │    │ ┌──▼───────────┐ │       │
           │  │ │  L2  │ │    │ │  L2          │ │       │
           │  │ │256K  │ │    │ │256K          │ │       │
           │  │ │~12 cy│ │    │ │~12 cy        │ │       │
           │  │ └──┬───┘ │    │ └──┬───────────┘ │       │
           │  └────┼─────┘    └────┼─────────────┘       │
                   │       │               │             │
           │       └───────┬───────────────┘             │
           │            ┌──▼───────────┐                 │
           │            │  L3  │  共享快取               │
           │            │ 8-32M        │                 │
           │            │~40 cy        │                 │
           │            └──┬───────────┘                 │
           └───────────────┼─────────────────────────────┘
                                                         │
                        ┌──▼─────────────────────────────┐
                        │   RAM    │  主記憶體
                        │  GB 級                         │
                        │ ~200 cy                        │
                        └──┬─────────────────────────────┘
                                                         │
                        ┌──▼─────────────────────────────┐
                        │   磁碟   │  持久儲存
                        │  TB 級                         │
                        │~10M cy                         │
                        └────────────────────────────────┘

  存取延遲對比（越往下越慢）：
  ┌──────────────┬──────────────┬────────────────────────┐
  │ 快取層級     │ 存取延遲     │ 說明                   │
  ├──────────────┼──────────────┼────────────────────────┤
  │ L1 Cache     │    ~4 cycles │ 每核私有，最快         │
  │ L2 Cache     │   ~12 cycles │ 每核私有，較大         │
  │ L3 Cache     │   ~40 cycles │ 多核共享               │
  │ RAM          │  ~200 cycles │ 通過記憶體匯流排存取   │
  │ SSD          │  ~100K cycles│ NVMe 介面              │
  │ HDD/磁碟     │  ~10M cycles │ 機械旋轉延遲           │
  └──────────────┴──────────────┴────────────────────────┘

  ⚠ 重點：Core0 修改的資料在 L1/L2 中，Core1 可能看到舊值
           必須靠快取一致性協議保證多副本同步
</code></pre>
<p>L1/L2/L3 讓 CPU 讀寫更快，但也帶來多副本一致性問題。</p>
<h2 id="62-快取一致性對應-621625"><a class="header" href="#62-快取一致性對應-621625">6.2 快取一致性（對應 6.2.1~6.2.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-20"><a class="header" href="#本小節示意圖-20">本小節示意圖</a></h3>
<pre><code class="language-text">  MESI 協議四狀態轉換圖
  ════════════════════════════════════════════════════════

  狀態定義：
  ┌─────────────┬────────────────────────────────────────────┐
  │ M (Modified)│ 本核修改過，其他核無副本，與 RAM 不同      │
  │ E (Exclusive)│ 本核獨有，與 RAM 相同，無其他副本         │
  │ S (Shared)  │ 多核共有，與 RAM 相同                      │
  │ I (Invalid) │ 快取行無效，需重新從其他核/RAM 取          │
  └─────────────┴────────────────────────────────────────────┘

  狀態機轉換：
                      ┌──────────────────────────────────────┐
              本核讀命中 ◄─┤  E (Exclusive)  ├─► 本核寫命中
              不需總線操作  └────────┬────────┘   M (Modified)
                                                             │
                          其他核讀（Bus Read）
                                    │ 降級共享
                                    ▼
  ┌──────────────┐         ┌─────────────────────────────────┐
  │ M (Modified) │         │  S (Shared)                     │
  │              │◄────────                 │                │
  │ 本核寫：不需  │  本核寫   │ 多核可同時持有               │
  │ 總線操作      │  發送    │ 只能讀，不能寫                │
  └──────┬───────┘ Invalidate└───────┬───────────────────────┘
         │        給其他核                                   │
         │ 其他核讀時                 │ 所有核清除或被替換
         │ 回寫 RAM + 降為 S                                 │
         ▼                           ▼
  ┌──────────────────────────────────────────────────────────┐
  │              I (Invalid)                                 │
  │         快取行無效，需要重新載入                         │
  └──────────────────────────────────────────────────────────┘

  Core0 寫入流程（從 S → M，令 Core1 失效）：
  ┌──────────────────────────────────────────────────────────┐
  │  時間                                                    │
       │   │                                                 │
  │   │  1. Core0 和 Core1 都持有 x=10（S 狀態）             │
  │   │     Core0 L1: [x=10, S]   Core1 L1: [x=10, S]        │
       │   │                                                 │
  │   │  2. Core0 寫入 x=20                                  │
  │   │     Core0 發送 BusUpgr（Invalidate）給 Core1         │
  │   │     ─────────────────────────────────────────►       │
  │   │     Core1 L1: [x=10, I]  ← 標記無效                  │
  │   │     Core0 L1: [x=20, M]  ← 獨占修改                  │
       │   │                                                 │
  │   │  3. Core1 之後讀 x                                   │
  │   │     發現是 I（Invalid），發出 BusMiss                │
  │   │     Core0 攔截，回寫 x=20 到 RAM                     │
  │   │     Core1 從 RAM 讀 x=20（S 狀態）                   │
  │   ▼                                                      │
  └──────────────────────────────────────────────────────────┘
</code></pre>
<p>MESI 等協議保證核心間最終一致。</p>
<h2 id="63-偽共享對應-631633"><a class="header" href="#63-偽共享對應-631633">6.3 偽共享（對應 6.3.1~6.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-21"><a class="header" href="#本小節示意圖-21">本小節示意圖</a></h3>
<pre><code class="language-text">  偽共享（False Sharing）問題示意
  ════════════════════════════════════════════════════════

  問題：x 和 y 落在同一個 64-byte 快取行

  記憶體布局：
  ┌─────────────────────────────────────────────────────┐
  │              64-byte Cache Line                     │
  │  ┌──────────┬──────────┬────────────────────────┐   │
  │  │  x (8B)  │  y (8B)  │   padding...  (48B)    │   │
  │  │  addr 0  │  addr 8  │   addr 16~63           │   │
  │  └──────────┴──────────┴────────────────────────┘   │
  └─────────────────────────────────────────────────────┘
        ↑                ↑
    Core0 寫 x       Core1 寫 y

  結果（每次寫都會使對方快取行失效）：
  ┌─────────────────────────────────────────────────────┐
  │  Core0 寫 x=1                                       │
  │    → 整條 64B Cache Line 變 M 狀態                  │
  │    → 發 Invalidate 給 Core1                         │
  │    → Core1 的 y 雖然沒動，快取行也失效！            │
     │                                                  │
  │  Core1 要讀/寫 y                                    │
  │    → Cache Miss（因為被 Core0 的寫 x 連帶失效）     │
  │    → 必須等 Core0 回寫，再從 RAM 重新載入           │
  │    → 效能劇烈下降（可能慢 10~100 倍）               │
  └─────────────────────────────────────────────────────┘

  解法 1：填充（Padding）讓 x 和 y 各占獨立快取行
  ┌─────────────────────────────────────────────────────┐
  │   Cache Line 0 (64B)    │   Cache Line 1 (64B)      │
  │  ┌──────┬─────────────┐ │ ┌──────┬───────────────┐  │
  │  │  x   │ padding 56B │ │ │  y   │ padding 56B   │  │
  │  └──────┴─────────────┘ │ └──────┴───────────────┘  │
  │       Core0 操作         │      Core1 操作          │
  └─────────────────────────────────────────────────────┘
  Core0 修改 x → 只影響 Cache Line 0，不影響 Core1

  解法 2：編譯器對齊屬性
  C：    __attribute__((aligned(64))) int x;
  C++：  alignas(64) int x;
  Rust： #[repr(align(64))] struct PaddedCell { val: i64 }
  Go：   使用 atomic + 手動補位元組到 64B
</code></pre>
<p>不同變數落在同一 cache line，互相拖慢。</p>
<h2 id="64-volatile-類語義對應-641643"><a class="header" href="#64-volatile-類語義對應-641643">6.4 volatile 類語義（對應 6.4.1~6.4.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-22"><a class="header" href="#本小節示意圖-22">本小節示意圖</a></h3>
<pre><code class="language-text">  volatile 可見性語義：寫前 StoreStore + 讀後 LoadLoad
  ════════════════════════════════════════════════════════

  Thread 1 (Writer)                Thread 2 (Reader)
  ──────────────────               ─────────────────────
  write data = 42          │       read result = flag
                                                             │
  ┌─ StoreStore Fence ──┐  │       ┌─ LoadLoad Fence ────────┐
  │  確保 data 寫入先    │  │       │  確保 flag 讀出後      │
  │  於 flag 寫入可見    │  │       │  才讀 data             │
  └─────────────────────┘  │       └─────────────────────────┘
                            │               │                │
           ▼               │                ▼
  write flag = true        │       if flag == true:
  （volatile write）       │           use data  ← 保證看到 42
                                             │               │
           └──── 可見性保證（flush store buffer）──────►

  volatile 的保證與限制：
  ┌──────────────────────────────────────────────────────────┐
  │  ✅ 保證：每次讀都從主記憶體/快取一致視圖讀取            │
  │  ✅ 保證：每次寫都立即刷新到主記憶體                     │
  │  ✅ 保證：寫操作對其他執行緒可見（happens-before）       │
       │                                                     │
  │  ❌ 不保證：複合操作原子性                               │
  │     volatile int v = 0;                                  │
  │     v++;  // 等同 v = v + 1，read-modify-write           │
  │            // 兩個執行緒各自讀 0，都寫 1 → 遺失更新      │
  └──────────────────────────────────────────────────────────┘

  四種語言的 volatile 對應：
  ┌──────────┬───────────────────────────────────────────────┐
  │ 語言     │ volatile / 可見性 API                         │
  ├──────────┼───────────────────────────────────────────────┤
  │ C/C++    │ volatile（只阻止編譯器重排，非執行緒安全）    │
  │          │ atomic_store/load（正確做法）                 │
  │ Rust     │ AtomicXxx::store/load(Ordering)               │
  │ Go       │ sync/atomic.Store/Load                        │
  └──────────┴───────────────────────────────────────────────┘
</code></pre>
<p>可見性強，但不保證複合操作原子性。</p>
<h2 id="65-指令重排與屏障對應-651654"><a class="header" href="#65-指令重排與屏障對應-651654">6.5 指令重排與屏障（對應 6.5.1~6.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-23"><a class="header" href="#本小節示意圖-23">本小節示意圖</a></h3>
<pre><code class="language-text">  四種記憶體屏障（Memory Fence）類型
  ════════════════════════════════════════════════════════

  屏障阻止跨越屏障的重排序（時間從上到下）：

  ┌─────────────────┬────────────────────────────────────┐
  │  LoadLoad        │  確保屏障前的 Load 先於後面的 Load│
   │                  │                                  │
  │  load A          │  ─────── 屏障上方 ───────         │
  │  ── LL Fence ──  │  ══════════════════════════════   │
  │  load B          │  ─────── 屏障下方 ───────         │
  │  保證 A 先於 B   │  A 的結果對下方 Load 可見         │
  └─────────────────┴────────────────────────────────────┘

  ┌─────────────────┬────────────────────────────────────┐
  │  LoadStore       │  確保屏障前的 Load 先於後面的Store│
   │                  │                                  │
  │  load A          │  通常用於避免載入後的寫被提前     │
  │  ── LS Fence ──   │                                  │
  │  store B          │                                  │
  └─────────────────┴────────────────────────────────────┘

  ┌─────────────────┬────────────────────────────────────┐
  │  StoreStore      │  確保屏障前的 Store 先於後面Store │
   │                  │                                  │
  │  store A         │  ─────── 屏障上方 ───────         │
  │  ── SS Fence ──  │  ══════════════════════════════   │
  │  store B         │  ─────── 屏障下方 ───────         │
  │  保證 A 先寫出   │  A 對其他核的可見先於 B           │
  └─────────────────┴────────────────────────────────────┘

  ┌─────────────────┬────────────────────────────────────┐
  │  StoreLoad       │  最重的屏障，確保前面 Store 對所有│
  │  （全屏障）      │  核可見後，才執行後面的 Load      │
   │                  │                                  │
  │  store A         │  必須刷新 Store Buffer + 清空     │
  │  ── SL Fence ──  │  Invalidate Queue                 │
  │  load B          │  代價最高，x86 用 MFENCE          │
  └─────────────────┴────────────────────────────────────┘

  Acquire / Release 語義包含的 Fence：

  Release（寫端）：          Acquire（讀端）：
  ┌──────────────────┐       ┌───────────────────────────┐
  │  普通寫操作       │       │  acquire load            │
  │  普通寫操作               │       │                  │
  │  ─ SS Fence ──   │       │  ─ LL + LS ──             │
  │  ─ LS Fence ──   │       │    Fence                  │
  │  release store            │       │                  │
  └──────────────────┘       │  普通讀操作               │
  保證 release 前的寫         └──────────────────────────┘
  在 release store 之前可見   保證 acquire 後的讀
                              在 acquire load 之後
</code></pre>
<p>Memory Fence 阻止特定方向的重排。</p>
<h2 id="66-記憶體模型對應-661663"><a class="header" href="#66-記憶體模型對應-661663">6.6 記憶體模型（對應 6.6.1~6.6.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-24"><a class="header" href="#本小節示意圖-24">本小節示意圖</a></h3>
<pre><code class="language-text">  各語言記憶體模型與同步 API 對比
  ════════════════════════════════════════════════════════

  ┌──────────┬──────────────────┬───────────────────────────────────────┐
  │ 語言     │ 記憶體模型        │ 同步操作 API / 保證                  │
  ├──────────┼──────────────────┼───────────────────────────────────────┤
  │ C11/C17  │ C11 Memory Model │ atomic_store(relaxed/release/seq_cst) │
  │          │ 弱序 + 顯式標注   │ atomic_load(relaxed/acquire/seq_cst) │
  │          │                  │ atomic_thread_fence(memory_order_*)   │
  ├──────────┼──────────────────┼───────────────────────────────────────┤
  │ C++11+   │ C++ Memory Model │ std::atomic&lt;T&gt;::store(memory_order)   │
  │          │ 與 C11 相近      │ std::atomic&lt;T&gt;::load(memory_order)    │
  │          │                  │ memory_order_{relaxed,acquire,        │
  │          │                  │   release,acq_rel,seq_cst}            │
  ├──────────┼──────────────────┼───────────────────────────────────────┤
  │ Rust     │ C++ 相容         │ AtomicI32::store(val, Ordering::*)    │
  │          │ 型別系統強制      │ AtomicI32::load(Ordering::*)         │
  │          │ 所有權排除競爭    │ Ordering::{Relaxed,Acquire,          │
  │          │                  │   Release,AcqRel,SeqCst}              │
  ├──────────┼──────────────────┼───────────────────────────────────────┤
  │ Go       │ Go Memory Model  │ sync/atomic.Store/Load                │
  │          │ 較簡單，happens- │ sync.Mutex / sync.RWMutex             │
  │          │ before 為主      │ channel send/recv（天然同步點）       │
  │          │                  │ 無顯式 memory_order 選擇              │
  └──────────┴──────────────────┴───────────────────────────────────────┘

  強弱排序光譜：
  弱序（性能高，推理難）                    強序（性能低，推理易）
  ────────────────────────────────────────────────────────►
  Relaxed        Acquire/Release       SeqCst（全序）
  （無同步）      （happens-before）    （全局一致順序）
  僅原子性        producer-consumer     計數器、旗標
</code></pre>
<p>Java、C++、Rust、Go 都定義了跨執行緒可見性規則。</p>
<h2 id="67-happens-before對應-671679"><a class="header" href="#67-happens-before對應-671679">6.7 happens-before（對應 6.7.1~6.7.9）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-25"><a class="header" href="#本小節示意圖-25">本小節示意圖</a></h3>
<pre><code class="language-text">  happens-before（HB）傳遞鏈示意
  ════════════════════════════════════════════════════════

  執行緒 T1                     執行緒 T2
  ──────────────────            ──────────────────
  data = 42           ─── HB ──► (HB 傳遞)
      │ HB（程式順序）                                    │
  unlock(L)           ═══ HB ══► lock(L)
                                 │ HB（程式順序）
                                read data → 42 ✅

  HB 鏈推導：
  ┌───────────────────────────────────────────────────────┐
  │  data = 42                                            │
  │      │ HB（T1 程式順序：先寫 data 再 unlock）         │
  │      ▼                                                │
  │  unlock(L)                                            │
  │      │ HB（同步動作：unlock HB lock 同一把鎖）        │
  │      ▼                                                │
  │  lock(L)   ← T2 獲取同一把鎖                          │
  │      │ HB（T2 程式順序：先 lock 再讀 data）           │
  │      ▼                                                │
  │  read data → 保證看到 42（HB 具傳遞性）               │
  └───────────────────────────────────────────────────────┘

  建立 happens-before 的常見同步事件：
  ┌───────────────────────────────────────────────────────┐
  │  同步事件                  HB 關係                    │
  ├───────────────────────────────────────────────────────┤
  │  unlock(L)           HB    lock(L)（同一鎖）          │
  │  volatile write      HB    volatile read（後發生）    │
  │  thread.start()      HB    執行緒內第一個動作         │
  │  執行緒最後動作       HB    thread.join() 返回        │
  │  channel send        HB    channel recv（Go）         │
  │  release store       HB    acquire load（C++/Rust）   │
  └───────────────────────────────────────────────────────┘

  HB 具有傳遞性：若 A HB B 且 B HB C，則 A HB C
  ┌───┐  HB  ┌───┐  HB  ┌─────────────────────────────────┐
  │ A │─────►│ B │─────►│ C │   則 A HB C
  └───┘      └───┘      └─────────────────────────────────┘
</code></pre>
<p>能建立 happens-before 的同步事件，才可推導正確性。</p>
<pre><code class="language-text">unlock(L) happens-before lock(L)
write(x) in T1 before unlock -&gt; T2 lock 後可見
</code></pre>
<h2 id="示意圖-5"><a class="header" href="#示意圖-5">示意圖</a></h2>
<pre><code class="language-text">Core0 write -&gt; StoreBuffer -&gt; L1 -&gt; L2/L3 -&gt; Core1 read
需要一致性協議 + memory order 才能正確觀察
</code></pre>
<h2 id="跨語言完整範例-5"><a class="header" href="#跨語言完整範例-5">跨語言完整範例</a></h2>
<p>主題：release-acquire 語義傳遞數據（producer 設 data 後 release store flag，consumer acquire load flag 後讀 data）</p>
<h3 id="cc11-atomics"><a class="header" href="#cc11-atomics">C（C11 atomics）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch06_c ch06.c
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

static int data = 0;
static atomic_int flag = ATOMIC_VAR_INIT(0);

void *producer(void *arg) {
    data = 42;                                          // 普通寫
    atomic_store_explicit(&amp;flag, 1, memory_order_release); // release
    return NULL;
}

void *consumer(void *arg) {
    int f;
    while ((f = atomic_load_explicit(&amp;flag, memory_order_acquire)) == 0)
        ;                                               // spin acquire
    printf("consumer: data = %d (expected 42)\n", data);
    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, consumer, NULL);
    pthread_create(&amp;t2, NULL, producer, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
</code></pre>
<h3 id="cstdatomic-releaseacquire"><a class="header" href="#cstdatomic-releaseacquire">C++（std::atomic release/acquire）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch06_cpp ch06.cpp
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

static int data = 0;
static std::atomic&lt;int&gt; flag{0};

void producer() {
    data = 42;                                          // 普通寫
    flag.store(1, std::memory_order_release);           // release store
}

void consumer() {
    while (flag.load(std::memory_order_acquire) == 0)  // acquire load
        ;                                               // spin
    std::cout &lt;&lt; "consumer: data = " &lt;&lt; data
              &lt;&lt; " (expected 42)\n";
}

int main() {
    std::thread t1(consumer);
    std::thread t2(producer);
    t1.join();
    t2.join();
}
</code></pre>
<h3 id="rustatomic-releaseacquire"><a class="header" href="#rustatomic-releaseacquire">Rust（Atomic release/acquire）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch06.rs &amp;&amp; ./ch06
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(AtomicI32::new(0));
    let flag = Arc::new(AtomicI32::new(0));

    let (d2, f2) = (Arc::clone(&amp;data), Arc::clone(&amp;flag));
    let producer = thread::spawn(move || {
        d2.store(42, Ordering::Relaxed);               // 普通原子寫
        f2.store(1, Ordering::Release);                // release store
    });

    let (d1, f1) = (Arc::clone(&amp;data), Arc::clone(&amp;flag));
    let consumer = thread::spawn(move || {
        while f1.load(Ordering::Acquire) == 0 {}       // acquire load spin
        println!("consumer: data = {} (expected 42)",
                 d1.load(Ordering::Relaxed));
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<h3 id="gosyncatomic--channel-同步"><a class="header" href="#gosyncatomic--channel-同步">Go（sync/atomic + channel 同步）</a></h3>
<pre><code class="language-go">// 執行：go run ch06.go
package main

import (
	"fmt"
	"sync/atomic"
)

var data int64
var flag atomic.Int32

func main() {
	done := make(chan struct{})

	go func() { // consumer
		for flag.Load() == 0 { // acquire-like（Go atomic 隱含 seq_cst）
		}
		val := atomic.LoadInt64(&amp;data)
		fmt.Printf("consumer: data = %d (expected 42)\n", val)
		close(done)
	}()

	go func() { // producer
		atomic.StoreInt64(&amp;data, 42)
		flag.Store(1) // release-like
	}()

	&lt;-done
}
</code></pre>
<h3 id="pythonthreadingcondition-模擬-releaseacquire"><a class="header" href="#pythonthreadingcondition-模擬-releaseacquire">Python（threading.Condition 模擬 release/acquire）</a></h3>
<pre><code class="language-python"># 執行：python3 ch06.py
import threading

data = 0
flag = False
cv = threading.Condition()

def producer():
    global data, flag
    with cv:
        data = 42       # 設定 payload
        flag = True     # release：通知 consumer
        cv.notify_all()

def consumer():
    with cv:
        while not flag: # acquire：等待 flag
            cv.wait()
        print(f"consumer: data = {data} (expected 42)")

if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start()
    t1.join(); t2.join()
</code></pre>
<h2 id="完整專案級範例python-5"><a class="header" href="#完整專案級範例python-5">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch06.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch06.py
</code></pre>
<pre><code class="language-python">"""Chapter 06: ordering with condition variable."""
import threading

cv = threading.Condition()
ready = False
payload = 0


def producer():
    global ready, payload
    with cv:
        payload = 99
        ready = True
        cv.notify_all()


def consumer():
    with cv:
        while not ready:
            cv.wait()
        print("payload=", payload)


if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start(); t1.join(); t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第7章-synchronized-與-jvm-鎖實作"><a class="header" href="#第7章-synchronized-與-jvm-鎖實作">第7章 synchronized 與 JVM 鎖實作</a></h1>
<h2 id="71-語法層對應-711713"><a class="header" href="#71-語法層對應-711713">7.1 語法層（對應 7.1.1~7.1.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-26"><a class="header" href="#本小節示意圖-26">本小節示意圖</a></h3>
<pre><code class="language-text">  synchronized 三種語法形式與 bytecode 對應
  ════════════════════════════════════════════════════════

  形式 1：實例方法（鎖 this）
  ┌─────────────────────────────────────────────────────┐
  │  Java 源碼                                          │
  │  synchronized void increment() { count++; }         │
  │                                                     │
  │  bytecode（ACC_SYNCHRONIZED flag）                  │
  │  方法描述符帶有 ACC_SYNCHRONIZED                    │
  │  JVM 執行前自動 monitorenter(this)                  │
  │  JVM 執行後自動 monitorexit(this)                   │
  │                                                     │
  │  鎖對象：this（呼叫此方法的實例）                   │
  └─────────────────────────────────────────────────────┘

  形式 2：靜態方法（鎖 Class 對象）
  ┌─────────────────────────────────────────────────────┐
  │  Java 源碼                                          │
  │  static synchronized void reset() { count = 0; }    │
  │                                                     │
  │  bytecode（ACC_STATIC + ACC_SYNCHRONIZED）          │
  │  JVM 執行前 monitorenter(Counter.class)             │
  │  JVM 執行後 monitorexit(Counter.class)              │
  │                                                     │
  │  鎖對象：Counter.class（JVM 中 Class 對象）         │
  │  ⚠ 與實例鎖不同，互不衝突                           │
  └─────────────────────────────────────────────────────┘

  形式 3：程式區塊（鎖指定對象）
  ┌─────────────────────────────────────────────────────┐
  │  Java 源碼                                          │
  │  synchronized (lockObj) {                           │
  │      // critical section                            │
  │  }                                                  │
  │                                                     │
  │  bytecode（顯式指令）                               │
  │  0: aload lockObj    ← 將鎖對象壓棧                 │
  │  1: monitorenter     ← 嘗試獲取 monitor             │
  │  2: ... body ...                                    │
  │  3: monitorexit      ← 正常退出釋放                 │
  │  4: (exception path)  │                             │
  │  5: monitorexit      ← 異常退出也釋放（finally）    │
  │                                                     │
  │  鎖對象：lockObj（任意 Object）                     │
  └─────────────────────────────────────────────────────┘

  三種形式對比：
  ┌─────────────────┬────────────────┬──────────────────┐
  │ 形式            │ 鎖對象         │ 適用場景         │
  ├─────────────────┼────────────────┼──────────────────┤
  │ 實例方法        │ this           │ 保護實例狀態     │
  │ 靜態方法        │ ClassName.class│ 保護靜態狀態     │
  │ synchronized 塊 │ 指定 Object    │ 精細控制臨界區   │
  └─────────────────┴────────────────┴──────────────────┘
</code></pre>
<ul>
<li>實例方法鎖 <code>this</code></li>
<li>類方法鎖 <code>Class</code></li>
<li>程式區塊鎖指定對象</li>
</ul>
<h2 id="7273-物件頭與鎖標記對應-721733"><a class="header" href="#7273-物件頭與鎖標記對應-721733">7.2~7.3 物件頭與鎖標記（對應 7.2.1~7.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-27"><a class="header" href="#本小節示意圖-27">本小節示意圖</a></h3>
<pre><code class="language-text">  64-bit JVM 物件頭（Mark Word）布局
  ════════════════════════════════════════════════════════

  Mark Word（64 bit = 8 bytes）在不同鎖狀態下的含義：

  無鎖狀態（biasable）：
  ┌──────────────────────────┬──────┬─────┬──┬───────────────────────────────┐
  │  hashcode (31b) / unused │ age  │  0  │0 │1                              │
  │  bit 63 ─────────── 7   │ 4b   │ 1b  │1b│1b                              │
  └──────────────────────────┴──────┴─────┴──┴───────────────────────────────┘
                                               └─ lock bits = 01

  偏向鎖（Biased Lock）：
  ┌───────────────────────────────────┬──────┬──┬──┬─────────────────────────┐
  │  Thread ID (54b)  │ epoch (2b)    │ age  │1 │0 │1                        │
  │  bit 63 ──────────────────── 10  │  4b  │1b│1b│1b                        │
  └───────────────────────────────────┴──────┴──┴──┴─────────────────────────┘
                                                   └─ lock bits = 01, biased=1

  輕量鎖（Lightweight Lock，CAS 競爭）：
  ┌────────────────────────────────────────────────┬──┬──────────────────────┐
  │  Lock Record 指針（ptr to stack frame）(62b)   │0 │0                     │
  │  bit 63 ──────────────────────────────────── 2│1b│1b                     │
  └────────────────────────────────────────────────┴──┴──────────────────────┘
                                                       └─ lock bits = 00

  重量鎖（Heavyweight Lock，OS mutex）：
  ┌────────────────────────────────────────────────┬──┬──────────────────────┐
  │  Monitor 物件指針（ptr to ObjectMonitor）(62b) │1 │0                     │
  │  bit 63 ──────────────────────────────────── 2│1b│1b                     │
  └────────────────────────────────────────────────┴──┴──────────────────────┘
                                                       └─ lock bits = 10

  GC 標記（Marked for GC）：
  ┌────────────────────────────────────────────────┬──┬──────────────────────┐
  │  forwarding pointer                            │1 │1                     │
  └────────────────────────────────────────────────┴──┴──────────────────────┘
                                                       └─ lock bits = 11

  lock bits 速查表：
  ┌───────────┬──────────────────────────────────────────────────────────────┐
  │ lock bits │ 含義                                                         │
  ├───────────┼──────────────────────────────────────────────────────────────┤
  │    01     │ 無鎖（biasable=0）或 偏向鎖（biased=1）                      │
  │    00     │ 輕量鎖（CAS LockRecord 指針）                                │
  │    10     │ 重量鎖（Monitor 物件指針）                                   │
  │    11     │ GC 標記中                                                    │
  └───────────┴──────────────────────────────────────────────────────────────┘
</code></pre>
<p>這是 JVM 實作細節：物件頭記錄鎖狀態。</p>
<h2 id="7475-monitor-與-bytecode對應-741754"><a class="header" href="#7475-monitor-與-bytecode對應-741754">7.4~7.5 Monitor 與 bytecode（對應 7.4.1~7.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-28"><a class="header" href="#本小節示意圖-28">本小節示意圖</a></h3>
<pre><code class="language-text">  ObjectMonitor 結構與 monitorenter/exit 流程
  ════════════════════════════════════════════════════════

  ObjectMonitor 內部結構：
  ┌─────────────────────────────────────────────────────┐
  │                ObjectMonitor                        │
  │                                                     │
  │  ┌──────────────────────────────────────────────┐   │
  │  │  owner: Thread*    ← 當前持有鎖的執行緒      │   │
  │  │  recursions: int   ← 重入計數器              │   │
  │  └──────────────────────────────────────────────┘   │
  │                                                     │
  │  ┌──────────────────────────────────────────────┐   │
  │  │  EntryList: LinkedList&lt;Thread&gt;               │   │
  │  │  （等待獲取鎖的執行緒佇列）                  │   │
  │  │  T2 ──► T3 ──► T4                            │   │
  │  └──────────────────────────────────────────────┘   │
  │                                                     │
  │  ┌──────────────────────────────────────────────┐   │
  │  │  WaitSet: LinkedList&lt;Thread&gt;                 │   │
  │  │  （呼叫 wait() 後進入的執行緒集合）          │   │
  │  │  T5 ──► T6                                   │   │
  │  └──────────────────────────────────────────────┘   │
  └─────────────────────────────────────────────────────┘

  monitorenter 流程：
  ┌─────────────────────────────────────────────────────┐
  │  執行緒嘗試 monitorenter                            │
  │       │                                             │
  │       ▼                                             │
  │  owner == null ?                                    │
  │  ├─ 是 ──► CAS 設定 owner = 自己 ──► 成功，進入     │
  │  │                                                  │
  │  └─ 否 ──► owner == 自己（重入）?                   │
  │            ├─ 是 ──► recursions++ ──► 進入          │
  │            │                                        │
  │            └─ 否 ──► 加入 EntryList                 │
  │                       park()（OS 睡眠）             │
  │                       等待 owner 釋放後被喚醒       │
  └─────────────────────────────────────────────────────┘

  monitorexit 流程：
  ┌─────────────────────────────────────────────────────┐
  │  執行緒執行 monitorexit                             │
  │       │                                             │
  │       ▼                                             │
  │  recursions &gt; 0 ?                                   │
  │  ├─ 是 ──► recursions-- ──► 繼續持有                │
  │  │                                                  │
  │  └─ 否 ──► owner = null                             │
  │            從 EntryList 選一個執行緒 unpark()       │
  │            被喚醒的執行緒重新競爭 monitorenter      │
  └─────────────────────────────────────────────────────┘
</code></pre>
<p>進入臨界區會走 <code>monitorenter</code>，離開走 <code>monitorexit</code>。</p>
<h2 id="76710-鎖升級與優化對應-76710"><a class="header" href="#76710-鎖升級與優化對應-76710">7.6~7.10 鎖升級與優化（對應 7.6~7.10）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-29"><a class="header" href="#本小節示意圖-29">本小節示意圖</a></h3>
<pre><code class="language-text">  JVM 鎖升級路徑（只能升級，不可降級）
  ════════════════════════════════════════════════════════

  ┌──────────────────────────────────────────────────────┐
  │                                                      │
  │  ┌──────────┐                                        │
  │  │  無鎖    │ lock bits = 01（biased=0）             │
  │  │ Unlocked │ 首次分配物件，等待首次鎖定             │
  │  └────┬─────┘                                        │
  │       │ 首次被某執行緒獲取（無競爭）                 │
  │       ▼ 在 Mark Word 記錄 Thread ID                  │
  │  ┌──────────────┐                                    │
  │  │  偏向鎖      │ lock bits = 01（biased=1）         │
  │  │ Biased Lock  │ CAS 寫入 Thread ID，後續進入免 CAS │
  │  └──────┬───────┘ 優點：單執行緒場景近乎無鎖效能     │
  │         │                                            │
  │         │ 觸發條件：另一個執行緒嘗試獲取             │
  │         │ → 觸發 STW（Stop-The-World）撤銷偏向鎖     │
  │         ▼                                            │
  │  ┌──────────────┐                                    │
  │  │  輕量鎖      │ lock bits = 00                     │
  │  │ Lightweight  │ 在執行緒棧幀建立 Lock Record       │
  │  │    Lock      │ CAS 將 Mark Word 指向 Lock Record  │
  │  └──────┬───────┘ 優點：避免 OS mutex，自旋等待      │
  │         │                                            │
  │         │ 觸發條件：CAS 自旋超過閾值（預設 10 次）   │
  │         │ 或 等待執行緒數 &gt; 1                        │
  │         ▼                                            │
  │  ┌──────────────┐                                    │
  │  │  重量鎖      │ lock bits = 10                     │
  │  │ Heavyweight  │ Mark Word 指向 ObjectMonitor       │
  │  │    Lock      │ 使用 OS Mutex（pthread_mutex）     │
  │  └──────────────┘ 代價最高，但公平，支援 wait/notify │
  │                                                      │
  │  升級觸發條件總結：                                  │
  │  ┌────────────────┬───────────────────────────────┐  │
  │  │ 無鎖 → 偏向鎖 │ 第一次被任意執行緒獲取         │  │
  │  │ 偏向鎖→輕量鎖 │ 第二個執行緒競爭（撤銷偏向）   │  │
  │  │ 輕量鎖→重量鎖 │ 自旋 CAS 失敗次數超過閾值      │  │
  │  └────────────────┴───────────────────────────────┘  │
  └──────────────────────────────────────────────────────┘
</code></pre>
<p>偏向鎖 -&gt; 輕量鎖 -&gt; 重量鎖，競爭越激烈成本越高。</p>
<pre><code class="language-text">低競爭: fast path
高競爭: 進入等待佇列 + 喚醒
</code></pre>
<p>跨語言對應：其他語言沒有 <code>synchronized</code> 關鍵字，但 runtime 也有類似 fast/slow path 優化。</p>
<h2 id="示意圖-6"><a class="header" href="#示意圖-6">示意圖</a></h2>
<pre><code class="language-text">monitor(owner=T1)
queue: T2 -&gt; T3
T1 exit monitor -&gt; wake T2
</code></pre>
<h2 id="跨語言完整範例-6"><a class="header" href="#跨語言完整範例-6">跨語言完整範例</a></h2>
<p>主題：mutex 保護共享計數器（4 個執行緒各加 10000 次，驗證最終結果正確）</p>
<h3 id="cpthread_mutex"><a class="header" href="#cpthread_mutex">C（pthread_mutex）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch07_c ch07.c
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define INCREMENTS 10000

static int counter = 0;
static pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;

void *worker(void *arg) {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        pthread_mutex_lock(&amp;mu);
        counter++;
        pthread_mutex_unlock(&amp;mu);
    }
    return NULL;
}

int main(void) {
    pthread_t threads[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;threads[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("counter = %d (expected %d)\n", counter, THREADS * INCREMENTS);
    pthread_mutex_destroy(&amp;mu);
    return 0;
}
</code></pre>
<h3 id="cstdmutex"><a class="header" href="#cstdmutex">C++（std::mutex）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch07_cpp ch07.cpp
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int THREADS = 4;
constexpr int INCREMENTS = 10000;

static int counter = 0;
static std::mutex mu;

void worker() {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        std::scoped_lock lock(mu);
        counter++;
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; THREADS; i++)
        threads.emplace_back(worker);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * INCREMENTS &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rustmutex"><a class="header" href="#rustmutex">Rust（Mutex<i32>）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch07.rs &amp;&amp; ./ch07
use std::sync::{Arc, Mutex};
use std::thread;

const THREADS: usize = 4;
const INCREMENTS: usize = 10_000;

fn main() {
    let counter = Arc::new(Mutex::new(0i32));
    let mut handles = Vec::new();

    for _ in 0..THREADS {
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..INCREMENTS {
                *counter.lock().unwrap() += 1;
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})",
             *counter.lock().unwrap(),
             THREADS * INCREMENTS);
}</code></pre></pre>
<h3 id="gosyncmutex"><a class="header" href="#gosyncmutex">Go（sync.Mutex）</a></h3>
<pre><code class="language-go">// 執行：go run ch07.go
package main

import (
	"fmt"
	"sync"
)

const (
	threads    = 4
	increments = 10000
)

func main() {
	var (
		counter int
		mu      sync.Mutex
		wg      sync.WaitGroup
	)
	for i := 0; i &lt; threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j &lt; increments; j++ {
				mu.Lock()
				counter++
				mu.Unlock()
			}
		}()
	}
	wg.Wait()
	fmt.Printf("counter = %d (expected %d)\n", counter, threads*increments)
}
</code></pre>
<h3 id="pythonthreadinglock"><a class="header" href="#pythonthreadinglock">Python（threading.Lock）</a></h3>
<pre><code class="language-python"># 執行：python3 ch07.py
import threading

THREADS = 4
INCREMENTS = 10000

counter = 0
lock = threading.Lock()

def worker():
    global counter
    for _ in range(INCREMENTS):
        with lock:
            counter += 1

if __name__ == "__main__":
    ts = [threading.Thread(target=worker) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"counter = {counter} (expected {THREADS * INCREMENTS})")
</code></pre>
<h2 id="完整專案級範例python-6"><a class="header" href="#完整專案級範例python-6">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch07.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch07.py
</code></pre>
<pre><code class="language-python">"""Chapter 07: synchronized equivalent in Python."""
import threading

lock = threading.Lock()
total = 0


def add():
    global total
    for _ in range(10000):
        with lock:
            total += 1


if __name__ == "__main__":
    ts = [threading.Thread(target=add) for _ in range(4)]
    for t in ts: t.start()
    for t in ts: t.join()
    print("total=", total)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第8章-aqs-佇列同步器"><a class="header" href="#第8章-aqs-佇列同步器">第8章 AQS 佇列同步器</a></h1>
<h2 id="81-aqs-核心對應-811812"><a class="header" href="#81-aqs-核心對應-811812">8.1 AQS 核心（對應 8.1.1~8.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-30"><a class="header" href="#本小節示意圖-30">本小節示意圖</a></h3>
<pre><code class="language-text">  AQS（AbstractQueuedSynchronizer）核心結構
  ════════════════════════════════════════════════════════

  AQS 由兩個核心元件組成：

  ┌────────────────────────────────────────────────────────┐
  │                    AQS 物件                            │
     │                                                     │
  │  state: int = 0   ← 核心同步狀態（CAS 競爭）           │
  │  head: Node*  ─────────────────────────────────────┐   │
  │  tail: Node*  ──────────────────────────────────┼────┐ │
  └──────────────────────────────────────────────────┼─┼───┘
                                                         │ │
  CLH 雙向等待佇列：                                     │ │
  ┌──────────┐    ┌──────────────┐    ┌──────────────────┐ │
  │  head    │    │   Node(T2)   │    │   Node(T3)       │ │
  │ (dummy)  │◄──►│  waitStatus  │◄──►│  waitStatus  │◄    ┘
  │  Node    │    │  = SIGNAL    │    │  = SIGNAL          │
  │          │    │  thread=T2   │    │  thread=T3         │
  └──────────┘    └──────────────┘    └──────┬─────────────┘
                                                           │
                                           tail ◄── 最後入隊

  獨占模式 acquire 流程（以 ReentrantLock.lock 為例）：
  ┌────────────────────────────────────────────────────────┐
     │                                                     │
  │  Thread 呼叫 acquire(1)                                │
     │       │                                             │
  │       ▼                                                │
  │  tryAcquire()  ─── 成功（CAS state: 0→1）──► 持有鎖    │
     │       │                                             │
  │       │ 失敗（state != 0，鎖被佔用）                   │
  │       ▼                                                │
  │  addWaiter(EXCLUSIVE)                                  │
  │  建立 Node(thread=自己)，CAS 加入佇列尾部              │
     │       │                                             │
  │       ▼                                                │
  │  acquireQueued()                                       │
  │  ┌──────────────────────────────────────────────┐      │
  │  │  for(;;) {                                   │      │
  │  │    若前驅是 head → 再嘗試 tryAcquire()       │      │
  │  │    若成功 → 自己成為新 head，退出迴圈        │      │
  │  │    若失敗 → 前驅設為 SIGNAL                  │      │
  │  │    LockSupport.park()（掛起執行緒）          │      │
  │  │    等待 unpark() 喚醒後繼續迴圈              │      │
  │  │  }                                           │      │
  │  └──────────────────────────────────────────────┘      │
     │       │                                             │
  │  release(1) 時：                                       │
  │  tryRelease() → state 0 → unpark(head.next.thread)     │
  └────────────────────────────────────────────────────────┘
</code></pre>
<p>AQS = <code>state</code>（整數狀態）+ FIFO 等待佇列。</p>
<h2 id="82-獨占與共享對應-821824"><a class="header" href="#82-獨占與共享對應-821824">8.2 獨占與共享（對應 8.2.1~8.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-31"><a class="header" href="#本小節示意圖-31">本小節示意圖</a></h3>
<pre><code class="language-text">  獨占模式 vs 共享模式對比
  ════════════════════════════════════════════════════════

  獨占模式（Exclusive）— ReentrantLock
  ┌──────────────────────────────────────────────────────┐
  │  state: 0 → 1（被獲取） → 0（釋放）                  │
   │                                                     │
  │  時間軸：                                            │
  │  ─────────────────────────────────────────────►      │
  │  T1 獲取 ████████████████████ T1 釋放                │
  │  T2 等待 ░░░░░░░░░░░░░░░░░░░░ T2 獲取 ████████       │
  │  T3 等待 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ T3 獲取    │
   │                                                     │
  │  state 只有 0 和 1，一次只有一個執行緒在臨界區       │
  │  tryAcquire：CAS(state, 0, 1) 成功才獲取             │
  │  tryRelease：state = 0，unpark 下一個等待者          │
  └──────────────────────────────────────────────────────┘

  共享模式（Shared）— Semaphore(permits=2)
  ┌──────────────────────────────────────────────────────┐
  │  state: 2（可用名額） → 1 → 0（滿） → 1 → 2          │
   │                                                     │
  │  時間軸：                                            │
  │  ─────────────────────────────────────────────►      │
  │  T1 獲取(state:2→1)████████████████ T1 釋放(→2)      │
  │  T2 獲取(state:1→0)████████████████ T2 釋放(→1)      │
  │  T3 等待(state=0) ░░░░░░░░░░░░░░░░ T3 獲取(1→0)██    │
  │  T4 等待(state=0) ░░░░░░░░░░░░░░░░ T4 等待...        │
   │                                                     │
  │  tryAcquireShared：state &gt; 0 → CAS(state, s, s-1)    │
  │  tryReleaseShared：CAS(state, s, s+1)                │
   │                                                     │
  │  setHeadAndPropagate：獲取成功後                     │
  │  如果還有名額（state &gt; 0），傳播喚醒後續等待者       │
  │  ┌──────────────────────────────────────────────┐    │
  │  │  T2 獲取成功後：                             │    │
  │  │  state = 1 &gt; 0 → unpark(T3) 傳播             │    │
  │  └──────────────────────────────────────────────┘    │
  └──────────────────────────────────────────────────────┘

  獨占 vs 共享 API 對比：
  ┌────────────────────────┬─────────────────────────────┐
  │ 獨占（Exclusive）      │ 共享（Shared）              │
  ├────────────────────────┼─────────────────────────────┤
  │ tryAcquire(arg)        │ tryAcquireShared(arg)       │
  │ tryRelease(arg)        │ tryReleaseShared(arg)       │
  │ acquire(arg)           │ acquireShared(arg)          │
  │ release(arg)           │ releaseShared(arg)          │
  │ ReentrantLock          │ Semaphore, ReadLock         │
  └────────────────────────┴─────────────────────────────┘
</code></pre>
<ul>
<li>獨占：一次一個（ReentrantLock）</li>
<li>共享：可多個（Semaphore/Read lock）</li>
</ul>
<pre><code class="language-text">state=0 -&gt; acquire 成功 -&gt; state=1
        -&gt; 失敗 -&gt; 入隊等待
</code></pre>
<p>白話例子：一個收銀櫃台（獨占） vs 多個自助結帳機（共享）。</p>
<h2 id="示意圖-7"><a class="header" href="#示意圖-7">示意圖</a></h2>
<pre><code class="language-text">state=1 (held)
wait queue: N1 -&gt; N2 -&gt; N3
release -&gt; unpark N1 -&gt; state 轉移
</code></pre>
<h2 id="跨語言完整範例-7"><a class="header" href="#跨語言完整範例-7">跨語言完整範例</a></h2>
<p>主題：Semaphore 限制最多 N 個並發任務（5 個任務，最多 2 個同時運行）</p>
<h3 id="cposix-sem_t"><a class="header" href="#cposix-sem_t">C（POSIX sem_t）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch08_c ch08.c
#include &lt;semaphore.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define MAX_CONCURRENT 2
#define TASK_COUNT 5

static sem_t sem;

void *task(void *arg) {
    int id = *(int *)arg;
    sem_wait(&amp;sem);                      // acquire（P 操作）
    printf("task %d: running\n", id);
    usleep(50000);                       // 模擬工作 50ms
    printf("task %d: done\n", id);
    sem_post(&amp;sem);                      // release（V 操作）
    return NULL;
}

int main(void) {
    sem_init(&amp;sem, 0, MAX_CONCURRENT);  // 最多 2 個並發
    pthread_t threads[TASK_COUNT];
    int ids[TASK_COUNT];
    for (int i = 0; i &lt; TASK_COUNT; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, task, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASK_COUNT; i++)
        pthread_join(threads[i], NULL);
    sem_destroy(&amp;sem);
    return 0;
}
</code></pre>
<h3 id="cstdcounting_semaphorec20"><a class="header" href="#cstdcounting_semaphorec20">C++（std::counting_semaphore，C++20）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++20 -pthread -o ch08_cpp ch08.cpp
#include &lt;semaphore&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int MAX_CONCURRENT = 2;
constexpr int TASK_COUNT = 5;

static std::counting_semaphore&lt;MAX_CONCURRENT&gt; sem(MAX_CONCURRENT);

void task(int id) {
    sem.acquire();                       // 獲取名額
    std::cout &lt;&lt; "task " &lt;&lt; id &lt;&lt; ": running\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    std::cout &lt;&lt; "task " &lt;&lt; id &lt;&lt; ": done\n";
    sem.release();                       // 釋放名額
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; TASK_COUNT; i++)
        threads.emplace_back(task, i);
    for (auto &amp;t : threads) t.join();
}
</code></pre>
<h3 id="rustsemaphore-via-arcmutex"><a class="header" href="#rustsemaphore-via-arcmutex">Rust（Semaphore via Arc&lt;Mutex<i32>&gt;）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch08.rs &amp;&amp; ./ch08
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use std::time::Duration;

const MAX_CONCURRENT: i32 = 2;
const TASK_COUNT: usize = 5;

fn main() {
    // 用 Mutex&lt;i32&gt; + Condvar 模擬 Semaphore
    let pair = Arc::new((Mutex::new(MAX_CONCURRENT), Condvar::new()));
    let mut handles = Vec::new();

    for id in 0..TASK_COUNT {
        let pair = Arc::clone(&amp;pair);
        handles.push(thread::spawn(move || {
            let (lock, cvar) = &amp;*pair;
            // acquire
            let mut count = lock.lock().unwrap();
            while *count == 0 {
                count = cvar.wait(count).unwrap();
            }
            *count -= 1;
            drop(count);

            println!("task {}: running", id);
            thread::sleep(Duration::from_millis(50));
            println!("task {}: done", id);

            // release
            *lock.lock().unwrap() += 1;
            cvar.notify_one();
        }));
    }
    for h in handles { h.join().unwrap(); }
}</code></pre></pre>
<h3 id="gochannel-作為-semaphore"><a class="header" href="#gochannel-作為-semaphore">Go（channel 作為 Semaphore）</a></h3>
<pre><code class="language-go">// 執行：go run ch08.go
package main

import (
	"fmt"
	"sync"
	"time"
)

const (
	maxConcurrent = 2
	taskCount     = 5
)

func main() {
	sem := make(chan struct{}, maxConcurrent) // 緩衝 channel 作 Semaphore
	var wg sync.WaitGroup

	for i := 0; i &lt; taskCount; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			sem &lt;- struct{}{}              // acquire（放入代表佔用名額）
			fmt.Printf("task %d: running\n", id)
			time.Sleep(50 * time.Millisecond)
			fmt.Printf("task %d: done\n", id)
			&lt;-sem                          // release（取出代表釋放名額）
		}(i)
	}
	wg.Wait()
}
</code></pre>
<h3 id="pythonthreadingsemaphore"><a class="header" href="#pythonthreadingsemaphore">Python（threading.Semaphore）</a></h3>
<pre><code class="language-python"># 執行：python3 ch08.py
import threading
import time

MAX_CONCURRENT = 2
TASK_COUNT = 5

sem = threading.Semaphore(MAX_CONCURRENT)

def task(task_id):
    with sem:                            # acquire / release 自動管理
        print(f"task {task_id}: running")
        time.sleep(0.05)
        print(f"task {task_id}: done")

if __name__ == "__main__":
    ts = [threading.Thread(target=task, args=(i,)) for i in range(TASK_COUNT)]
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<h2 id="完整專案級範例python-7"><a class="header" href="#完整專案級範例python-7">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch08.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch08.py
</code></pre>
<pre><code class="language-python">"""Chapter 08: queue synchronizer flavor via semaphore."""
import threading
import time

sem = threading.Semaphore(2)


def task(i: int):
    with sem:
        print(f"task {i} enter")
        time.sleep(0.05)
        print(f"task {i} leave")


if __name__ == "__main__":
    ts = [threading.Thread(target=task, args=(i,)) for i in range(5)]
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第9章-lock-家族"><a class="header" href="#第9章-lock-家族">第9章 Lock 家族</a></h1>
<h2 id="91-顯式鎖"><a class="header" href="#91-顯式鎖">9.1 顯式鎖</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-32"><a class="header" href="#本小節示意圖-32">本小節示意圖</a></h3>
<pre><code class="language-text">  顯式鎖三種獲取路徑對比
  ════════════════════════════════════════════════════════

  lock()：無限等待，不可中斷
  ┌──────────────────────────────────────────────────────┐
  │  thread.lock()                                       │
  │       │                                              │
  │       ▼                                              │
  │  嘗試獲取鎖 ─── 成功 ──► 進入臨界區                  │
  │       │                                              │
  │       │ 失敗（鎖被佔用）                             │
  │       ▼                                              │
  │  park()（永久等待）                                  │
  │  ⚠ 即使收到 interrupt()，仍然繼續等待                │
  │  只有鎖被釋放後才被 unpark 喚醒                      │
  │  優點：簡單   缺點：可能永久阻塞                     │
  └──────────────────────────────────────────────────────┘

  tryLock(timeout)：超時等待
  ┌──────────────────────────────────────────────────────┐
  │  lock = thread.tryLock(1, TimeUnit.SECONDS)          │
  │       │                                              │
  │       ▼                                              │
  │  嘗試獲取鎖 ─── 成功 ──► 進入臨界區                  │
  │       │                                              │
  │       │ 失敗，記錄 deadline                          │
  │       ▼                                              │
  │  park(timeout)                                       │
  │  ┌──────────────────────────────────────────────┐    │
  │  │  等待期間：                                  │    │
  │  │  ├─ 被喚醒（鎖釋放）→ 重試 tryLock           │    │
  │  │  ├─ 超時      → 返回 false，不進臨界區       │    │
  │  │  └─ interrupt → 拋 InterruptedException      │    │
  │  └──────────────────────────────────────────────┘    │
  │  優點：避免永久阻塞   缺點：需處理返回值             │
  └──────────────────────────────────────────────────────┘

  lockInterruptibly()：可中斷等待
  ┌──────────────────────────────────────────────────────┐
  │  thread.lockInterruptibly()                          │
  │       │                                              │
  │       ▼                                              │
  │  嘗試獲取鎖 ─── 成功 ──► 進入臨界區                  │
  │       │                                              │
  │       │ 失敗，進入佇列等待                           │
  │       ▼                                              │
  │  parkInterruptibly()                                 │
  │  ┌──────────────────────────────────────────────┐    │
  │  │  等待期間：                                  │    │
  │  │  ├─ 被喚醒（鎖釋放）→ 重試獲取               │    │
  │  │  └─ interrupt → 立即拋 InterruptedException  │    │
  │  │     從等待佇列移除，不再等待                 │    │
  │  └──────────────────────────────────────────────┘    │
  │  優點：可取消   缺點：呼叫者必須處理異常             │
  └──────────────────────────────────────────────────────┘
</code></pre>
<p>比 <code>synchronized</code> 更可控：可中斷、可超時、可嘗試。</p>
<h2 id="92-公平與非公平對應-921926"><a class="header" href="#92-公平與非公平對應-921926">9.2 公平與非公平（對應 9.2.1~9.2.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-33"><a class="header" href="#本小節示意圖-33">本小節示意圖</a></h3>
<pre><code class="language-text">  公平鎖 vs 非公平鎖競爭示意
  ════════════════════════════════════════════════════════

  公平鎖（Fair Lock）— 嚴格 FIFO 順序
  ┌──────────────────────────────────────────────────────┐
   │                                                     │
  │  等待佇列：  T2 → T3 → T4（依入隊順序）              │
   │                                                     │
  │  T1 釋放鎖                                           │
   │       │                                             │
  │       ▼ 只喚醒佇列頭部                               │
  │  T2 獲取鎖（FIFO 頭部）                              │
   │                                                     │
  │  此時 T5 剛好到達：                                  │
  │  ┌───────────────────────────────────────────────┐   │
  │  │  T5 發現佇列不空 → 直接入隊尾部（不搶）       │   │
  │  │  等待佇列：T3 → T4 → T5                       │   │
  │  └───────────────────────────────────────────────┘   │
   │                                                     │
  │  ✅ 優點：無飢餓，等待時間可預期                     │
  │  ❌ 缺點：每次都要喚醒掛起執行緒（吞吐較低）         │
  └──────────────────────────────────────────────────────┘

  非公平鎖（Non-Fair Lock）— 先搶再排
  ┌──────────────────────────────────────────────────────┐
   │                                                     │
  │  等待佇列：  T2 → T3 → T4（已在等待）                │
   │                                                     │
  │  T1 釋放鎖                                           │
   │       │                                             │
  │       ▼ 喚醒佇列頭部 T2，同時...                     │
   │                                                     │
  │  此時 T5 剛好到達：                                  │
  │  ┌───────────────────────────────────────────────┐   │
  │  │  T5 先嘗試 CAS(state, 0, 1)                   │   │
  │  │  若 CAS 成功 → T5 直接獲取！（T2 繼續等）     │   │
  │  │  若 CAS 失敗 → T5 才入隊尾部                  │   │
  │  └───────────────────────────────────────────────┘   │
   │                                                     │
  │  ✅ 優點：減少上下文切換（T5 不必 park/unpark）      │
  │  ❌ 缺點：佇列中的執行緒可能被後來者插隊（飢餓）     │
  └──────────────────────────────────────────────────────┘

  效能對比：
  非公平鎖吞吐量通常比公平鎖高 2~10 倍（視競爭程度）
  ReentrantLock 預設是非公平鎖
</code></pre>
<p>公平降低飢餓但吞吐可能較低；非公平吞吐高但可能插隊。</p>
<h2 id="93-悲觀與樂觀對應-931934"><a class="header" href="#93-悲觀與樂觀對應-931934">9.3 悲觀與樂觀（對應 9.3.1~9.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-34"><a class="header" href="#本小節示意圖-34">本小節示意圖</a></h3>
<pre><code class="language-text">  悲觀鎖 vs 樂觀鎖（CAS）流程對比
  ════════════════════════════════════════════════════════

  悲觀鎖（Pessimistic Lock）— 假設衝突必然發生
  ┌─────────────────────────────────────────────────────┐
  │                                                     │
  │  ┌──────────┐                                       │
  │  │  lock()  │← 先鎖定資源（阻塞其他執行緒）         │
  │  └────┬─────┘                                       │
  │       │                                             │
  │       ▼                                             │
  │  ┌──────────┐                                       │
  │  │ read data│← 讀取資料（安全，因為已鎖定）         │
  │  └────┬─────┘                                       │
  │       │                                             │
  │       ▼                                             │
  │  ┌──────────┐                                       │
  │  │write data│← 修改資料                             │
  │  └────┬─────┘                                       │
  │       │                                             │
  │       ▼                                             │
  │  ┌──────────┐                                       │
  │  │ unlock() │← 釋放鎖                               │
  │  └──────────┘                                       │
  │                                                     │
  │  適用：衝突頻率高、臨界區長、寫操作多               │
  └─────────────────────────────────────────────────────┘

  樂觀鎖（Optimistic Lock）— 假設衝突很少，先做再驗
  ┌─────────────────────────────────────────────────────┐
  │                                                     │
  │  ┌─────────────────────┐                            │
  │  │ read data + version │← 讀值 + 記版本號（無鎖）   │
  │  └──────────┬──────────┘                            │
  │             │                                       │
  │             ▼                                       │
  │  ┌─────────────────────┐                            │
  │  │    compute new val  │← 計算新值（無鎖執行）      │
  │  └──────────┬──────────┘                            │
  │             │                                       │
  │             ▼                                       │
  │  ┌───────────────────────────────────────────────┐  │
  │  │  CAS(addr, old_val, new_val)                  │  │
  │  │      ── 且 ──                                 │  │
  │  │  version 比較（version == old_version）       │  │
  │  └────────────────┬──────────────────────────────┘  │
  │                   │                                 │
  │          ┌────────┴────────┐                        │
  │          ▼                 ▼                        │
  │    CAS 成功              CAS 失敗（有衝突）         │
  │    version++             重新 read + retry          │
  │    操作完成              ↑──────────────────────┘   │
  │                                                     │
  │  適用：衝突頻率低、臨界區短、讀操作多               │
  └─────────────────────────────────────────────────────┘
</code></pre>
<p>衝突高用悲觀鎖，衝突低可走 CAS/版本號。</p>
<h2 id="94-可中斷對應-941944"><a class="header" href="#94-可中斷對應-941944">9.4 可中斷（對應 9.4.1~9.4.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-35"><a class="header" href="#本小節示意圖-35">本小節示意圖</a></h3>
<pre><code class="language-text">  可中斷等待 vs 不可中斷等待對比
  ════════════════════════════════════════════════════════

  lock()：不可中斷（忽略 interrupt）
  ┌──────────────────────────────────────────────────────┐
  │                                                      │
  │  Thread T_wait                    Thread T_other     │
  │  ──────────────                   ──────────────     │
  │  lock()（鎖被佔用）                                  │
  │  park()...（掛起等待）                               │
  │                        ──────►   T_wait.interrupt()  │
  │  中斷標記設為 true                                   │
  │  但 lock() 繼續等待！                                │
  │  ⚠ 不拋異常，繼續 park                               │
  │  直到鎖釋放才 unpark                                 │
  │  獲取鎖後才能檢查中斷標記                            │
  │                                                      │
  └──────────────────────────────────────────────────────┘

  lockInterruptibly()：可中斷
  ┌──────────────────────────────────────────────────────┐
  │                                                      │
  │  Thread T_wait                    Thread T_other     │
  │  ──────────────                   ──────────────     │
  │  lockInterruptibly()                                 │
  │  （鎖被佔用）進入等待佇列                            │
  │  parkInterruptibly()...                              │
  │                        ──────►   T_wait.interrupt()  │
  │  ↓ 被喚醒（因 interrupt）                            │
  │  拋出 InterruptedException ←───────────────────────  │
  │  從等待佇列移除                                      │
  │  執行緒可以執行取消/清理邏輯                         │
  │                                                      │
  │  使用場景：可取消的任務、避免死鎖、實作超時          │
  └──────────────────────────────────────────────────────┘
</code></pre>
<p>等待鎖時可取消，避免永久卡死。</p>
<h2 id="95-獨占共享對應-951954"><a class="header" href="#95-獨占共享對應-951954">9.5 獨占/共享（對應 9.5.1~9.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-36"><a class="header" href="#本小節示意圖-36">本小節示意圖</a></h3>
<pre><code class="language-text">  獨占鎖 vs 共享鎖 相容矩陣
  ════════════════════════════════════════════════════════

  ┌──────────────────────┬────────────────┬───────────────┐
  │                      │  持有讀鎖中    │  持有寫鎖中   │
  ├──────────────────────┼────────────────┼───────────────┤
  │  新執行緒申請讀鎖     │  ✅ 允許（共享）│  ❌ 阻塞    │
  ├──────────────────────┼────────────────┼───────────────┤
  │  新執行緒申請寫鎖     │  ❌ 阻塞       │  ❌ 阻塞     │
  └──────────────────────┴────────────────┴───────────────┘

  說明：
  ┌───────────────────────────────────────────────────────┐
  │  讀鎖（共享）：                                       │
  │  • 多個執行緒可同時持有讀鎖                           │
  │  • 適合唯讀操作，不修改資料                           │
  │  • 相容性：讀-讀 允許 / 讀-寫 不允許                  │
    │                                                     │
  │  寫鎖（獨占）：                                       │
  │  • 只有一個執行緒可持有寫鎖                           │
  │  • 持有期間排斥所有讀鎖和寫鎖                         │
  │  • 相容性：寫-讀 不允許 / 寫-寫 不允許                │
    │                                                     │
  │  AQS state 編碼（ReadWriteLock）：                    │
  │  ┌──────────────────────────────────────────────┐     │
  │  │  32-bit state                                │     │
  │  │  高 16 位：讀鎖計數（讀者數量）              │     │
  │  │  低 16 位：寫鎖計數（重入次數）              │     │
  │  └──────────────────────────────────────────────┘     │
  └───────────────────────────────────────────────────────┘
</code></pre>
<p>不同資源特性選不同模型。</p>
<h2 id="96-可重入對應-961962"><a class="header" href="#96-可重入對應-961962">9.6 可重入（對應 9.6.1~9.6.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-37"><a class="header" href="#本小節示意圖-37">本小節示意圖</a></h3>
<pre><code class="language-text">  可重入鎖（Reentrant Lock）計數器機制
  ════════════════════════════════════════════════════════

  場景：T1 持有鎖後呼叫遞迴方法，需要再次獲取同一把鎖

  ┌───────────────────────────────────────────────────────┐
  │  Thread T1                          state 計數器      │
  │  ──────────────────                 ─────────────     │
   │                                                      │
  │  1. lock()                          state = 0         │
  │     CAS(state, 0, 1) 成功           state = 1         │
  │     owner = T1                                        │
  │     ↓                                                 │
  │  2. 呼叫 methodA()                                    │
  │     ↓                                                 │
  │  3. lock()（重入）                  state = 1         │
  │     owner == T1（自己）→ 直接重入   state = 2         │
  │     recursions++                                      │
  │     ↓                                                 │
  │  4. 呼叫 methodB()（繼續重入）                        │
  │     lock()                          state = 2         │
  │     owner == T1 → 直接重入          state = 3         │
  │     ↓                                                 │
  │  5. methodB 完成                                      │
  │     unlock()                        state = 3         │
  │     recursions--                    state = 2         │
  │     ↓                                                 │
  │  6. methodA 完成                                      │
  │     unlock()                        state = 2         │
  │     recursions--                    state = 1         │
  │     ↓                                                 │
  │  7. 最外層完成                                        │
  │     unlock()                        state = 1         │
  │     state = 0，owner = null         state = 0 ✅      │
  │     喚醒等待的執行緒                                  │
   │                                                      │
  │  ⚠ 若不可重入：步驟 3 會死鎖（等自己釋放鎖）          │
  └───────────────────────────────────────────────────────┘
</code></pre>
<p>同執行緒可重複拿同一把鎖，靠計數器解決遞迴鎖死。</p>
<h2 id="97-讀寫鎖對應-971976"><a class="header" href="#97-讀寫鎖對應-971976">9.7 讀寫鎖（對應 9.7.1~9.7.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-38"><a class="header" href="#本小節示意圖-38">本小節示意圖</a></h3>
<pre><code class="language-text">  讀寫鎖時間軸示意
  ════════════════════════════════════════════════════════

  時間軸（從左到右）：
  ─────────────────────────────────────────────────────►

  R1: ████████████████████████                  ← 讀者1
  R2:       ████████████████████████            ← 讀者2（與R1並發）
  R3:             ████████████████████████      ← 讀者3（與R1/R2並發）

  W1:                              ░░░░░░████   ← 寫者1（等待R1/R2/R3結束）
                                   等待  ↑ 進入臨界區

  R4: （W1 等待期間到來）          ░░░░░░░░████ ← 可能被 W1 擋住（防寫者飢餓）
  R5:                                    ░░░████← W1 完成後 R4/R5 可進入

  規則：
  ┌───────────────────────────────────────────────────────┐
  │  ✅ 多個讀者同時進入（無寫者時）                      │
  │  ✅ 寫者獨占（進入時排除所有讀者和其他寫者）          │
  │  ⚠  寫者等待所有現有讀者完成才能進入                  │
  │  ⚠  有等待寫者時，新讀者可能被阻止（防飢餓策略）      │
  └───────────────────────────────────────────────────────┘

  狀態轉換：
  ┌────────────────┬───────────────┬──────────────────────┐
  │  當前狀態      │ 申請讀鎖      │ 申請寫鎖             │
  ├────────────────┼───────────────┼──────────────────────┤
  │  無鎖          │ 立即獲取      │ 立即獲取             │
  │  讀鎖（1+個）  │ 立即獲取      │ 阻塞等待所有讀者退出 │
  │  寫鎖（1個）   │ 阻塞等待      │ 阻塞（除非重入）     │
  └────────────────┴───────────────┴──────────────────────┘
</code></pre>
<p>讀多寫少場景常見，讀可併發、寫需獨占。</p>
<h2 id="98-parkunpark對應-981982"><a class="header" href="#98-parkunpark對應-981982">9.8 park/unpark（對應 9.8.1~9.8.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-39"><a class="header" href="#本小節示意圖-39">本小節示意圖</a></h3>
<pre><code class="language-text">  LockSupport.park / unpark 原語
  ════════════════════════════════════════════════════════

  執行緒狀態轉換：

  Thread T
  ─────────────────────────────────────────────────────
  RUNNABLE
                                                         │
      │ LockSupport.park()
      ▼
  WAITING ← 執行緒掛起，不消耗 CPU
  （操作系統層面：futex/pthread_cond_wait）
                                                         │
      │ LockSupport.unpark(T)  ← 任意執行緒可呼叫
      ▼
  RUNNABLE ← 繼續執行 park() 之後的程式碼

  park / unpark 特殊語義（permit 模型）：
  ┌──────────────────────────────────────────────────────┐
  │  每個執行緒有一個「permit」（0 或 1）                │
   │                                                     │
  │  unpark(T)：                                         │
  │  • 若 T 在等待 → 立即喚醒 T，permit 保持 0           │
  │  • 若 T 未等待 → permit 設為 1（預存）               │
   │                                                     │
  │  park()：                                            │
  │  • 若 permit = 1 → 立即返回（消耗 permit 設為 0）    │
  │  • 若 permit = 0 → 掛起等待                          │
   │                                                     │
  │  結果：unpark 可以在 park 之前呼叫，不會丟失喚醒信號 │
  └──────────────────────────────────────────────────────┘

  與 wait/notify 對比：
  ┌───────────────────┬─────────────────┬────────────────┐
  │ 特性              │ wait/notify     │ park/unpark    │
  ├───────────────────┼─────────────────┼────────────────┤
  │ 需要鎖            │ 是（必須在      │ 否（任何地方   │
  │                   │ synchronized 中）│ 都可呼叫）    │
  │ 喚醒特定執行緒    │ 否（notify 隨機）│ 是（指定 T）  │
  │ 先喚醒後等待      │ 信號丟失        │ permit 保存    │
  │ 虛假喚醒         │ 需要 while 迴圈 │ 也需要檢查      │
  └───────────────────┴─────────────────┴────────────────┘
</code></pre>
<p>底層掛起/喚醒原語。</p>
<h2 id="示意圖-8"><a class="header" href="#示意圖-8">示意圖</a></h2>
<pre><code class="language-text">讀寫鎖:
Readers: R1 R2 R3 可同時進
Writer : W 需要獨占，等所有 Reader 離開
</code></pre>
<h2 id="跨語言完整範例-8"><a class="header" href="#跨語言完整範例-8">跨語言完整範例</a></h2>
<p>主題：讀寫鎖保護 map（3 個 reader 並發讀，1 個 writer 定期寫）</p>
<h3 id="cpthread_rwlock"><a class="header" href="#cpthread_rwlock">C（pthread_rwlock）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch09_c ch09.c
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define READERS 3

static int shared_data = 0;
static pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

void *reader(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i &lt; 3; i++) {
        pthread_rwlock_rdlock(&amp;rwlock);       // 讀鎖（多讀者可並發）
        printf("reader %d: data = %d\n", id, shared_data);
        usleep(20000);
        pthread_rwlock_unlock(&amp;rwlock);
        usleep(10000);
    }
    return NULL;
}

void *writer(void *arg) {
    for (int i = 1; i &lt;= 3; i++) {
        usleep(30000);
        pthread_rwlock_wrlock(&amp;rwlock);       // 寫鎖（獨占）
        shared_data = i * 10;
        printf("writer: data set to %d\n", shared_data);
        pthread_rwlock_unlock(&amp;rwlock);
    }
    return NULL;
}

int main(void) {
    pthread_t readers[READERS], wr;
    int ids[READERS];
    for (int i = 0; i &lt; READERS; i++) {
        ids[i] = i;
        pthread_create(&amp;readers[i], NULL, reader, &amp;ids[i]);
    }
    pthread_create(&amp;wr, NULL, writer, NULL);
    for (int i = 0; i &lt; READERS; i++) pthread_join(readers[i], NULL);
    pthread_join(wr, NULL);
    pthread_rwlock_destroy(&amp;rwlock);
    return 0;
}
</code></pre>
<h3 id="cstdshared_mutex"><a class="header" href="#cstdshared_mutex">C++（std::shared_mutex）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch09_cpp ch09.cpp
#include &lt;shared_mutex&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

static int shared_data = 0;
static std::shared_mutex rw;

void reader(int id) {
    for (int i = 0; i &lt; 3; i++) {
        std::shared_lock lock(rw);            // 共享讀鎖
        std::cout &lt;&lt; "reader " &lt;&lt; id &lt;&lt; ": data = " &lt;&lt; shared_data &lt;&lt; "\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }
}

void writer() {
    for (int i = 1; i &lt;= 3; i++) {
        std::this_thread::sleep_for(std::chrono::milliseconds(30));
        std::unique_lock lock(rw);            // 獨占寫鎖
        shared_data = i * 10;
        std::cout &lt;&lt; "writer: data set to " &lt;&lt; shared_data &lt;&lt; "\n";
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 3; i++)
        threads.emplace_back(reader, i);
    threads.emplace_back(writer);
    for (auto &amp;t : threads) t.join();
}
</code></pre>
<h3 id="rustrwlock"><a class="header" href="#rustrwlock">Rust（RwLock<i32>）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch09.rs &amp;&amp; ./ch09
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

fn main() {
    let data = Arc::new(RwLock::new(0i32));
    let mut handles = Vec::new();

    // 3 個讀者
    for id in 0..3 {
        let data = Arc::clone(&amp;data);
        handles.push(thread::spawn(move || {
            for _ in 0..3 {
                let val = data.read().unwrap();  // 共享讀鎖
                println!("reader {}: data = {}", id, *val);
                drop(val);
                thread::sleep(Duration::from_millis(10));
            }
        }));
    }

    // 1 個寫者
    let data = Arc::clone(&amp;data);
    handles.push(thread::spawn(move || {
        for i in 1..=3 {
            thread::sleep(Duration::from_millis(30));
            *data.write().unwrap() = i * 10;    // 獨占寫鎖
            println!("writer: data set to {}", i * 10);
        }
    }));

    for h in handles { h.join().unwrap(); }
}</code></pre></pre>
<h3 id="gosyncrwmutex"><a class="header" href="#gosyncrwmutex">Go（sync.RWMutex）</a></h3>
<pre><code class="language-go">// 執行：go run ch09.go
package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	sharedData int
	rw         sync.RWMutex
)

func reader(id int, wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 0; i &lt; 3; i++ {
		rw.RLock()                              // 共享讀鎖
		fmt.Printf("reader %d: data = %d\n", id, sharedData)
		time.Sleep(20 * time.Millisecond)
		rw.RUnlock()
		time.Sleep(10 * time.Millisecond)
	}
}

func writer(wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 1; i &lt;= 3; i++ {
		time.Sleep(30 * time.Millisecond)
		rw.Lock()                               // 獨占寫鎖
		sharedData = i * 10
		fmt.Printf("writer: data set to %d\n", sharedData)
		rw.Unlock()
	}
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i &lt; 3; i++ {
		wg.Add(1)
		go reader(i, &amp;wg)
	}
	wg.Add(1)
	go writer(&amp;wg)
	wg.Wait()
}
</code></pre>
<h3 id="pythonthreadingrlock--手動讀寫鎖"><a class="header" href="#pythonthreadingrlock--手動讀寫鎖">Python（threading.RLock + 手動讀寫鎖）</a></h3>
<pre><code class="language-python"># 執行：python3 ch09.py
import threading
import time

shared_data = 0
rw = threading.Lock()          # 寫者用
read_count = 0
read_count_lock = threading.Lock()

def reader(reader_id):
    global read_count
    for _ in range(3):
        with read_count_lock:
            read_count += 1
            if read_count == 1:
                rw.acquire()   # 第一個讀者鎖定寫者
        print(f"reader {reader_id}: data = {shared_data}")
        time.sleep(0.02)
        with read_count_lock:
            read_count -= 1
            if read_count == 0:
                rw.release()   # 最後一個讀者釋放寫者鎖

def writer():
    global shared_data
    for i in range(1, 4):
        time.sleep(0.03)
        with rw:               # 獨占寫鎖
            shared_data = i * 10
            print(f"writer: data set to {shared_data}")

if __name__ == "__main__":
    ts = [threading.Thread(target=reader, args=(i,)) for i in range(3)]
    ts.append(threading.Thread(target=writer))
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<h2 id="完整專案級範例python-8"><a class="header" href="#完整專案級範例python-8">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch09.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch09.py
</code></pre>
<pre><code class="language-python">"""Chapter 09: lock family (Lock/RLock/Condition)."""
import threading

rlock = threading.RLock()
cond = threading.Condition(rlock)
ready = False


def producer():
    global ready
    with rlock:
        ready = True
        cond.notify_all()


def consumer():
    with rlock:
        while not ready:
            cond.wait()
        print("consumer got signal")


if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start(); t1.join(); t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第10章-cas"><a class="header" href="#第10章-cas">第10章 CAS</a></h1>
<h2 id="101-cas-基本模型"><a class="header" href="#101-cas-基本模型">10.1 CAS 基本模型</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-40"><a class="header" href="#本小節示意圖-40">本小節示意圖</a></h3>
<pre><code class="language-text">  CAS（Compare-And-Swap）基本模型
  ════════════════════════════════════════════════════════

  函數語義：
  ┌───────────────────────────────────────────────────────┐
  │  bool CAS(addr, expected, new_val) {                  │
  │      if (*addr == expected) {                         │
  │          *addr = new_val;                             │
  │          return true;    // 交換成功                  │
  │      } else {                                         │
  │          return false;   // 交換失敗（值已被改）      │
  │      }                                                │
  │  }                                                    │
  │  ⚠ 上面的 if-then 是原子執行，不可被打斷              │
  └───────────────────────────────────────────────────────┘

  執行流程示意：
  ┌───────────────────────────────────────────────────────┐
   │                                                      │
  │  記憶體位址 addr                                      │
  │  ┌───────────┐                                        │
  │  │  *addr   │ = 10（當前值）                          │
  │  └───────────┘                                        │
   │       │                                              │
  │       │ CAS(addr, expected=10, new_val=20)            │
  │       ▼                                               │
  │  ┌──────────────────────────────────────────────┐     │
  │  │  原子比較：*addr(10) == expected(10) ?       │     │
  │  │  ├─ 是（成功路徑）                           │     │
  │  │  │   *addr = 20                              │     │
  │  │  │   return true ✅                          │     │
  │  │  │   ┌───────────┐                           │     │
  │  │  │   │  *addr   │ = 20                       │     │
  │  │  │   └───────────┘                           │     │
   │  │  │                                          │     │
  │  │  └─ 否（失敗路徑，*addr 已被其他執行緒改為 15）    │
  │  │      return false ❌                         │     │
  │  │      呼叫者需要重新讀取並重試                │     │
  │  └──────────────────────────────────────────────┘     │
   │                                                      │
  │  硬體層：CMPXCHG 指令（x86）                          │
  │  ┌──────────────────────────────────────────────┐     │
  │  │  LOCK CMPXCHG [mem], reg                     │     │
  │  │  ├─ LOCK 前綴：鎖定快取行/記憶體匯流排       │     │
  │  │  ├─ 比較 EAX 與 [mem]                        │     │
  │  │  ├─ 相等 → [mem] = reg（ZF=1）               │     │
  │  │  └─ 不等 → EAX = [mem]（ZF=0，讓呼叫者重試） │     │
  │  └──────────────────────────────────────────────┘     │
  └───────────────────────────────────────────────────────┘
</code></pre>
<p>Compare-And-Swap：比較並交換。</p>
<h2 id="102-底層支持對應-10211022"><a class="header" href="#102-底層支持對應-10211022">10.2 底層支持（對應 10.2.1~10.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-41"><a class="header" href="#本小節示意圖-41">本小節示意圖</a></h3>
<pre><code class="language-text">  Intel x86 LOCK CMPXCHG vs ARM LL/SC
  ════════════════════════════════════════════════════════

  Intel x86 — LOCK CMPXCHG（單條原子指令）
  ┌───────────────────────────────────────────────────────┐
    │                                                     │
  │  CPU 執行 LOCK CMPXCHG                                │
    │       │                                             │
  │       ▼                                               │
  │  ┌─────────────────────────────────────────────────┐  │
  │  │  Step 1：LOCK 前綴                              │  │
  │  │  鎖定對應快取行（Cache Line Lock）              │  │
  │  │  或在多 CPU 系統鎖定記憶體匯流排                │  │
  │  └─────────────────────┬───────────────────────────┘  │
    │                         │                           │
  │                         ▼                             │
  │  ┌─────────────────────────────────────────────────┐  │
  │  │  Step 2：原子比較                               │  │
  │  │  compare EAX（expected）with [mem]              │  │
  │  │  ├─ 相等 → exchange [mem] = new_reg             │  │
  │  │  │         ZF = 1（表示成功）                   │  │
  │  │  └─ 不等 → EAX = [mem]（取回現值）              │  │
  │  │            ZF = 0（表示失敗）                   │  │
  │  └─────────────────────┬───────────────────────────┘  │
    │                         │                           │
  │                         ▼                             │
  │  ┌─────────────────────────────────────────────────┐  │
  │  │  Step 3：UNLOCK                                 │  │
  │  │  釋放快取行/匯流排鎖                            │  │
  │  └─────────────────────────────────────────────────┘  │
  │  整個過程不可中斷，其他 CPU 必須等待               │  │
  └───────────────────────────────────────────────────────┘

  ARM — LL/SC（Load-Link / Store-Conditional，可能重試）
  ┌───────────────────────────────────────────────────────┐
    │                                                     │
  │  retry:                                               │
    │       │                                             │
  │       ▼                                               │
  │  ┌─────────────────────────────────────────────────┐  │
  │  │  LDREX r0, [addr]  ← Load-Link                  │  │
  │  │  記錄 addr 的「獨占監視器」標記                 │  │
  │  │  r0 = *addr（讀取當前值）                       │  │
  │  └─────────────────────┬───────────────────────────┘  │
    │                         │                           │
  │                         ▼ 計算新值                    │
  │                    r1 = r0 + 1                        │
    │                         │                           │
  │                         ▼                             │
  │  ┌─────────────────────────────────────────────────┐  │
  │  │  STREX result, r1, [addr]  ← Store-Conditional   │ │
  │  │  若獨占監視器標記仍有效（無其他寫入）           │  │
  │  │  ├─ 寫入成功：*addr = r1，result = 0            │  │
  │  │  └─ 寫入失敗：result = 1（有其他 CPU 寫入）     │  │
  │  └─────────────────────┬───────────────────────────┘  │
    │                         │                           │
  │             ┌───────────┴─────────────┐               │
  │             ▼                       ▼                 │
  │        result == 0             result == 1            │
  │        成功，完成              失敗，回到 retry       │
  │                                ────────────────►      │
  │  LL/SC 通過重試避免總線鎖，對多核效能更友好        │  │
  └───────────────────────────────────────────────────────┘
</code></pre>
<p>依賴 CPU 原子指令；Java <code>Unsafe/VarHandle</code>、C++ <code>atomic</code>、Rust <code>Atomic*</code>、Go <code>sync/atomic</code>。</p>
<h2 id="103-cas-實作計數器對應-10311033"><a class="header" href="#103-cas-實作計數器對應-10311033">10.3 CAS 實作計數器（對應 10.3.1~10.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-42"><a class="header" href="#本小節示意圖-42">本小節示意圖</a></h3>
<pre><code class="language-text">  CAS 自旋計數器流程
  ════════════════════════════════════════════════════════

  單次遞增流程（樂觀自旋）：
  ┌─────────────────────────────────────────────────────┐
  │                                                     │
  │  ┌──────────────────────────────────────────────┐   │
  │  │  Step 1：load old = *counter                 │   │
  │  │  讀取當前值（此時 counter = 5）              │   │
  │  └────────────────────────┬─────────────────────┘   │
  │                            │ old = 5                │
  │                            ▼                        │
  │  ┌──────────────────────────────────────────────┐   │
  │  │  Step 2：new = old + 1 = 6                   │   │
  │  │  計算新值（純粹計算，無競爭）                │   │
  │  └────────────────────────┬─────────────────────┘   │
  │                            │                        │
  │                            ▼                        │
  │  ┌──────────────────────────────────────────────┐   │
  │  │  Step 3：CAS(*counter, old=5, new=6)         │   │
  │  │  ├─ *counter 仍為 5 → 交換成功，counter=6    │   │
  │  │  │   ✅ done                                 │   │
  │  │  └─ *counter 已改（別的執行緒改為 6）        │   │
  │  │      ❌ 失敗 → 回到 Step 1 重試              │   │
  │  └──────────────────────────────────────────────┘   │
  │                                                     │
  │  高競爭下的問題：                                   │
  │  ┌──────────────────────────────────────────────┐   │
  │  │  T1 讀 old=5 ─────────────────────────────►  │   │
  │  │  T2 讀 old=5 → CAS 成功(5→6)                 │   │
  │  │  T3 讀 old=5 → CAS 失敗，重試                │   │
  │  │  T4 讀 old=5 → CAS 失敗，重試                │   │
  │  │  T1      → CAS 失敗，重試                    │   │
  │  │  ...N 個執行緒競爭，每輪只有 1 個成功        │   │
  │  │  自旋 CPU 浪費 ∝ 執行緒數量                  │   │
  │  └──────────────────────────────────────────────┘   │
  │  解法：LongAdder（分段計數，減少競爭）              │
  └─────────────────────────────────────────────────────┘
</code></pre>
<pre><code class="language-text">do {
  old = load(x)
  new = old + 1
} while (!CAS(x, old, new))
</code></pre>
<h2 id="104-aba-問題對應-10411043"><a class="header" href="#104-aba-問題對應-10411043">10.4 ABA 問題（對應 10.4.1~10.4.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-43"><a class="header" href="#本小節示意圖-43">本小節示意圖</a></h3>
<pre><code class="language-text">  ABA 問題時間軸與帶版本號解法
  ════════════════════════════════════════════════════════

  問題：CAS 只比較值，不感知中間的變化

  Thread T1                   Thread T2
  ─────────────────           ─────────────────────────
  read: *addr = A             （暫停）
  （準備 CAS A → B）
                                                           │
        │                     read: *addr = A
        │                     CAS(*addr, A, B) → 成功
        │                     *addr = B
                                                           │
        │                     read: *addr = B
        │                     CAS(*addr, B, A) → 成功
        │                     *addr = A  ← 改回 A
                                                           │
        ▼
  CAS(*addr, A, B)            （T1 繼續執行）
  ← *addr 仍為 A，CAS 成功！
  但 A 其實已經歷了 A→B→A 的變化
  ⚠ T1 誤以為「什麼都沒發生」，中間的 B 被忽略

  ABA 問題的後果：
  ┌────────────────────────────────────────────────────────┐
  │  無鎖棧場景（stack pop + push）：                      │
  │  T1 準備 pop A（讀到 head=A, next=B）                  │
  │  T2 pop A, pop B, push A（棧頂還是A，但B丟失）         │
  │  T1 CAS(head, A, B) 成功，但 B 已經不在棧裡！          │
  │  → 棧結構損壞                                          │
  └────────────────────────────────────────────────────────┘

  解法：帶版本號的 CAS（Double-CAS / Stamped Reference）

  時間軸（帶版本號）：
  ┌────────────────────────────────────────────────────────┐
    │                                                      │
  │  初始：(value=A, version=v1)                           │
    │                                                      │
  │  Thread T1                   Thread T2                 │
  │  ─────────────────           ────────────────────      │
  │  read: (A, v1)               read: (A, v1)             │
  │  （準備 CAS）                                          │
  │                              CAS((A,v1),(B,v2))→成功   │
  │                              state: (B, v2)            │
    │                                                      │
  │                              CAS((B,v2),(A,v3))→成功   │
  │                              state: (A, v3)  ← 版本不同│
    │                                                      │
  │  CAS((A,v1),(B,v2))                                    │
  │  當前: (A, v3) ≠ expected: (A, v1)                     │
  │  → CAS 失敗！❌                                        │
  │  → T1 重新讀取，感知到 ABA 變化                        │
    │                                                      │
  │  版本號每次修改單調遞增，即使值迴圈也能區分            │
  │  (A,v1) → (B,v2) → (A,v3)   v3 ≠ v1                    │
  └────────────────────────────────────────────────────────┘

  各語言帶版本號的實現：
  ┌────────────────────────────────────────────────────────┐
  │  Java:  AtomicStampedReference&lt;V&gt;                      │
  │         compareAndSet(expect, update, stamp, newStamp) │
    │                                                      │
  │  C++:   std::atomic&lt;std::pair&lt;T,int&gt;&gt;（128-bit CAS）   │
  │         或自訂 tagged pointer                          │
    │                                                      │
  │  Rust:  AtomicU64（將 value 和 version 打包）          │
    │                                                      │
  │  Go:    sync/atomic.CompareAndSwapUint64（打包）       │
  └────────────────────────────────────────────────────────┘
</code></pre>
<p>A-&gt;B-&gt;A 會讓 CAS 誤判「沒變過」。</p>
<p>解法：加版本號（stamp/tagged pointer）。</p>
<h2 id="示意圖-9"><a class="header" href="#示意圖-9">示意圖</a></h2>
<pre><code class="language-text">loop:
  old = load
  new = f(old)
  if CAS(old,new) 成功 -&gt; done
  else -&gt; retry
</code></pre>
<h2 id="跨語言完整範例-9"><a class="header" href="#跨語言完整範例-9">跨語言完整範例</a></h2>
<p>主題：CAS 計數器（多執行緒自旋遞增，對比 mutex 版本）</p>
<h3 id="cc11-atomiccas-自旋"><a class="header" href="#cc11-atomiccas-自旋">C（C11 atomic，CAS 自旋）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch10_c ch10.c
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define INCREMENTS 10000

static atomic_int counter = ATOMIC_VAR_INIT(0);

void *cas_worker(void *arg) {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        int old, new_val;
        do {
            old = atomic_load_explicit(&amp;counter, memory_order_relaxed);
            new_val = old + 1;
        } while (!atomic_compare_exchange_weak_explicit(
                     &amp;counter, &amp;old, new_val,
                     memory_order_relaxed, memory_order_relaxed));
    }
    return NULL;
}

int main(void) {
    pthread_t threads[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;threads[i], NULL, cas_worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("counter = %d (expected %d)\n",
           atomic_load(&amp;counter), THREADS * INCREMENTS);
    return 0;
}
</code></pre>
<h3 id="cstdatomic-compare_exchange_weak-1"><a class="header" href="#cstdatomic-compare_exchange_weak-1">C++（std::atomic compare_exchange_weak）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch10_cpp ch10.cpp
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int THREADS = 4;
constexpr int INCREMENTS = 10000;

static std::atomic&lt;int&gt; counter{0};

void cas_worker() {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        int old = counter.load(std::memory_order_relaxed);
        while (!counter.compare_exchange_weak(
                   old, old + 1,
                   std::memory_order_relaxed)) {
            // old 自動被 compare_exchange_weak 更新為當前值
        }
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; THREADS; i++)
        threads.emplace_back(cas_worker);
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * INCREMENTS &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rustatomici32-fetch_add-vs-compare_exchange"><a class="header" href="#rustatomici32-fetch_add-vs-compare_exchange">Rust（AtomicI32 fetch_add vs compare_exchange）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch10.rs &amp;&amp; ./ch10
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;

const THREADS: usize = 4;
const INCREMENTS: usize = 10_000;

fn main() {
    let counter = Arc::new(AtomicI32::new(0));
    let mut handles = Vec::new();

    for _ in 0..THREADS {
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..INCREMENTS {
                // CAS 自旋遞增
                let mut old = counter.load(Ordering::Relaxed);
                loop {
                    match counter.compare_exchange_weak(
                        old, old + 1,
                        Ordering::Relaxed, Ordering::Relaxed)
                    {
                        Ok(_) =&gt; break,
                        Err(cur) =&gt; old = cur, // 更新 old 後重試
                    }
                }
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})",
             counter.load(Ordering::SeqCst),
             THREADS * INCREMENTS);
}</code></pre></pre>
<h3 id="gosyncatomic-compareandswap-1"><a class="header" href="#gosyncatomic-compareandswap-1">Go（sync/atomic CompareAndSwap）</a></h3>
<pre><code class="language-go">// 執行：go run ch10.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

const (
	threads    = 4
	increments = 10000
)

func main() {
	var counter int64
	var wg sync.WaitGroup

	for i := 0; i &lt; threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j &lt; increments; j++ {
				// CAS 自旋遞增
				for {
					old := atomic.LoadInt64(&amp;counter)
					if atomic.CompareAndSwapInt64(&amp;counter, old, old+1) {
						break // CAS 成功退出
					}
					// 失敗則重試（old 在下次 Load 時更新）
				}
			}
		}()
	}
	wg.Wait()
	fmt.Printf("counter = %d (expected %d)\n", counter, threads*increments)
}
</code></pre>
<h3 id="python模擬-caslock-保護原子性"><a class="header" href="#python模擬-caslock-保護原子性">Python（模擬 CAS，Lock 保護原子性）</a></h3>
<pre><code class="language-python"># 執行：python3 ch10.py
import threading

THREADS = 4
INCREMENTS = 10000

class AtomicInt:
    def __init__(self, initial=0):
        self._val = initial
        self._lock = threading.Lock()

    def load(self):
        return self._val

    def compare_and_swap(self, expected, new_val):
        with self._lock:
            if self._val == expected:
                self._val = new_val
                return True
            return False

counter = AtomicInt(0)

def cas_worker():
    for _ in range(INCREMENTS):
        while True:
            old = counter.load()
            if counter.compare_and_swap(old, old + 1):
                break  # CAS 成功

if __name__ == "__main__":
    ts = [threading.Thread(target=cas_worker) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"counter = {counter.load()} (expected {THREADS * INCREMENTS})")
</code></pre>
<h2 id="完整專案級範例python-9"><a class="header" href="#完整專案級範例python-9">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch10.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch10.py
</code></pre>
<pre><code class="language-python">"""Chapter 10: CAS increment loop."""
import threading


class AtomicInt:
    def __init__(self):
        self.v = 0
        self.m = threading.Lock()

    def cas(self, expect: int, new: int) -&gt; bool:
        with self.m:
            if self.v == expect:
                self.v = new
                return True
            return False


if __name__ == "__main__":
    a = AtomicInt()
    for _ in range(5):
        while True:
            old = a.v
            if a.cas(old, old + 1):
                break
    print("value=", a.v)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第11章-死鎖"><a class="header" href="#第11章-死鎖">第11章 死鎖</a></h1>
<h2 id="111-死鎖定義"><a class="header" href="#111-死鎖定義">11.1 死鎖定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-44"><a class="header" href="#本小節示意圖-44">本小節示意圖</a></h3>
<pre><code class="language-text">  資源分配圖：循環等待形成死鎖

  ┌─────────────┐         ┌───────────────────┐
  │  Thread T1  │         │  Thread T2        │
  └──────┬──────┘         └──────┬────────────┘
         │ 持有(hold)              │ 持有(hold)
         ▼                        ▼
  ┌─────────────┐         ┌───────────────────┐
  │  Resource A │         │  Resource B       │
  └─────────────┘         └───────────────────┘
         ▲                        ▲
         │ 等待(wait)              │ 等待(wait)
  ┌──────┴──────┐         ┌──────┴────────────┐
  │  Thread T2  │         │  Thread T1        │
  └─────────────┘         └───────────────────┘

  T1 → 持有 A，等待 B
  T2 → 持有 B，等待 A
  ↔ 形成有向循環 ⇒ 永遠無法推進 ⇒ 死鎖
</code></pre>
<p>兩個或以上執行緒互相等待對方釋放資源，永遠走不下去。</p>
<p>死鎖（Deadlock）是指一組執行緒陷入永久等待的狀態：每個執行緒都在等待另一個執行緒持有的資源，而那個執行緒也在等待更多資源，形成一個閉合的等待環。作業系統無法自動解除這種僵局，程式將永久掛起。</p>
<h2 id="112-演化過程對應-11211123"><a class="header" href="#112-演化過程對應-11211123">11.2 演化過程（對應 11.2.1~11.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-45"><a class="header" href="#本小節示意圖-45">本小節示意圖</a></h3>
<pre><code class="language-text">  時間軸：安全狀態 → 不安全狀態 → 死鎖

  時間點   Thread T1              Thread T2            系統狀態
  ──────   ──────────────────     ──────────────────   ────────────
   t0      (就緒)                 (就緒)               ✅ 安全

   t1      lock(A) ✓              lock(B) ✓            ⚠️  危險
           [持有 A]               [持有 B]

   t2      try lock(B) → 阻塞     try lock(A) → 阻塞   🔴 不安全
           [持有 A，等 B]         [持有 B，等 A]
           ╔══════════╗           ╔══════════╗
           ║  WAITING ║           ║  WAITING ║
           ╚══════════╝           ╚══════════╝

   t3      ████████████           ████████████         💀 死鎖
           (永遠等待)              (永遠等待)
           CPU 佔用 0%，但無法繼續

  ──────────────────────────────────────────────────────
  關鍵轉折：t1→t2 時，兩個執行緒都已「持有資源並等待」
  一旦形成循環，無外部干預則永不解除
</code></pre>
<p>不安全排程 + 資源競用，逐步滑向死鎖。</p>
<p>死鎖的形成通常是逐步的：系統從安全狀態出發，隨著執行緒依序取得部分資源，進入不安全狀態，最終當所有執行緒都在等待對方持有的資源時，死鎖完成。</p>
<h2 id="113-四必要條件"><a class="header" href="#113-四必要條件">11.3 四必要條件</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-46"><a class="header" href="#本小節示意圖-46">本小節示意圖</a></h3>
<pre><code class="language-text">  死鎖四必要條件（缺一不可）

  ┌─────────────────────────────────────────────────────────────────┐
  │  條件一：互斥（Mutual Exclusion）                               │
   │                                                                │
  │  ┌────────┐    只能一人使用    ┌─────────────┐                  │
  │  │ T1佔用 │ ────────────────► │   廁所     │ ◄── T2 被擋在外    │
  │  └────────┘                   │（互斥資源）  │                  │
  │                               └──────────────┘                  │
  │  白話：廁所同時只能一個人用，資源不能共享                       │
  └─────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────┐
  │  條件二：持有且等待（Hold and Wait）                            │
   │                                                                │
  │  ┌────────────────────────────┐                                 │
  │  │ T1 手握 Lock A             │                                 │
  │  │      └→ 還要申請 Lock B  │  ← 不先放 A，直接等 B             │
  │  └────────────────────────────┘                                 │
  │  白話：手拿叉子，還要等筷子，但不肯放叉子                       │
  └─────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────┐
  │  條件三：不可剝奪（No Preemption）                              │
   │                                                                │
  │  OS/排程器 ─✗→ 強制搶走 T1 的 Lock A                            │
   │                                                                │
  │  只有 T1 自己 release() 才能釋放，外力無法強取                  │
  │  白話：手裡的漢堡不能被別人硬搶走                               │
  └─────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────┐
  │  條件四：循環等待（Circular Wait）                              │
   │                                                                │
  │       T1 ──等待──► Lock B (被 T2 持有)                          │
  │        ▲                     │                                  │
  │        │                    ▼                                   │
  │       Lock A ◄──等待── T2                                       │
  │  (被 T1 持有)                                                   │
   │                                                                │
  │  白話：A 等 B，B 等 A，繞成一個圈                               │
  └─────────────────────────────────────────────────────────────────┘

  ⚡ 破壞任一條件即可預防死鎖！
</code></pre>
<p>死鎖的四個必要條件：</p>
<ul>
<li><strong>互斥</strong>：資源在某時刻只能被一個執行緒佔用</li>
<li><strong>持有且等待</strong>：執行緒持有至少一個資源，同時等待獲取其他執行緒持有的資源</li>
<li><strong>不可剝奪</strong>：已分配的資源不能被強制奪走，只能由持有者主動釋放</li>
<li><strong>循環等待</strong>：存在一個執行緒等待鏈，形成閉合迴路</li>
</ul>
<p>四個條件缺一不可，破壞其中任何一個即可預防死鎖。</p>
<h2 id="114-預防與處理"><a class="header" href="#114-預防與處理">11.4 預防與處理</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-47"><a class="header" href="#本小節示意圖-47">本小節示意圖</a></h3>
<pre><code class="language-text">  三種策略對比

  ┌──────────────────┬───────────────────────────┬───────────────────────┐
  │     策略         │        做法               │   代價 / 適用場景     │
  ├──────────────────┼───────────────────────────┼───────────────────────┤
  │ 固定加鎖順序     │ 所有執行緒按相同順序加鎖  │ 代價：需全局規劃順序  │
  │                  │                           │ 適用：鎖數量固定、    │
  │ T1: lock(A→B)    │  ┌──┐    ┌──┐            │       關係清晰         │
  │ T2: lock(A→B)    │  │A │───►│B   │            │                      │
  │ (不再交叉)       │  └──┘    └──┘            │ ✅ 最可靠              │
  ├──────────────────┼───────────────────────────┼───────────────────────┤
  │ tryLock + 逾時   │ 嘗試加鎖，超過期限就放棄  │ 代價：需處理失敗重試  │
  │                  │                           │ 適用：鎖等待時間可    │
  │ if tryLock(B,    │  ┌───────────────┐        │       預期、業務允    │
  │   100ms):        │  │嘗試 100ms 後  │        │       許重試          │
  │   use B          │  │放棄，釋放 A    │        │                      │
  │ else:            │  └───────────────┘        │ ⚠️  可能活鎖          │
  │   release A       │                           │                      │
  ├──────────────────┼───────────────────────────┼───────────────────────┤
  │ 縮小持鎖範圍     │ 盡量縮短持鎖時間          │ 代價：需重新設計邏輯  │
  │                  │                           │ 適用：業務邏輯可拆    │
  │ 只在讀寫共享     │  ┌──────────────────────┐ │       分、IO操作多    │
  │ 資料時持鎖，     │  │lock │ op │ unlock     │ │                      │
  │ IO 等慢操作移出  │  └──────────────────────┘ │ ✅ 提升整體吞吐量     │
  │ 臨界區外         │   短   短   短             │                      │
  └──────────────────┴───────────────────────────┴───────────────────────┘

  死鎖偵測與恢復（補救手段）：
  ┌──────────────────────────────────────────────────────────────────────┐
  │  偵測：定期掃描資源分配圖，尋找循環                                  │
  │  恢復：選擇犧牲者（victim）→ 強制回滾或終止，釋放其資源              │
  │  適用：資料庫系統（如 MySQL 死鎖偵測）                               │
  └──────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>三種主流預防策略：</p>
<ul>
<li><strong>固定鎖順序</strong>：所有執行緒按相同的全局排序依序加鎖，確保不存在循環等待</li>
<li><strong><code>tryLock</code> + timeout</strong>：嘗試加鎖，超時後放棄並釋放已持有的鎖，待稍後重試</li>
<li><strong>減少持鎖時間</strong>：將不需要持鎖的操作（如 I/O、計算）移到臨界區外，降低衝突視窗</li>
</ul>
<pre><code class="language-text">T1: lock(A) -&gt; wait(B)
T2: lock(B) -&gt; wait(A)
=&gt; deadlock

修正後（固定順序）:
T1: lock(A) -&gt; lock(B) -&gt; unlock(B) -&gt; unlock(A)
T2: lock(A) -&gt; lock(B) -&gt; unlock(B) -&gt; unlock(A)
=&gt; 不再有循環，死鎖不可能發生
</code></pre>
<h2 id="跨語言完整範例-10"><a class="header" href="#跨語言完整範例-10">跨語言完整範例</a></h2>
<p>固定加鎖順序避免死鎖：兩把鎖按 id 排序後加鎖，無論執行緒以何種順序呼叫，都不會形成循環等待。</p>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch11_c ch11.c &amp;&amp; ./ch11_c */
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

typedef struct { int id; pthread_mutex_t mu; } Lock;

/* 按 id 排序後加鎖，破壞循環等待條件 */
void lock_ordered(Lock *a, Lock *b) {
    if (a-&gt;id &lt; b-&gt;id) {
        pthread_mutex_lock(&amp;a-&gt;mu);
        pthread_mutex_lock(&amp;b-&gt;mu);
    } else {
        pthread_mutex_lock(&amp;b-&gt;mu);
        pthread_mutex_lock(&amp;a-&gt;mu);
    }
}

void unlock_ordered(Lock *a, Lock *b) {
    pthread_mutex_unlock(&amp;a-&gt;mu);
    pthread_mutex_unlock(&amp;b-&gt;mu);
}

Lock res_a = {0, PTHREAD_MUTEX_INITIALIZER};
Lock res_b = {1, PTHREAD_MUTEX_INITIALIZER};
int shared = 0;

void *thread_fn(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i &lt; 5; i++) {
        lock_ordered(&amp;res_a, &amp;res_b);
        shared++;
        printf("Thread %d: shared = %d\n", id, shared);
        unlock_ordered(&amp;res_a, &amp;res_b);
        usleep(1000);
    }
    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    int id1 = 1, id2 = 2;
    pthread_create(&amp;t1, NULL, thread_fn, &amp;id1);
    pthread_create(&amp;t2, NULL, thread_fn, &amp;id2);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Final shared = %d\n", shared);
    return 0;
}
</code></pre>
<h3 id="c-1"><a class="header" href="#c-1">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch11_cpp ch11.cpp &amp;&amp; ./ch11_cpp
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

struct OrderedLock {
    int id;
    std::mutex mu;
};

// std::scoped_lock 內部用 std::lock() 實作死鎖安全加鎖
void transfer(OrderedLock &amp;from, OrderedLock &amp;to, int &amp;counter) {
    std::scoped_lock lk(from.mu, to.mu);   // 同時安全地鎖兩把
    counter++;
    std::cout &lt;&lt; "transferred, counter=" &lt;&lt; counter &lt;&lt; "\n";
}

int main() {
    OrderedLock account_a{0, {}};
    OrderedLock account_b{1, {}};
    int counter = 0;
    std::mutex cout_mu;

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++) {
        // 奇偶執行緒使用不同方向，但 scoped_lock 保證不死鎖
        if (i % 2 == 0)
            threads.emplace_back(transfer, std::ref(account_a),
                                 std::ref(account_b), std::ref(counter));
        else
            threads.emplace_back(transfer, std::ref(account_b),
                                 std::ref(account_a), std::ref(counter));
    }
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "Final counter=" &lt;&lt; counter &lt;&lt; "\n";
    return 0;
}
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch11.rs &amp;&amp; ./ch11
use std::sync::{Arc, Mutex};
use std::thread;

struct Resource {
    id: u32,
    data: Mutex&lt;i32&gt;,
}

// 按 id 排序後取鎖，確保全局順序
fn locked_update(a: &amp;Resource, b: &amp;Resource) {
    let (first, second) = if a.id &lt; b.id { (a, b) } else { (b, a) };
    let mut g1 = first.data.lock().unwrap();
    let mut g2 = second.data.lock().unwrap();
    *g1 += 1;
    *g2 += 1;
    println!("updated: res[{}]={}, res[{}]={}", first.id, *g1, second.id, *g2);
}

fn main() {
    let res_a = Arc::new(Resource { id: 0, data: Mutex::new(0) });
    let res_b = Arc::new(Resource { id: 1, data: Mutex::new(0) });

    let handles: Vec&lt;_&gt; = (0..4).map(|i| {
        let (a, b) = (Arc::clone(&amp;res_a), Arc::clone(&amp;res_b));
        thread::spawn(move || {
            // 一半執行緒傳 (a,b)，另一半傳 (b,a)，但排序保證安全
            if i % 2 == 0 { locked_update(&amp;a, &amp;b); }
            else           { locked_update(&amp;b, &amp;a); }
        })
    }).collect();

    for h in handles { h.join().unwrap(); }
    println!("Done, no deadlock.");
}</code></pre></pre>
<h3 id="go"><a class="header" href="#go">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch11.go
package main

import (
	"fmt"
	"sync"
)

type Resource struct {
	id int
	mu sync.Mutex
}

// 按 id 排序加鎖，破壞循環等待
func lockedTransfer(a, b *Resource, counter *int, mu *sync.Mutex) {
	first, second := a, b
	if a.id &gt; b.id {
		first, second = b, a
	}
	first.mu.Lock()
	second.mu.Lock()
	defer first.mu.Unlock()
	defer second.mu.Unlock()

	mu.Lock()
	*counter++
	fmt.Printf("transfer done, counter=%d\n", *counter)
	mu.Unlock()
}

func main() {
	resA := &amp;Resource{id: 0}
	resB := &amp;Resource{id: 1}
	counter := 0
	var printMu sync.Mutex
	var wg sync.WaitGroup

	for i := 0; i &lt; 8; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			if i%2 == 0 {
				lockedTransfer(resA, resB, &amp;counter, &amp;printMu)
			} else {
				lockedTransfer(resB, resA, &amp;counter, &amp;printMu)
			}
		}(i)
	}
	wg.Wait()
	fmt.Printf("Final counter=%d, no deadlock!\n", counter)
}
</code></pre>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch11.py
import threading
import time


class OrderedLock:
    def __init__(self, lock_id: int):
        self.id = lock_id
        self.mu = threading.Lock()


def locked_transfer(a: OrderedLock, b: OrderedLock, counter: list):
    """按 id 排序後加鎖，確保不形成循環等待。"""
    first, second = (a, b) if a.id &lt; b.id else (b, a)
    with first.mu:
        time.sleep(0.001)          # 模擬工作，增加競爭機會
        with second.mu:
            counter[0] += 1
            print(f"Thread {threading.current_thread().name}: "
                  f"counter={counter[0]}")


if __name__ == "__main__":
    res_a = OrderedLock(0)
    res_b = OrderedLock(1)
    counter = [0]

    threads = []
    for i in range(8):
        # 奇偶執行緒傳入順序相反，但 ordered lock 保證安全
        if i % 2 == 0:
            t = threading.Thread(target=locked_transfer,
                                 args=(res_a, res_b, counter), name=f"T{i}")
        else:
            t = threading.Thread(target=locked_transfer,
                                 args=(res_b, res_a, counter), name=f"T{i}")
        threads.append(t)
        t.start()

    for t in threads:
        t.join()
    print(f"Final counter={counter[0]}, no deadlock!")
</code></pre>
<h2 id="完整專案級範例python-10"><a class="header" href="#完整專案級範例python-10">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch11.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch11.py
</code></pre>
<pre><code class="language-python">"""Chapter 11: deadlock avoidance via timeout and ordered locking."""
import threading
import time

A = threading.Lock()
B = threading.Lock()


def worker1():
    """持有 A 後嘗試取 B，超時則主動放棄避免死鎖。"""
    with A:
        time.sleep(0.05)
        if B.acquire(timeout=0.1):
            print("w1 got B")
            B.release()
        else:
            print("w1 timeout on B — 避免死鎖，稍後重試")


def worker2():
    """持有 B 後嘗試取 A，超時則主動放棄避免死鎖。"""
    with B:
        time.sleep(0.05)
        if A.acquire(timeout=0.1):
            print("w2 got A")
            A.release()
        else:
            print("w2 timeout on A — 避免死鎖，稍後重試")


if __name__ == "__main__":
    t1 = threading.Thread(target=worker1)
    t2 = threading.Thread(target=worker2)
    t1.start(); t2.start(); t1.join(); t2.join()
    print("程式正常結束，無死鎖")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第12章-鎖優化"><a class="header" href="#第12章-鎖優化">第12章 鎖優化</a></h1>
<h2 id="121123-縮小鎖粒度"><a class="header" href="#121123-縮小鎖粒度">12.1~12.3 縮小鎖粒度</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-48"><a class="header" href="#本小節示意圖-48">本小節示意圖</a></h3>
<pre><code class="language-text">  縮小鎖粒度：粗鎖 vs 細鎖

  ╔══════════════════════════════════════════════════════════════╗
  ║  BEFORE：一把大鎖保護整個 Map                                ║
  ╚══════════════════════════════════════════════════════════════╝

  Thread A (讀 k1)  ───────────────────────────────────────────┐
  Thread B (寫 k7)  ──┤──► 爭搶同一把 GlobalLock ──► Map
  Thread C (讀 k3)  ───────────────────────────────────────────┤
  Thread D (寫 k9)  ───────────────────────────────────────────┘
                                                               │
         ▼
  衝突概率 = P(任意兩個操作重疊) ≈ 很高
  同一時刻只有 1 個執行緒能進入 Map

  ╔══════════════════════════════════════════════════════════════╗
  ║  AFTER：每個 bucket 一把鎖                                   ║
  ╚══════════════════════════════════════════════════════════════╝

  Thread A (讀 k1) ──► Lock[bucket_0] ──► bucket[0]: {k1,k2,...}
  Thread B (寫 k7) ──► Lock[bucket_1] ──► bucket[1]: {k7,k8,...}
  Thread C (讀 k3) ──► Lock[bucket_0] ──► bucket[0]: {k3,...}
  Thread D (寫 k9) ──► Lock[bucket_2] ──► bucket[2]: {k9,...}
                                                               │
         ▼
  A 和 C 競爭 bucket_0（才衝突）
  B 和 D 各用不同 bucket（完全並行）

  衝突概率 = P(兩操作落在同一 bucket) ≈ 1/N（N 為 bucket 數）
  並發度從 1 提升到接近 bucket 數量
</code></pre>
<p>粗鎖改細鎖，減少不必要互斥。</p>
<p>鎖粒度（Lock Granularity）指的是一把鎖所保護的資料範圍。粗粒度鎖（如保護整個 Map）易於實作但並發度低；細粒度鎖（如每個 bucket 一把鎖）提升並發，但設計複雜度也上升。核心原則：<strong>只鎖真正需要保護的最小資料範圍</strong>。</p>
<h2 id="124126-分段與分離"><a class="header" href="#124126-分段與分離">12.4~12.6 分段與分離</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-49"><a class="header" href="#本小節示意圖-49">本小節示意圖</a></h3>
<pre><code class="language-text">  分段鎖（Sharded Lock）：key hash % 16 → shard[i]

  ┌───────────────────────────────────────────────────────────────┐
  │                    Sharded Map（16 個分片）                   │
  ├───────────────────────────────────────────────────────────────┤
    │                                                             │
  │  key ──► hash(key) % 16 ──► 選擇分片                          │
    │                                                             │
  │   Shard[0]  ┌──────────┐  Lock[0]  ← Thread A                 │
  │             │ {k0,...}   │                                    │
  │   Shard[1]  ├──────────┤  Lock[1]  ← Thread B (同時並行)      │
  │             │ {k1,...}   │                                    │
  │   Shard[2]  ├──────────┤  Lock[2]  ← Thread C (同時並行)      │
  │             │ {k2,...}   │                                    │
  │      ⋮      │    ⋮     │    ⋮                                 │
  │   Shard[15] ├──────────┤  Lock[15] ← Thread P (同時並行)      │
  │             │ {k15,..}   │                                    │
  │             └────────────┘                                    │
    │                                                             │
  │  並發度：最多 16 個執行緒同時操作不同分片（互不阻塞）         │
  │  衝突只發生在：兩個 key 的 hash%16 值相同時                   │
    │                                                             │
  │  對比單一全域鎖：並發度提升 ≈ 16 倍（理論上限）               │
  └───────────────────────────────────────────────────────────────┘

  白話例子：
  超商單一結帳櫃台 → 16 個自助結帳機
  顧客分散到不同機台，排隊時間大幅縮短
</code></pre>
<p>把一把全域鎖拆成多段（striped/sharded lock）。</p>
<p>分段鎖是縮小鎖粒度的極致應用：將資料結構按某種規則（通常是 key 的 hash 值）切分為多個 shard，每個 shard 有獨立的鎖。操作時只鎖對應的 shard，其他 shard 的操作完全不受影響，理論並發度為 shard 數量。</p>
<h2 id="127129-其他策略"><a class="header" href="#127129-其他策略">12.7~12.9 其他策略</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-50"><a class="header" href="#本小節示意圖-50">本小節示意圖</a></h3>
<pre><code class="language-text">  鎖策略決策樹

  開始評估並發策略
                                                                      │
         ▼
  讀操作遠多於寫操作？
  ├── 是 ──► 使用讀寫鎖（RWLock / shared_mutex）
  │          多個讀者同時進入，只有寫者互斥
  │          適用：配置讀取、快取查詢
                                                                      │
  └── 否 ──► 操作是否無衝突（CAS 能完成）？
             ├── 是 ──► 樂觀鎖 / 原子 CAS（lock-free）
             │          適用：計數器、狀態機、無競爭更新
                                                                      │
             └── 否 ──► 高吞吐量場景？
                        ├── 是 ──► 分段鎖（Sharded Lock）
                        │          適用：並發 Map、並發計數器
                                                                      │
                        └── 否 ──► 需要公平性（FIFO 順序）？
                                   ├── 是 ──► 公平鎖（Fair Lock）
                                   │          避免飢餓，代價：吞吐略低
                                                                      │
                                   └── 否 ──► 執行緒本地資料夠用？
                                              ├── 是 ──► ThreadLocal
                                              │          完全消除鎖競爭
                                              └── 否 ──► 普通互斥鎖
                                                         + 縮小持鎖範圍
</code></pre>
<p>其他常見鎖優化策略：</p>
<ul>
<li><strong>降低持鎖時間</strong>：將 I/O、複雜計算移到臨界區外，只在真正需要保護的最小程式碼段持鎖</li>
<li><strong>熱點隔離</strong>：高頻訪問的共享計數器可用 per-CPU 計數器或 LongAdder 模式，最後再匯總</li>
<li><strong>讀寫分離</strong>：讀多寫少場景用 <code>RWMutex</code>，允許多個讀者並行，只有寫者獨佔</li>
<li><strong>優先無鎖結構</strong>：原子操作（CAS）、無鎖佇列在低競爭場景下比鎖更快</li>
</ul>
<p>白話例子：超商單一結帳櫃台改 16 個櫃台，隊伍自然變短。</p>
<h2 id="跨語言完整範例-11"><a class="header" href="#跨語言完整範例-11">跨語言完整範例</a></h2>
<p>分段鎖 Map：SHARDS=8，按 key hash 選鎖，多執行緒並發寫入，對比全域鎖展示吞吐量差異。</p>
<h3 id="c-2"><a class="header" href="#c-2">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch12_c ch12.c &amp;&amp; ./ch12_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define SHARDS   8
#define ITERS    100000
#define THREADS  4

typedef struct { long count; pthread_mutex_t mu; } Shard;

Shard shards[SHARDS];

static unsigned int hash_key(int key) {
    return (unsigned int)key * 2654435761u;
}

void shard_inc(int key) {
    int idx = hash_key(key) % SHARDS;
    pthread_mutex_lock(&amp;shards[idx].mu);
    shards[idx].count++;
    pthread_mutex_unlock(&amp;shards[idx].mu);
}

void *worker(void *arg) {
    int base = *(int *)arg;
    for (int i = 0; i &lt; ITERS; i++)
        shard_inc(base * ITERS + i);
    return NULL;
}

int main(void) {
    for (int i = 0; i &lt; SHARDS; i++)
        pthread_mutex_init(&amp;shards[i].mu, NULL);

    pthread_t ts[THREADS];
    int ids[THREADS];
    struct timespec t0, t1;
    clock_gettime(CLOCK_MONOTONIC, &amp;t0);

    for (int i = 0; i &lt; THREADS; i++) {
        ids[i] = i;
        pthread_create(&amp;ts[i], NULL, worker, &amp;ids[i]);
    }
    for (int i = 0; i &lt; THREADS; i++) pthread_join(ts[i], NULL);

    clock_gettime(CLOCK_MONOTONIC, &amp;t1);
    long total = 0;
    for (int i = 0; i &lt; SHARDS; i++) total += shards[i].count;

    long ms = (t1.tv_sec - t0.tv_sec) * 1000 +
              (t1.tv_nsec - t0.tv_nsec) / 1000000;
    printf("total=%ld (expected %d), elapsed=%ldms\n",
           total, THREADS * ITERS, ms);
    return 0;
}
</code></pre>
<h3 id="c-3"><a class="header" href="#c-3">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch12_cpp ch12.cpp &amp;&amp; ./ch12_cpp
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

constexpr int SHARDS  = 8;
constexpr int ITERS   = 100000;
constexpr int THREADS = 4;

struct Shard {
    long count = 0;
    std::mutex mu;
};

Shard shards[SHARDS];

void shard_inc(int key) {
    int idx = std::hash&lt;int&gt;{}(key) % SHARDS;
    std::lock_guard lk(shards[idx].mu);
    shards[idx].count++;
}

int main() {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) {
        ts.emplace_back([i] {
            for (int j = 0; j &lt; ITERS; j++)
                shard_inc(i * ITERS + j);
        });
    }
    for (auto &amp;t : ts) t.join();

    long total = 0;
    for (auto &amp;s : shards) total += s.count;
    std::cout &lt;&lt; "total=" &lt;&lt; total
              &lt;&lt; " (expected=" &lt;&lt; THREADS * ITERS &lt;&lt; ")\n";
    return 0;
}
</code></pre>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch12.rs -o ch12 &amp;&amp; ./ch12
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

const SHARDS: usize = 8;
const ITERS: usize = 25000;
const THREADS: usize = 4;

fn hash_shard(key: i32) -&gt; usize {
    let mut h = DefaultHasher::new();
    key.hash(&amp;mut h);
    (h.finish() as usize) % SHARDS
}

fn main() {
    // Arc&lt;Vec&lt;Mutex&lt;i64&gt;&gt;&gt;：共享的分段計數器
    let shards: Arc&lt;Vec&lt;Mutex&lt;i64&gt;&gt;&gt; =
        Arc::new((0..SHARDS).map(|_| Mutex::new(0)).collect());

    let handles: Vec&lt;_&gt; = (0..THREADS).map(|i| {
        let shards = Arc::clone(&amp;shards);
        thread::spawn(move || {
            for j in 0..ITERS {
                let key = (i * ITERS + j) as i32;
                let idx = hash_shard(key);
                *shards[idx].lock().unwrap() += 1;
            }
        })
    }).collect();

    for h in handles { h.join().unwrap(); }

    let total: i64 = shards.iter().map(|s| *s.lock().unwrap()).sum();
    println!("total={} (expected={})", total, THREADS * ITERS);
}</code></pre></pre>
<h3 id="go-1"><a class="header" href="#go-1">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch12.go
package main

import (
	"fmt"
	"hash/fnv"
	"sync"
	"sync/atomic"
)

const shards = 8
const iters = 25000
const workers = 4

type Shard struct {
	mu    sync.Mutex
	count int64
}

var shardMap [shards]Shard

func hashShard(key int) int {
	h := fnv.New32a()
	b := [4]byte{byte(key), byte(key &gt;&gt; 8), byte(key &gt;&gt; 16), byte(key &gt;&gt; 24)}
	h.Write(b[:])
	return int(h.Sum32()) % shards
}

func shardInc(key int) {
	idx := hashShard(key)
	shardMap[idx].mu.Lock()
	shardMap[idx].count++
	shardMap[idx].mu.Unlock()
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i &lt; workers; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			for j := 0; j &lt; iters; j++ {
				shardInc(i*iters + j)
			}
		}(i)
	}
	wg.Wait()

	var total int64
	for i := range shardMap {
		total += atomic.LoadInt64(&amp;shardMap[i].count)
	}
	fmt.Printf("total=%d (expected=%d)\n", total, workers*iters)
}
</code></pre>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch12.py
import threading
import hashlib

SHARDS  = 8
ITERS   = 10000
WORKERS = 4


class ShardedCounter:
    def __init__(self, n_shards: int):
        self.counts = [0] * n_shards
        self.locks  = [threading.Lock() for _ in range(n_shards)]
        self.n      = n_shards

    def increment(self, key: int):
        idx = key % self.n          # 簡單取模作為 hash 函數
        with self.locks[idx]:
            self.counts[idx] += 1

    def total(self) -&gt; int:
        return sum(self.counts)


counter = ShardedCounter(SHARDS)


def worker(worker_id: int):
    for j in range(ITERS):
        counter.increment(worker_id * ITERS + j)


if __name__ == "__main__":
    threads = [threading.Thread(target=worker, args=(i,)) for i in range(WORKERS)]
    for t in threads: t.start()
    for t in threads: t.join()
    print(f"total={counter.total()} (expected={WORKERS * ITERS})")
    print(f"分片分佈: {counter.counts}")
</code></pre>
<h2 id="完整專案級範例python-11"><a class="header" href="#完整專案級範例python-11">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch12.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch12.py
</code></pre>
<pre><code class="language-python">"""Chapter 12: lock sharding — 分段鎖實作與對比。"""
import threading
import time

SHARDS = 8
locks = [threading.Lock() for _ in range(SHARDS)]
data = [0] * SHARDS


def update(key: int):
    """按 key % SHARDS 選擇對應分片的鎖，只鎖該分片。"""
    idx = key % SHARDS
    with locks[idx]:
        data[idx] += 1


if __name__ == "__main__":
    start = time.time()
    ts = [threading.Thread(target=update, args=(i,)) for i in range(10_000)]
    for t in ts: t.start()
    for t in ts: t.join()
    elapsed = time.time() - start
    print(f"sum={sum(data)}, elapsed={elapsed:.3f}s")
    print(f"分片分佈: {data}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第13章-線程池"><a class="header" href="#第13章-線程池">第13章 線程池</a></h1>
<h2 id="131-狀態與生命週期對應-13111312"><a class="header" href="#131-狀態與生命週期對應-13111312">13.1 狀態與生命週期（對應 13.1.1~13.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-51"><a class="header" href="#本小節示意圖-51">本小節示意圖</a></h3>
<pre><code class="language-text">  線程池狀態機

                    ┌───────────────────────────────────────┐
               ──►  │   RUNNING   │  ◄── 正常接受任務並處理
                    └──────┬────────────────────────────────┘
                                                            │
               ┌───────────┴────────────────────────────────┐
               │ shutdown()               │ shutdownNow()
               ▼                          ▼
        ┌─────────────┐            ┌────────────────────────┐
        │  SHUTDOWN   │            │    STOP                │
        │（不收新任務) │            │（立即中斷）           │
        │  繼續排隊中  │            │  返回未執行           │
        │  的舊任務    │            │  任務列表             │
        └──────┬──────┘            └──────┬─────────────────┘
               │ 佇列清空                  │ workers 停止
               │ workers 歸零                               │
               └───────────┬────────────────────────────────┘
                            ▼
                    ┌───────────────────────────────────────┐
                    │   TIDYING   │  ← 所有任務已完成
                    │ worker=0    │    呼叫 terminated() hook
                    └──────┬────────────────────────────────┘
                            │ terminated() 完成
                            ▼
                    ┌───────────────────────────────────────┐
                    │ TERMINATED  │  ← 最終狀態，資源全部釋放
                    └───────────────────────────────────────┘

  注意：狀態只能單向推進，不可逆轉
</code></pre>
<p>管理執行緒建立、運作、關閉，避免每次任務都開新執行緒。</p>
<p>線程池維護一組預先建立的執行緒，持續從任務佇列取出任務執行。這樣避免了頻繁建立/銷毀執行緒的開銷（每次建立約耗費數十微秒），並提供統一的資源上限，防止系統因過多執行緒而耗盡記憶體。</p>
<h2 id="132-建立方式對應-13211324"><a class="header" href="#132-建立方式對應-13211324">13.2 建立方式（對應 13.2.1~13.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-52"><a class="header" href="#本小節示意圖-52">本小節示意圖</a></h3>
<pre><code class="language-text">  四種線程池類型對比

  ┌─────────────┬──────────────────┬─────────────────┬───────────────────┐
  │    類型      │    執行緒數量    │    任務佇列     │    適用場景      │
  ├─────────────┼──────────────────┼─────────────────┼───────────────────┤
  │ Fixed        │ 固定 N 個        │ 無界佇列        │ CPU 密集計算     │
  │ Thread Pool  │ 永遠存在         │ LinkedBlocking  │ 任務量穩定       │
  │              │                  │ Queue           │ Web 後端服務     │
  │              │  [T][T][T][T]    │  [Q─Q─Q─Q─…]    │                  │
  ├─────────────┼──────────────────┼─────────────────┼───────────────────┤
  │ Cached       │ 彈性 0~MAX       │ SynchronousQueue│ 短暫突發流量     │
  │ Thread Pool  │ 閒置 60s 後回收  │ (容量=0，直接   │ 任務量不可預測   │
  │              │                  │  handoff)       │ 但單個任務快     │
  │              │  [T]?[T]?[T]?    │  [直接交付]     │                  │
  ├─────────────┼──────────────────┼─────────────────┼───────────────────┤
  │ Scheduled    │ 固定核心 N 個    │ DelayedQueue    │ 定時任務排程     │
  │ Thread Pool  │ 支援延遲/週期    │ (按時間排序)    │ Cron 類工作      │
  │              │                  │                 │ 心跳、清理任務   │
  │              │  [T][T] (定時)   │  [t=10s][t=30s] │                  │
  ├─────────────┼──────────────────┼─────────────────┼───────────────────┤
  │ ForkJoin     │ N ≈ CPU 核數     │ 每執行緒私有    │ 分治演算法       │
  │ Pool         │ 工作竊取（steal) │ Deque           │ 遞迴並行處理     │
  │              │                  │ (可從別人尾部   │ Stream parallel  │
  │              │  [T]←steal─[T]   │  偷任務)        │                  │
  └─────────────┴──────────────────┴─────────────────┴───────────────────┘
</code></pre>
<p>固定池、快取池、排程池、分治池各有適用場景。選錯類型可能導致記憶體耗盡（Cached pool 在爆發流量下無限建執行緒）或效能低下（Fixed pool 在 I/O 密集時執行緒閒置）。</p>
<h2 id="133-提交流程與拒絕策略對應-13311332"><a class="header" href="#133-提交流程與拒絕策略對應-13311332">13.3 提交流程與拒絕策略（對應 13.3.1~13.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-53"><a class="header" href="#本小節示意圖-53">本小節示意圖</a></h3>
<pre><code class="language-text">  submit(task) 完整決策流程

  submit(task)
                                                                             │
       ▼
  ┌──────────────────────────────────────────────────────────────────────────┐
  │ 核心執行緒數 &lt; corePoolSize?                                             │
  └──────────────┬───────────────────────────────────────────────────────────┘
       是 │               │ 否
          ▼               ▼
  ┌───────────────┐  ┌───────────────────────────────────────────────────────┐
  │ 新建 Worker   │  │ 任務佇列 queue 未滿？                                 │
  │ 執行此任務    │  └────────────┬──────────────────────────────────────────┘
  └───────────────┘       是 │            │ 否
                             ▼            ▼
                    ┌─────────────┐  ┌───────────────────────────────────────┐
                    │ 入佇列等待  │  │ 執行緒數 &lt; maxPoolSize?               │
                    └─────────────┘  └────────────┬──────────────────────────┘
                                          是 │             │ 否
                                             ▼             ▼
                                    ┌──────────────┐  ┌──────────────────────┐
                                    │ 新建非核心   │  │      拒絕策略        │
                                    │ Worker 執行  │  ├──────────────────────┤
                                    └──────────────┘  │ AbortPolicy:拋例外   │
                                                       │ CallerRunsPolicy:   │
                                                       │   呼叫者自己跑      │
                                                       │ DiscardPolicy:靜默  │
                                                       │ DiscardOldest:丟最  │
                                                       │   舊的任務          │
                                                       └─────────────────────┘
</code></pre>
<p>核心是「任務佇列 + 工作執行緒 + 飽和策略」。</p>
<p>任務提交時，線程池按優先級嘗試：先用核心執行緒，再入佇列，再擴展到最大執行緒數，最後觸發拒絕策略。理解這個流程對調參（corePoolSize、maxPoolSize、queueCapacity）至關重要。</p>
<h2 id="134-關閉對應-13411342"><a class="header" href="#134-關閉對應-13411342">13.4 關閉（對應 13.4.1~13.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-54"><a class="header" href="#本小節示意圖-54">本小節示意圖</a></h3>
<pre><code class="language-text">  兩種關閉方式對比

  ┌───────────────────────────────────────────────────────────────┐
  │  shutdown()：優雅關閉                                         │
   │                                                              │
  │  1. 標記狀態為 SHUTDOWN                                       │
  │  2. 不再接受新的 submit() 呼叫                                │
  │  3. 已在佇列中的任務 ✅ 繼續執行完畢                          │
  │  4. 所有 worker 完成後進入 TERMINATED                         │
   │                                                              │
  │  Timeline:                                                    │
  │  ──┬──────────────────────────────────────┬──► 結束           │
  │    │ shutdown()                             │                 │
  │    │←── 不接受新任務 ──►│←── 排空佇列 ──►   │                 │
  │    │  [Q任務1][Q任務2]  →  執行完畢         │                 │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  shutdownNow()：立即關閉                                      │
   │                                                              │
  │  1. 標記狀態為 STOP                                           │
  │  2. 對所有 worker 送出 interrupt() 訊號                       │
  │  3. 佇列中 ❌ 未執行的任務以 List 形式返回給呼叫者            │
  │  4. 正在執行的任務若響應中斷則提前結束                        │
   │                                                              │
  │  Timeline:                                                    │
  │  ──┬────────────────────┬──► 結束                             │
  │    │ shutdownNow()        │                                   │
  │    │←── 中斷 workers ──►│  返回未執行任務列表                 │
  │    │  [Q任務1][Q任務2]  ← 取出並返回，不執行                  │
  └───────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>優雅關閉（<code>shutdown</code>）：不收新任務，處理完已接收的任務後關閉。</li>
<li>立即關閉（<code>shutdownNow</code>）：嘗試中斷執行中的任務，返回未執行的任務列表。</li>
</ul>
<p>實務上應搭配 <code>awaitTermination(timeout)</code> 等待關閉完成，避免主程式提前退出導致任務被截斷。</p>
<h2 id="135-參數調優對應-13511352"><a class="header" href="#135-參數調優對應-13511352">13.5 參數調優（對應 13.5.1~13.5.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-55"><a class="header" href="#本小節示意圖-55">本小節示意圖</a></h3>
<pre><code class="language-text">  線程數調優公式

  ┌──────────────────────────────────────────────────────────────┐
  │  符號定義                                                    │
  │  N  = CPU 核心數（Runtime.getRuntime().availableProcessors） │
  │  WT = 平均等待時間（Wait Time，例如 I/O 等待 900ms）         │
  │  ST = 平均服務時間（Service Time，例如 CPU 計算 100ms）      │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │  CPU 密集型任務（幾乎不等待 I/O）                            │
   │                                                             │
  │  最佳執行緒數 = N + 1                                        │
   │                                                             │
  │  +1 的原因：當某執行緒因缺頁中斷等短暫暫停時，               │
  │            額外一個執行緒可立即接手 CPU，避免浪費            │
   │                                                             │
  │  範例：N=8 核 → 推薦 9 個執行緒                              │
  └──────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────┐
  │  I/O 密集型任務（大量等待磁碟/網路）                         │
   │                                                             │
  │  最佳執行緒數 = N × (1 + WT/ST)                              │
   │                                                             │
  │  直覺：執行緒等待 I/O 時 CPU 是閒置的，                      │
  │        可讓更多執行緒同時在 CPU 上運行                       │
   │                                                             │
  │  範例：N=8，WT=900ms，ST=100ms                               │
  │        = 8 × (1 + 900/100)                                   │
  │        = 8 × 10 = 80 個執行緒                                │
   │                                                             │
  │  ⚠️  上限受記憶體限制，每個 Java 執行緒預設 256KB~1MB 棧     │
  └──────────────────────────────────────────────────────────────┘

  實務建議：先用公式估算，再透過壓測（吞吐量、延遲）調整
</code></pre>
<p>CPU 密集：執行緒數接近核心數（N+1）。
I/O 密集：可高於核心數，按 N×(1+WT/ST) 估算。</p>
<pre><code class="language-text">Producer -&gt; Queue -&gt; Worker x N -&gt; Result
</code></pre>
<h2 id="跨語言完整範例-12"><a class="header" href="#跨語言完整範例-12">跨語言完整範例</a></h2>
<p>執行緒池處理批次任務：固定 4 個 worker，處理 20 個任務，顯示並發執行效果。</p>
<h3 id="c-4"><a class="header" href="#c-4">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch13_c ch13.c &amp;&amp; ./ch13_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

#define WORKERS 4
#define TASKS   20
#define QUEUE_CAP 64

typedef void (*task_fn)(int);

typedef struct {
    task_fn  fn;
    int      arg;
} Task;

typedef struct {
    Task      queue[QUEUE_CAP];
    int       head, tail, size;
    pthread_mutex_t mu;
    pthread_cond_t  not_empty;
    int       done;           /* 1 = shutdown */
} Pool;

Pool pool = {.head=0, .tail=0, .size=0, .done=0,
             .mu=PTHREAD_MUTEX_INITIALIZER,
             .not_empty=PTHREAD_COND_INITIALIZER};

void pool_submit(task_fn fn, int arg) {
    pthread_mutex_lock(&amp;pool.mu);
    pool.queue[pool.tail] = (Task){fn, arg};
    pool.tail = (pool.tail + 1) % QUEUE_CAP;
    pool.size++;
    pthread_cond_signal(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);
}

void *worker_loop(void *arg) {
    int id = *(int *)arg;
    for (;;) {
        pthread_mutex_lock(&amp;pool.mu);
        while (pool.size == 0 &amp;&amp; !pool.done)
            pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
        if (pool.size == 0 &amp;&amp; pool.done) {
            pthread_mutex_unlock(&amp;pool.mu);
            break;
        }
        Task t = pool.queue[pool.head];
        pool.head = (pool.head + 1) % QUEUE_CAP;
        pool.size--;
        pthread_mutex_unlock(&amp;pool.mu);
        t.fn(t.arg);
    }
    printf("Worker %d exiting\n", id);
    return NULL;
}

void process_task(int task_id) {
    printf("Task %2d running on thread %lu\n",
           task_id, pthread_self() % 10000);
    usleep(50000);  /* 模擬 50ms 工作 */
}

int main(void) {
    pthread_t threads[WORKERS];
    int ids[WORKERS];
    for (int i = 0; i &lt; WORKERS; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker_loop, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASKS; i++)
        pool_submit(process_task, i);

    /* 等佇列排空後關閉 */
    pthread_mutex_lock(&amp;pool.mu);
    while (pool.size &gt; 0)
        pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
    pool.done = 1;
    pthread_cond_broadcast(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);

    for (int i = 0; i &lt; WORKERS; i++) pthread_join(threads[i], NULL);
    printf("All %d tasks completed.\n", TASKS);
    return 0;
}
</code></pre>
<h3 id="c-5"><a class="header" href="#c-5">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch13_cpp ch13.cpp &amp;&amp; ./ch13_cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;queue&gt;
#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;vector&gt;

class ThreadPool {
    std::vector&lt;std::thread&gt; workers;
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::mutex mu;
    std::condition_variable cv;
    bool stop = false;
public:
    explicit ThreadPool(int n) {
        for (int i = 0; i &lt; n; i++)
            workers.emplace_back([this] {
                for (;;) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock lk(mu);
                        cv.wait(lk, [this]{ return stop || !tasks.empty(); });
                        if (stop &amp;&amp; tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
    }
    void submit(std::function&lt;void()&gt; f) {
        { std::lock_guard lk(mu); tasks.push(std::move(f)); }
        cv.notify_one();
    }
    ~ThreadPool() {
        { std::lock_guard lk(mu); stop = true; }
        cv.notify_all();
        for (auto &amp;t : workers) t.join();
    }
};

int main() {
    ThreadPool pool(4);
    std::mutex print_mu;
    for (int i = 0; i &lt; 20; i++) {
        pool.submit([i, &amp;print_mu] {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            std::lock_guard lk(print_mu);
            std::cout &lt;&lt; "Task " &lt;&lt; i &lt;&lt; " done by thread "
                      &lt;&lt; std::this_thread::get_id() &lt;&lt; "\n";
        });
    }
    /* ThreadPool 解構時自動等待所有任務完成 */
    std::cout &lt;&lt; "All tasks submitted, waiting...\n";
    return 0;
}
</code></pre>
<h3 id="rust-2"><a class="header" href="#rust-2">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch13.rs -o ch13 &amp;&amp; ./ch13
use std::sync::{Arc, Mutex};
use std::sync::mpsc;
use std::thread;

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

struct ThreadPool {
    _workers: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
    sender: mpsc::Sender&lt;Option&lt;Job&gt;&gt;,
}

impl ThreadPool {
    fn new(size: usize) -&gt; Self {
        let (sender, receiver) = mpsc::channel::&lt;Option&lt;Job&gt;&gt;();
        let receiver = Arc::new(Mutex::new(receiver));
        let workers = (0..size).map(|_| {
            let rx = Arc::clone(&amp;receiver);
            thread::spawn(move || loop {
                let msg = rx.lock().unwrap().recv().unwrap();
                match msg {
                    Some(job) =&gt; job(),
                    None =&gt; break,
                }
            })
        }).collect();
        ThreadPool { _workers: workers, sender }
    }

    fn submit&lt;F: FnOnce() + Send + 'static&gt;(&amp;self, f: F) {
        self.sender.send(Some(Box::new(f))).unwrap();
    }

    fn shutdown(self) {
        for _ in &amp;self._workers {
            self.sender.send(None).unwrap();
        }
        for w in self._workers { w.join().unwrap(); }
    }
}

fn main() {
    let pool = ThreadPool::new(4);
    let counter = Arc::new(Mutex::new(0));

    for i in 0..20 {
        let c = Arc::clone(&amp;counter);
        pool.submit(move || {
            thread::sleep(std::time::Duration::from_millis(50));
            let mut n = c.lock().unwrap();
            *n += 1;
            println!("Task {:2} done, completed so far: {}", i, *n);
        });
    }
    pool.shutdown();
    println!("All tasks completed.");
}</code></pre></pre>
<h3 id="go-2"><a class="header" href="#go-2">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch13.go
package main

import (
	"fmt"
	"sync"
	"time"
)

func newWorkerPool(workers int, queueSize int) chan&lt;- func() {
	jobs := make(chan func(), queueSize)
	for i := 0; i &lt; workers; i++ {
		workerID := i
		go func() {
			for job := range jobs {
				fmt.Printf("  Worker %d picked up job\n", workerID)
				job()
			}
		}()
	}
	return jobs
}

func main() {
	const numWorkers = 4
	const numTasks   = 20

	pool := newWorkerPool(numWorkers, 64)
	var wg sync.WaitGroup

	for i := 0; i &lt; numTasks; i++ {
		taskID := i
		wg.Add(1)
		pool &lt;- func() {
			defer wg.Done()
			time.Sleep(50 * time.Millisecond)
			fmt.Printf("Task %2d completed\n", taskID)
		}
	}

	wg.Wait()
	close(pool)
	fmt.Printf("All %d tasks completed.\n", numTasks)
}
</code></pre>
<h3 id="python-2"><a class="header" href="#python-2">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch13.py
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed


def process_task(task_id: int) -&gt; str:
    """模擬一個需要 50ms 的工作任務。"""
    time.sleep(0.05)
    thread_name = threading.current_thread().name
    return f"Task {task_id:2d} done by {thread_name}"


if __name__ == "__main__":
    num_tasks   = 20
    num_workers = 4

    start = time.time()
    with ThreadPoolExecutor(max_workers=num_workers,
                            thread_name_prefix="Worker") as pool:
        futures = [pool.submit(process_task, i) for i in range(num_tasks)]
        for future in as_completed(futures):
            print(future.result())

    elapsed = time.time() - start
    # 序列需 20×0.05=1.0s，4 個 worker 並行約 0.25s
    print(f"\n完成 {num_tasks} 個任務，耗時 {elapsed:.2f}s "
          f"（序列估計 {num_tasks * 0.05:.2f}s）")
</code></pre>
<h2 id="完整專案級範例python-12"><a class="header" href="#完整專案級範例python-12">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch13.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch13.py
</code></pre>
<pre><code class="language-python">"""Chapter 13: thread pool — 使用 ThreadPoolExecutor 並行處理批次任務。"""
import time
from concurrent.futures import ThreadPoolExecutor


def square(x: int) -&gt; int:
    """模擬 CPU 計算：計算平方值。"""
    time.sleep(0.01)  # 模擬少量計算時間
    return x * x


if __name__ == "__main__":
    inputs = list(range(16))
    start = time.time()

    with ThreadPoolExecutor(max_workers=4) as ex:
        results = list(ex.map(square, inputs))

    elapsed = time.time() - start
    print(f"結果: {results}")
    print(f"耗時: {elapsed:.2f}s（4 個 worker 並行）")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第14章-threadlocal"><a class="header" href="#第14章-threadlocal">第14章 ThreadLocal</a></h1>
<h2 id="141143-存取機制對應-1411434"><a class="header" href="#141143-存取機制對應-1411434">14.1~14.3 存取機制（對應 14.1~14.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-56"><a class="header" href="#本小節示意圖-56">本小節示意圖</a></h3>
<pre><code class="language-text">  ThreadLocal 存取機制：Thread 內部結構圖

  ┌─────────────────────────────────────────────────────────────────┐
  │  Thread A                                                       │
  │  ┌──────────────────────────────────────────────────────────┐   │
  │  │  threadLocals: ThreadLocalMap                            │   │
  │  │  ┌────────────────────────────────────────────────────┐  │   │
  │  │  │  Entry[]（開放定址雜湊表）                         │  │   │
  │  │  │  ┌────────────────────┬─────────────────────────┐  │  │   │
  │  │  │  │ key = WeakRef(TL1) │ value = "user_42"       │  │  │   │
  │  │  │  ├────────────────────┼─────────────────────────┤  │  │   │
  │  │  │  │ key = WeakRef(TL2) │ value = conn_obj_A      │  │  │   │
  │  │  │  ├────────────────────┼─────────────────────────┤  │  │   │
  │  │  │  │      (空槽)          │                       │  │  │   │
  │  │  │  └────────────────────┴─────────────────────────┘  │  │   │
  │  │  └────────────────────────────────────────────────────┘  │   │
  │  └──────────────────────────────────────────────────────────┘   │
  └─────────────────────────────────────────────────────────────────┘

  查找路徑：
  threadLocal.get()
                                                                    │
       ▼
  Thread.currentThread()          ← 取得當前執行緒
                                                                    │
       ▼
  thread.threadLocals             ← 取得 ThreadLocalMap
                                                                    │
       ▼
  map.get(this)                   ← this = ThreadLocal 實例，作為 key
                                                                    │
       ▼
  entry.value                     ← 返回使用者儲存的值

  ⚠️  記憶體洩漏風險：
  ┌─────────────────────────────────────────────────────────────────┐
  │  ThreadLocal 實例被 GC（key 變 null）                           │
  │  → Entry 的 key = null，但 value 仍被強引用                     │
  │  → value 無法被 GC 回收 ← 洩漏！                                │
  │                                                                 │
  │  防範：使用完畢後務必呼叫 threadLocal.remove()                  │
  └─────────────────────────────────────────────────────────────────┘
</code></pre>
<p>每個執行緒持有自己的本地變數副本，互不干擾。</p>
<p>ThreadLocal 的核心不是「一個全局變數有多份副本」，而是「每個 Thread 物件內部有一個 <code>ThreadLocalMap</code>」。<code>get()/set()</code> 實際上是在當前執行緒的 Map 中查找/寫入，以 ThreadLocal 實例本身作為 key。</p>
<p>關鍵細節：Map 中的 key 是弱引用（WeakReference），若 ThreadLocal 實例沒有外部強引用而被 GC 回收，key 就會變成 null，但 value 仍被 Entry 強引用，造成洩漏。執行緒池中的執行緒長期存活，此問題尤為危險。</p>
<h2 id="144-不繼承性"><a class="header" href="#144-不繼承性">14.4 不繼承性</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-57"><a class="header" href="#本小節示意圖-57">本小節示意圖</a></h3>
<pre><code class="language-text">  父執行緒 vs 子執行緒的 ThreadLocal 隔離

  ┌──────────────────────────────────────────────────────────────────┐
  │  父執行緒（Parent Thread）                                       │
  │  threadLocals: { TL_user_id → 42, TL_request → "req-001" }       │
  └────────────────────────────┬─────────────────────────────────────┘
                               │ new Thread(...)  或  pool.submit(...)
                               │ 建立子執行緒
                               ▼
  ┌──────────────────────────────────────────────────────────────────┐
  │  子執行緒（Child Thread）                                        │
  │  threadLocals: { }   ← 空 Map！                                  │
   │                                                                 │
  │  child.get(TL_user_id)  → null（或 initialValue()）              │
  │  child.get(TL_request)  → null（或 initialValue()）              │
  └──────────────────────────────────────────────────────────────────┘

  ⚠️  常見問題：
  父執行緒設定了 user_id=42（用於追蹤請求）
  提交任務到執行緒池後，子執行緒讀到 null
  → 日誌無法關聯到正確的請求 ID
  → 解決方案：改用 InheritableThreadLocal（見 14.5）
              或手動在 submit 時捕獲並傳遞值
</code></pre>
<p>子執行緒預設看不到父執行緒 ThreadLocal。</p>
<p>這個設計是有意的：ThreadLocal 的語義是「執行緒私有」，若自動繼承反而破壞隔離性。但在請求追蹤（Trace ID）等場景確實需要傳遞上下文，此時應使用 InheritableThreadLocal 或顯式傳遞。</p>
<h2 id="145146-可繼承變體"><a class="header" href="#145146-可繼承變體">14.5~14.6 可繼承變體</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-58"><a class="header" href="#本小節示意圖-58">本小節示意圖</a></h3>
<pre><code class="language-text">  InheritableThreadLocal：建立子執行緒時複製快照

  ┌──────────────────────────────────────────────────────────────────┐
  │  父執行緒                                                        │
  │  inheritableThreadLocals: { ITL_user → 42, ITL_locale → "zh" }   │
  └────────────────────────────┬─────────────────────────────────────┘
                               │ new Thread() 時，JVM 自動複製快照
                               ▼
  ┌──────────────────────────────────────────────────────────────────┐
  │  子執行緒（建立時複製）                                          │
  │  inheritableThreadLocals: { ITL_user → 42, ITL_locale → "zh" }   │
  │                           ↑ 獨立副本，修改互不影響               │
  └──────────────────────────────────────────────────────────────────┘

  child.set(ITL_user, 99)  → 只影響子執行緒，父執行緒仍是 42

  ⚠️  執行緒池問題：
  Pool 中的執行緒在建立時已複製，之後複用時不會再複製
  父執行緒後續修改的值，Pool Worker 看不到

  ─────────────────────────────────────────────────────────────────

  設計哲學對比：Java vs Go

  Java：隱式攜帶（InheritableThreadLocal）
  ┌──────────────────────────────────────────────────────────────────┐
  │ 上下文隱藏在執行緒內部                                           │
  │ 優點：呼叫方不需要傳參                                           │
  │ 缺點：隱式依賴，難以追蹤                                         │
  └──────────────────────────────────────────────────────────────────┘

  Go：顯式傳遞（context.Context）
  ┌──────────────────────────────────────────────────────────────────┐
  │ func process(ctx context.Context) {                              │
  │     userID := ctx.Value("user_id")                               │
  │     child(ctx)  ← 顯式傳遞                                       │
  │ }                                                                │
  │ 優點：資料流向清晰，易於測試                                     │
  │ 缺點：所有函式都需要加 ctx 參數                                  │
  └──────────────────────────────────────────────────────────────────┘
</code></pre>
<p>InheritableThreadLocal 可在建立子執行緒時複製上下文。</p>
<p>跨語言對比：</p>
<ul>
<li>C/C++: <code>thread_local</code> — 關鍵字宣告，編譯器自動為每個執行緒分配獨立儲存</li>
<li>Rust: <code>thread_local!</code> — 宏定義，支援懶初始化</li>
<li>Go: 常用 <code>context.Context</code> 顯式傳遞，不鼓勵隱式 thread local；這反映了 Go 「明確優於隱式」的設計哲學</li>
</ul>
<pre><code class="language-text">Thread A: user_id=42
Thread B: user_id=? (預設拿不到 A 的值)
</code></pre>
<h2 id="跨語言完整範例-13"><a class="header" href="#跨語言完整範例-13">跨語言完整範例</a></h2>
<p>執行緒本地儲存：每個執行緒有自己的 user_id，互不干擾，演示隔離性。</p>
<h3 id="c-6"><a class="header" href="#c-6">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch14_c ch14.c &amp;&amp; ./ch14_c */
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

/* thread_local 在 C11 中為 _Thread_local，gcc 支援 __thread */
static __thread int user_id = 0;

typedef struct { int set_id; const char *name; } Args;

void *thread_fn(void *arg) {
    Args *a = (Args *)arg;
    user_id = a-&gt;set_id;                  /* 只影響當前執行緒 */
    usleep(10000);                         /* 讓其他執行緒也設定自己的值 */
    printf("%-10s user_id=%d\n", a-&gt;name, user_id);
    return NULL;
}

int main(void) {
    Args args[] = {{42, "Thread-A"}, {7, "Thread-B"}, {100, "Thread-C"}};
    pthread_t threads[3];

    for (int i = 0; i &lt; 3; i++)
        pthread_create(&amp;threads[i], NULL, thread_fn, &amp;args[i]);
    for (int i = 0; i &lt; 3; i++)
        pthread_join(threads[i], NULL);

    printf("Main thread user_id=%d (never set, remains 0)\n", user_id);
    return 0;
}
</code></pre>
<h3 id="c-7"><a class="header" href="#c-7">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch14_cpp ch14.cpp &amp;&amp; ./ch14_cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;

thread_local int user_id = 0;          // 每個執行緒各自的 user_id
thread_local std::string request_id;   // 每個執行緒各自的 request_id

void handle_request(int uid, const std::string &amp;rid) {
    user_id    = uid;
    request_id = rid;
    std::this_thread::sleep_for(std::chrono::milliseconds(10));

    // 讀回自己的值，不受其他執行緒影響
    std::cout &lt;&lt; "Thread " &lt;&lt; std::this_thread::get_id()
              &lt;&lt; " user_id=" &lt;&lt; user_id
              &lt;&lt; " request_id=" &lt;&lt; request_id &lt;&lt; "\n";
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    threads.emplace_back(handle_request, 42,  "req-001");
    threads.emplace_back(handle_request, 7,   "req-002");
    threads.emplace_back(handle_request, 100, "req-003");
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "main thread: user_id=" &lt;&lt; user_id
              &lt;&lt; " (0，從未設定)\n";
    return 0;
}
</code></pre>
<h3 id="rust-3"><a class="header" href="#rust-3">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch14.rs -o ch14 &amp;&amp; ./ch14
use std::cell::RefCell;
use std::thread;

thread_local! {
    static USER_ID:    RefCell&lt;i32&gt;     = RefCell::new(0);
    static REQUEST_ID: RefCell&lt;String&gt;  = RefCell::new(String::new());
}

fn handle_request(uid: i32, rid: &amp;'static str) {
    USER_ID.with(|u| *u.borrow_mut() = uid);
    REQUEST_ID.with(|r| *r.borrow_mut() = rid.to_string());

    thread::sleep(std::time::Duration::from_millis(10));

    USER_ID.with(|u| {
        REQUEST_ID.with(|r| {
            println!("thread {:?}: user_id={}, request_id={}",
                     thread::current().id(), u.borrow(), r.borrow());
        });
    });
}

fn main() {
    let handles: Vec&lt;_&gt; = vec![
        (42,  "req-001"),
        (7,   "req-002"),
        (100, "req-003"),
    ].into_iter().map(|(uid, rid)| {
        thread::spawn(move || handle_request(uid, rid))
    }).collect();

    for h in handles { h.join().unwrap(); }
    USER_ID.with(|u| println!("main: user_id={} (0，從未設定)", u.borrow()));
}</code></pre></pre>
<h3 id="go-3"><a class="header" href="#go-3">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch14.go
// Go 不推薦隱式 thread-local，改用 context.Context 顯式傳遞
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

type contextKey string

const keyUserID    contextKey = "user_id"
const keyRequestID contextKey = "request_id"

// handleRequest 接收 context，從中讀取執行緒「本地」資料
// 這是 Go 的慣用做法：顯式傳遞，不依賴隱式 goroutine-local
func handleRequest(ctx context.Context, wg *sync.WaitGroup) {
	defer wg.Done()
	time.Sleep(10 * time.Millisecond)

	uid := ctx.Value(keyUserID)
	rid := ctx.Value(keyRequestID)
	fmt.Printf("goroutine: user_id=%v, request_id=%v\n", uid, rid)
}

func main() {
	var wg sync.WaitGroup
	requests := []struct {
		userID    int
		requestID string
	}{
		{42, "req-001"},
		{7, "req-002"},
		{100, "req-003"},
	}

	for _, req := range requests {
		ctx := context.WithValue(context.Background(), keyUserID, req.userID)
		ctx = context.WithValue(ctx, keyRequestID, req.requestID)
		wg.Add(1)
		go handleRequest(ctx, &amp;wg)
	}
	wg.Wait()
	fmt.Println("Done — Go 使用 context 顯式傳遞，語意清晰")
}
</code></pre>
<h3 id="python-3"><a class="header" href="#python-3">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch14.py
import threading
import time


# threading.local() 為每個執行緒提供獨立的命名空間
local_storage = threading.local()


def handle_request(user_id: int, request_id: str):
    """每個執行緒設定自己的 local 變數，互不干擾。"""
    local_storage.user_id    = user_id
    local_storage.request_id = request_id
    time.sleep(0.01)   # 讓其他執行緒也在設定自己的值

    # 讀回自己設定的值
    print(f"{threading.current_thread().name}: "
          f"user_id={local_storage.user_id}, "
          f"request_id={local_storage.request_id}")


if __name__ == "__main__":
    requests = [(42, "req-001"), (7, "req-002"), (100, "req-003")]
    threads = [
        threading.Thread(target=handle_request, args=(uid, rid),
                         name=f"Thread-{i}")
        for i, (uid, rid) in enumerate(requests)
    ]
    for t in threads: t.start()
    for t in threads: t.join()

    # 主執行緒從未設定，讀取會拋出 AttributeError
    try:
        print(f"main: user_id={local_storage.user_id}")
    except AttributeError:
        print("main: user_id 未設定（符合預期，各執行緒隔離）")
</code></pre>
<h2 id="完整專案級範例python-13"><a class="header" href="#完整專案級範例python-13">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch14.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch14.py
</code></pre>
<pre><code class="language-python">"""Chapter 14: thread local — 執行緒本地儲存，每個執行緒持有獨立副本。"""
import threading

local = threading.local()


def run(name: str, uid: int):
    """設定執行緒本地的 user_id，讀回時只看到自己設定的值。"""
    local.user_id = uid
    # 即使其他執行緒同時修改各自的 user_id，這裡讀到的仍是自己的值
    print(f"{name} user_id={local.user_id}")


if __name__ == "__main__":
    t1 = threading.Thread(target=run, args=("T1", 42))
    t2 = threading.Thread(target=run, args=("T2", 7))
    t1.start(); t2.start(); t1.join(); t2.join()
    # 主執行緒從未設定，驗證隔離性
    try:
        print(f"main user_id={local.user_id}")
    except AttributeError:
        print("main: user_id 不存在（各執行緒完全隔離）")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第15章-手寫線程池實戰"><a class="header" href="#第15章-手寫線程池實戰">第15章 手寫線程池實戰</a></h1>
<h2 id="151-結構設計"><a class="header" href="#151-結構設計">15.1 結構設計</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-59"><a class="header" href="#本小節示意圖-59">本小節示意圖</a></h3>
<pre><code class="language-text">  ThreadPool 核心組件圖

  ┌──────────────────────────────────────────────────────────────────┐
  │                        ThreadPool                                │
   │                                                                 │
  │  ┌───────────────────────────────────────────────────────────┐   │
  │  │  state: AtomicInteger                                     │   │
  │  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────────┐ │   │
  │  │  │ RUNNING  │→ │SHUTDOWN  │→ │  STOP    │→ │TERMINATED  │ │   │
  │  │  └──────────┘  └──────────┘  └──────────┘  └────────────┘ │   │
  │  └───────────────────────────────────────────────────────────┘   │
  │                              │ 控制                              │
  │  ┌──────────────────┐        │        ┌────────────────────┐     │
  │  │  task_queue      │        │        │  workers           │     │
  │  │  BlockingQueue   │◄───────┴───────►│  Set&lt;Thread&gt;       │     │
  │  │                  │    協作           │                  │     │
  │  │  [Task][Task]    │  ─poll()─►      │  [W1][W2][W3][W4]  │     │
  │  │  [Task][Task]    │                 │   ↑執行任務↑       │     │
  │  └──────────────────┘                 └────────────────────┘     │
  │          ▲ submit()                                              │
  │          │                   飽和時觸發                          │
  │  ┌───────┴──────┐        ┌────────────────────────────────┐      │
  │  │   外部呼叫方  │        │  reject_policy                │      │
  │  │  (Producer)  │        │  RejectedExecutionHandler      │      │
  │  └──────────────┘        │  Abort / CallerRuns / Discard  │      │
  │                           └───────────────────────────────┘      │
   │                                                                 │
  │  組件職責：                                                      │
  │  • task_queue：緩衝待執行任務，解耦生產者與消費者                │
  │  • workers：實際執行任務的執行緒集合，數量在 [core, max] 間調整  │
  │  • state：協調關閉流程，防止競態                                 │
  │  • reject_policy：佇列+執行緒都滿時的降級策略                    │
  └──────────────────────────────────────────────────────────────────┘
</code></pre>
<p>需要的核心欄位：</p>
<ul>
<li><strong>任務佇列（task_queue）</strong>：BlockingQueue，生產者 submit 入佇，worker 出佇執行</li>
<li><strong>worker 集合（workers）</strong>：追蹤所有活躍執行緒，用於關閉時中斷</li>
<li><strong>運行狀態（state）</strong>：AtomicInteger，防止在關閉中繼續接受任務</li>
<li><strong>拒絕策略（reject_policy）</strong>：飽和時的處理方式，預設拋出例外</li>
</ul>
<h2 id="152-worker-邏輯"><a class="header" href="#152-worker-邏輯">15.2 Worker 邏輯</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-60"><a class="header" href="#本小節示意圖-60">本小節示意圖</a></h3>
<pre><code class="language-text">  Worker 主循環流程圖

  Worker 執行緒啟動
                                                           │
        ▼
  ┌────────────────────────────────────────────────────────┐
  │  loop（主循環）      │ ◄───────────────────────────────┐
  └──────────┬─────────────┘                               │
                │                                          │
             ▼                                             │
  ┌────────────────────────────────────────┐               │
  │  task = queue.poll(keepAliveTime)      │               │
  │  （等待最多 keepAliveTime 超時）       │               │
  └──────────────┬─────────────────────────┘               │
                   │                                       │
        task != null?                                      │
        ┌────────┴───────────┐                             │
        │是               │否（等待超時）                  │
        ▼                 ▼                                │
  ┌───────────┐   是否為核心執行緒？                       │
  │ execute() │   ┌────────┴───────────┐                   │
  │  task     │   │是               │否（非核心）          │
  └─────┬─────┘   ▼                 ▼                      │
        │   繼續等待，        workers.size &gt; core?         │
        │   不退出            ┌────────┴──────────┐        │
        │                    │是               │否         │
        │                    ▼                 ▼           │
        │             ┌─────────────┐    繼續等待          │
        │             │ 退出 loop   │    不退出 ─────────► │
        │             │ workers.                           │
        │             │ remove(this)                       │
        └─────────────►            │ ←──────────── shutdown?
                      └─────────────┘                   ▲
                                                           │
                               pool.state == SHUTDOWN  ────┘
                               且 queue 已空 → 退出
</code></pre>
<p>worker 持續從佇列取任務執行，遇到關閉訊號退出。</p>
<p>Worker 的關鍵設計點：</p>
<ol>
<li><strong>keepAlive 超時</strong>：非核心執行緒等待超過 keepAliveTime 後縮容退出，避免資源浪費</li>
<li><strong>中斷響應</strong>：<code>shutdownNow()</code> 時送出中斷，worker 的 <code>poll()</code> 會拋出 <code>InterruptedException</code> 並退出</li>
<li><strong>退出清理</strong>：worker 退出前從 <code>workers</code> 集合中移除自己，並在必要時判斷是否需要觸發 <code>TERMINATED</code> 狀態</li>
</ol>
<h2 id="153-提交與關閉對應-15311536"><a class="header" href="#153-提交與關閉對應-15311536">15.3 提交與關閉（對應 15.3.1~15.3.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-61"><a class="header" href="#本小節示意圖-61">本小節示意圖</a></h3>
<pre><code class="language-text">  submit(task) 流程圖

  submit(task)
                                                                  │
       ▼
  ┌───────────────────────────────────────────────────────────────┐
  │ state == RUNNING ?                                            │
  └──────────┬────────────────────────────────────────────────────┘
       是 │           │ 否（SHUTDOWN/STOP）
          ▼           ▼
  ┌──────────────┐  ┌─────────────────────────────────────────────┐
  │ queue.offer  │  │ reject(task)                                │
  │ (task) 成功? │  │ RejectedExecution                           │
  └──────┬───────┘  └─────────────────────────────────────────────┘
    是 │     │ 否（佇列滿）
       ▼     ▼
  ┌──────┐  ┌─────────────────────────────────────────────────────┐
  │ 返回 │  │ workers.size &lt; maxPoolSize?                         │
  └──────┘  └────────────┬────────────────────────────────────────┘
                  是 │           │ 否
                     ▼           ▼
             ┌──────────────┐  ┌──────────────────────────────────┐
             │ 新建 Worker  │  │ reject(task)                     │
             │ 執行此任務   │  │（飽和拒絕）                      │
             └──────────────┘  └──────────────────────────────────┘

  ─────────────────────────────────────────────────────────────────

  shutdown() 流程圖

  shutdown()
                                                                  │
       ├─► 1. 原子設定 state = SHUTDOWN
                                                                  │
       ├─► 2. 中斷所有閒置 workers（喚醒正在 poll() 等待的執行緒）
                                                                  │
       ├─► 3. 不再接受新的 submit()
                                                                  │
       └─► 4. 等待佇列排空 + workers 歸零 → 轉入 TERMINATED
            （可用 awaitTermination() 阻塞等待）
</code></pre>
<ul>
<li><strong>submit</strong>：放入佇列或觸發拒絕</li>
<li><strong>shutdown</strong>：停止收新任務，排空後結束</li>
</ul>
<p>關閉的正確姿勢是先呼叫 <code>shutdown()</code>，再以迴圈呼叫 <code>awaitTermination()</code> 直到返回 <code>true</code> 或超時強制中斷（<code>shutdownNow()</code>）。</p>
<h2 id="154-測試"><a class="header" href="#154-測試">15.4 測試</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-62"><a class="header" href="#本小節示意圖-62">本小節示意圖</a></h3>
<pre><code class="language-text">  測試場景清單與期望行為

  ┌──────────────────────────────────────────────────────────────────┐
  │  場景 1：正常提交                                                │
  │  操作：提交 N 個任務（N ≤ queue capacity）                       │
  │  期望：所有任務按完成，無例外，result 集合 size == N             │
  ├──────────────────────────────────────────────────────────────────┤
  │  場景 2：飽和拒絕                                                │
  │  操作：workers 全忙 + 佇列滿時繼續提交                           │
  │  期望：觸發 RejectedExecutionException（或自定義策略動作）       │
  │  驗證：已進入佇列的任務仍能正常完成                              │
  ├──────────────────────────────────────────────────────────────────┤
  │  場景 3：優雅關閉（shutdown）                                    │
  │  操作：提交 N 個任務後立即 shutdown()                            │
  │  期望：所有已提交任務執行完畢，awaitTermination 返回 true        │
  │  禁止：shutdown 後再 submit 拋出 RejectedExecutionException      │
  ├──────────────────────────────────────────────────────────────────┤
  │  場景 4：強制中斷（shutdownNow）                                 │
  │  操作：任務執行中呼叫 shutdownNow()                              │
  │  期望：返回未執行任務列表，正在執行的任務收到中斷訊號            │
  │  驗證：list.size == 未執行任務數量                               │
  ├──────────────────────────────────────────────────────────────────┤
  │  場景 5：keepAlive 縮容                                          │
  │  操作：高峰期超過 coreSize，低峰期閒置超過 keepAliveTime         │
  │  期望：非核心執行緒自動退出，workers.size 降回 coreSize          │
  │  驗證：等待 keepAliveTime + buffer 後檢查 activeCount            │
  └──────────────────────────────────────────────────────────────────┘

  壓測指標：
  ┌─────────────┬────────────────────────────────────────────────────┐
  │  吞吐量     │ tasks/second，對比序列執行的加速比                 │
  │  延遲 P99   │ 第 99 百分位任務完成時間，反映長尾效能             │
  │  拒絕比例   │ rejected / total，評估參數設定是否合理             │
  │  佇列水位   │ queue.size() 峰值，評估是否需要擴容                │
  └─────────────┴────────────────────────────────────────────────────┘
</code></pre>
<p>壓測觀察吞吐、延遲、拒絕比例。</p>
<p>測試線程池時需涵蓋正常路徑和各種邊界情況。特別注意關閉時的競態：<code>shutdown()</code> 和最後一個任務完成之間存在時間視窗，測試需等待 <code>awaitTermination()</code> 返回 <code>true</code> 才能斷言結果。</p>
<pre><code class="language-text">while (running) {
  task = queue.pop()
  run(task)
}
</code></pre>
<h2 id="跨語言完整範例-14"><a class="header" href="#跨語言完整範例-14">跨語言完整範例</a></h2>
<p>最簡執行緒池：channel 做佇列，N 個 goroutine/thread 做 worker，展示核心機制。</p>
<h3 id="c-8"><a class="header" href="#c-8">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch15_c ch15.c &amp;&amp; ./ch15_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdatomic.h&gt;

#define WORKERS   4
#define TASKS     20
#define QCAP      64

typedef struct { int id; } Task;

/* 環形緩衝佇列 */
typedef struct {
    Task        buf[QCAP];
    int         head, tail, size;
    pthread_mutex_t mu;
    pthread_cond_t  not_empty;
    atomic_int  shutdown;
    atomic_int  completed;
} Pool;

static Pool pool;

static void pool_init(void) {
    pool.head = pool.tail = pool.size = 0;
    atomic_store(&amp;pool.shutdown, 0);
    atomic_store(&amp;pool.completed, 0);
    pthread_mutex_init(&amp;pool.mu, NULL);
    pthread_cond_init(&amp;pool.not_empty, NULL);
}

static void pool_submit(int task_id) {
    pthread_mutex_lock(&amp;pool.mu);
    pool.buf[pool.tail] = (Task){task_id};
    pool.tail = (pool.tail + 1) % QCAP;
    pool.size++;
    pthread_cond_signal(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);
}

static void *worker_loop(void *arg) {
    int wid = *(int *)arg;
    for (;;) {
        pthread_mutex_lock(&amp;pool.mu);
        while (pool.size == 0 &amp;&amp; !atomic_load(&amp;pool.shutdown))
            pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
        if (pool.size == 0) {           /* shutdown + 空佇列 */
            pthread_mutex_unlock(&amp;pool.mu);
            break;
        }
        Task t = pool.buf[pool.head];
        pool.head = (pool.head + 1) % QCAP;
        pool.size--;
        pthread_mutex_unlock(&amp;pool.mu);

        usleep(20000);                  /* 模擬 20ms 工作 */
        int done = atomic_fetch_add(&amp;pool.completed, 1) + 1;
        printf("Worker%d finished task %2d (total done: %d)\n",
               wid, t.id, done);
    }
    return NULL;
}

int main(void) {
    pool_init();
    pthread_t threads[WORKERS];
    int ids[WORKERS];
    for (int i = 0; i &lt; WORKERS; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker_loop, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASKS; i++) {
        pool_submit(i);
    }
    /* 等佇列排空後再 shutdown */
    pthread_mutex_lock(&amp;pool.mu);
    while (pool.size &gt; 0)
        pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
    atomic_store(&amp;pool.shutdown, 1);
    pthread_cond_broadcast(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);

    for (int i = 0; i &lt; WORKERS; i++) pthread_join(threads[i], NULL);
    printf("All %d tasks done.\n", atomic_load(&amp;pool.completed));
    return 0;
}
</code></pre>
<h3 id="c-9"><a class="header" href="#c-9">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch15_cpp ch15.cpp &amp;&amp; ./ch15_cpp
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;atomic&gt;

class SimpleThreadPool {
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::vector&lt;std::thread&gt; workers;
    std::mutex mu;
    std::condition_variable cv;
    bool stopped = false;
    std::atomic&lt;int&gt; completed{0};

public:
    explicit SimpleThreadPool(int n) {
        for (int i = 0; i &lt; n; i++) {
            workers.emplace_back([this, i] {
                for (;;) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock lk(mu);
                        cv.wait(lk, [this]{ return stopped || !tasks.empty(); });
                        if (stopped &amp;&amp; tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                    completed++;
                }
            });
        }
    }

    void submit(std::function&lt;void()&gt; f) {
        { std::lock_guard lk(mu); tasks.push(std::move(f)); }
        cv.notify_one();
    }

    int done_count() const { return completed.load(); }

    void shutdown() {
        { std::lock_guard lk(mu); stopped = true; }
        cv.notify_all();
        for (auto &amp;t : workers) t.join();
    }
};

int main() {
    SimpleThreadPool pool(4);
    std::mutex print_mu;

    for (int i = 0; i &lt; 20; i++) {
        pool.submit([i, &amp;print_mu, &amp;pool] {
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
            std::lock_guard lk(print_mu);
            std::cout &lt;&lt; "Task " &lt;&lt; std::setw(2) &lt;&lt; i
                      &lt;&lt; " done, total=" &lt;&lt; pool.done_count() + 1 &lt;&lt; "\n";
        });
    }
    pool.shutdown();
    std::cout &lt;&lt; "All tasks completed, total=" &lt;&lt; pool.done_count() &lt;&lt; "\n";
    return 0;
}
</code></pre>
<h3 id="rust-4"><a class="header" href="#rust-4">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch15.rs -o ch15 &amp;&amp; ./ch15
use std::sync::{Arc, Mutex, Condvar};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;
use std::collections::VecDeque;

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

struct SimplePool {
    queue:     Mutex&lt;VecDeque&lt;Option&lt;Job&gt;&gt;&gt;,
    cv:        Condvar,
    completed: AtomicUsize,
}

impl SimplePool {
    fn new() -&gt; Arc&lt;Self&gt; {
        Arc::new(SimplePool {
            queue:     Mutex::new(VecDeque::new()),
            cv:        Condvar::new(),
            completed: AtomicUsize::new(0),
        })
    }

    fn submit(self: &amp;Arc&lt;Self&gt;, f: impl FnOnce() + Send + 'static) {
        self.queue.lock().unwrap().push_back(Some(Box::new(f)));
        self.cv.notify_one();
    }

    fn spawn_workers(self: &amp;Arc&lt;Self&gt;, n: usize) -&gt; Vec&lt;thread::JoinHandle&lt;()&gt;&gt; {
        (0..n).map(|_| {
            let pool = Arc::clone(self);
            thread::spawn(move || loop {
                let job = {
                    let mut q = pool.cv
                        .wait_while(pool.queue.lock().unwrap(), |q| q.is_empty())
                        .unwrap();
                    q.pop_front().unwrap()
                };
                match job {
                    Some(f) =&gt; { f(); pool.completed.fetch_add(1, Ordering::Relaxed); }
                    None    =&gt; break,
                }
            })
        }).collect()
    }

    fn shutdown(self: &amp;Arc&lt;Self&gt;, handles: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;, n: usize) {
        for _ in 0..n {
            self.queue.lock().unwrap().push_back(None);
            self.cv.notify_one();
        }
        for h in handles { h.join().unwrap(); }
    }
}

fn main() {
    const WORKERS: usize = 4;
    const TASKS:   usize = 20;

    let pool = SimplePool::new();
    let handles = pool.spawn_workers(WORKERS);

    for i in 0..TASKS {
        let p = Arc::clone(&amp;pool);
        pool.submit(move || {
            thread::sleep(std::time::Duration::from_millis(20));
            let done = p.completed.load(Ordering::Relaxed) + 1;
            println!("Task {:2} done, completed so far: {}", i, done);
        });
    }
    pool.shutdown(handles, WORKERS);
    println!("Total completed: {}", pool.completed.load(Ordering::Relaxed));
}</code></pre></pre>
<h3 id="go-4"><a class="header" href="#go-4">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch15.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

// SimplePool：channel 作為任務佇列，goroutine 作為 worker
type SimplePool struct {
	jobs      chan func()
	wg        sync.WaitGroup
	completed int64
}

func NewPool(workers, queueSize int) *SimplePool {
	p := &amp;SimplePool{jobs: make(chan func(), queueSize)}
	for i := 0; i &lt; workers; i++ {
		workerID := i
		go func() {
			for job := range p.jobs {
				job()
				atomic.AddInt64(&amp;p.completed, 1)
				fmt.Printf("  Worker%d: task done (total=%d)\n",
					workerID, atomic.LoadInt64(&amp;p.completed))
			}
		}()
	}
	return p
}

func (p *SimplePool) Submit(f func()) {
	p.wg.Add(1)
	p.jobs &lt;- func() {
		defer p.wg.Done()
		f()
	}
}

func (p *SimplePool) Shutdown() {
	p.wg.Wait()
	close(p.jobs)
}

func main() {
	const numWorkers = 4
	const numTasks   = 20

	pool := NewPool(numWorkers, 64)
	for i := 0; i &lt; numTasks; i++ {
		taskID := i
		pool.Submit(func() {
			time.Sleep(20 * time.Millisecond)
			_ = taskID
		})
	}
	pool.Shutdown()
	fmt.Printf("All done, completed=%d\n", atomic.LoadInt64(&amp;pool.completed))
}
</code></pre>
<h3 id="python-4"><a class="header" href="#python-4">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch15.py
import queue
import threading
import time
from typing import Callable


class SimpleThreadPool:
    """最簡執行緒池：queue 做佇列，Thread 做 worker。"""

    def __init__(self, num_workers: int, queue_size: int = 64):
        self._queue = queue.Queue(maxsize=queue_size)
        self._completed = 0
        self._lock = threading.Lock()
        self._workers = [
            threading.Thread(target=self._worker_loop, name=f"Worker-{i}",
                             daemon=True)
            for i in range(num_workers)
        ]
        for w in self._workers:
            w.start()

    def _worker_loop(self):
        """Worker 主循環：不斷從佇列取任務並執行。"""
        while True:
            task = self._queue.get()
            if task is None:        # None 作為關閉訊號
                self._queue.task_done()
                break
            try:
                task()
                with self._lock:
                    self._completed += 1
                    print(f"{threading.current_thread().name}: "
                          f"task done (total={self._completed})")
            finally:
                self._queue.task_done()

    def submit(self, fn: Callable):
        self._queue.put(fn)

    def shutdown(self):
        """等待所有任務完成後關閉。"""
        self._queue.join()          # 等佇列排空
        for _ in self._workers:
            self._queue.put(None)   # 每個 worker 一個停止訊號
        for w in self._workers:
            w.join()
        return self._completed


if __name__ == "__main__":
    pool = SimpleThreadPool(num_workers=4, queue_size=64)

    for i in range(20):
        def make_task(task_id):
            def task():
                time.sleep(0.02)
                _ = task_id     # 實際工作
            return task
        pool.submit(make_task(i))

    total = pool.shutdown()
    print(f"All tasks completed, total={total}")
</code></pre>
<h2 id="完整專案級範例python-14"><a class="header" href="#完整專案級範例python-14">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch15.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch15.py
</code></pre>
<pre><code class="language-python">"""Chapter 15: custom thread pool — 手動實作執行緒池的核心機制。"""
import queue
import threading

q = queue.Queue()
stop = object()              # 哨兵值，用來通知 worker 退出


def worker():
    """Worker 主循環：取任務執行，遇到 stop 哨兵則退出。"""
    while True:
        task = q.get()
        if task is stop:
            q.task_done()
            return
        try:
            task()
        finally:
            q.task_done()


if __name__ == "__main__":
    num_workers = 3
    workers = [threading.Thread(target=worker, daemon=True)
               for _ in range(num_workers)]
    for w in workers: w.start()

    # 提交 5 個任務
    for i in range(5):
        task_id = i
        q.put(lambda tid=task_id: print(f"task {tid} on {threading.current_thread().name}"))

    # 等所有任務完成，再送停止訊號
    q.join()
    for _ in workers: q.put(stop)
    for w in workers: w.join()
    print("pool shutdown complete")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第16章-cas-自旋鎖實戰"><a class="header" href="#第16章-cas-自旋鎖實戰">第16章 CAS 自旋鎖實戰</a></h1>
<h2 id="161-目標"><a class="header" href="#161-目標">16.1 目標</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-63"><a class="header" href="#本小節示意圖-63">本小節示意圖</a></h3>
<pre><code class="language-text">三種鎖模式對比

┌───────────────────────────────────────────────────────────────────┐
│                       鎖模式適用場景比較                          │
├───────────────┬───────────────┬───────────────────────────────────┤
│  Lock-free    │   Spin Lock   │          OS Mutex                 │
│     CAS         │               │                                 │
├───────────────┼───────────────┼───────────────────────────────────┤
│  無阻塞       │  短臨界區     │  長臨界區                         │
│  全自旋       │  適合高頻鎖   │  適合 I/O、DB 等耗時操作          │
  │               │               │                                 │
│  CPU 一直轉   │  等待期間     │  等待時讓出 CPU                   │
│  不切換執行緒 │  CPU 仍在燃燒 │  有上下文切換開銷                 │
├───────────────┼───────────────┼───────────────────────────────────┤
│  臨界區極短   │  臨界區 &lt; 幾  │  臨界區 &gt; 幾微秒                  │
│  衝突極低     │  微秒，低衝突 │  衝突較高                         │
│  適合計數器   │  適合 cache   │  適合資料庫操作                   │
├───────────────┼───────────────┼───────────────────────────────────┤
│               │               │                                 │
│  ●●●●●        │  ●●●○○        │  ●○○○○                            │
│  CPU 效率     │  CPU 效率     │  CPU 效率                         │
│  (高衝突時差) │  (中度場景佳) │  (等待時釋放CPU)                  │
└───────────────┴───────────────┴───────────────────────────────────┘

適用場景判斷流程：

  臨界區有多長？
                                                                    │
       ├─── &lt; 1 微秒 ──→ CAS / Lock-free（無鎖化）
                                                                    │
       ├─── 1~10 微秒 ──→ Spin Lock（自旋）
                                                                    │
       └─── &gt; 10 微秒 ──→ OS Mutex（阻塞等待）
</code></pre>
<p>用最少原語實作可用鎖，理解 lock-free 與 spin 的邊界。</p>
<h2 id="162-核心做法"><a class="header" href="#162-核心做法">16.2 核心做法</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-64"><a class="header" href="#本小節示意圖-64">本小節示意圖</a></h3>
<pre><code class="language-text">自旋鎖 CAS 流程圖

  flag = 0（free）  flag = 1（held）

  ┌──────────────────────────────────────────────────────────────┐
  │  atomic_flag / AtomicBool                                    │
          │                                                      │
  │   初始值 = 0（free）                                         │
  └──────────────────────────────────────────────────────────────┘

  lock() 流程：
  ┌──────────────────────────────────────────────────────────────┐
   │                                                             │
  │  ┌──────────┐    CAS(0→1)     ┌────────────┐                 │
  │  │  Thread  │ ─── 成功 ──────► │  進入     │                 │
  │  │  嘗試鎖  │                 │  臨界區    │                 │
  │  └──────────┘                 └────────────┘                 │
   │       │                                                     │
  │       │ CAS(0→1) 失敗                                        │
  │       ▼                                                      │
  │  ┌────────────────────────────────────────┐                  │
  │  │         自旋等待迴圈                   │                  │
  │  │                                      │ memory_order_      │
  │  │  while (flag != 0) {                 │ acquire ←──────    │
  │  │      [pause / yield]  ←── CPU 提示   │ 確保後續讀到       │
  │  │  }                                   │ 最新資料           │
  │  │  再試 CAS(0→1)                         │                  │
  │  └────────────────────────────────────────┘                  │
   │                                                             │
  └──────────────────────────────────────────────────────────────┘

  unlock() 流程：
  ┌──────────────────────────────────────────────────────────────┐
   │                                                             │
  │  ┌──────────┐   store(0)      ┌────────────────────────┐     │
  │  │  Thread  │ ──────────────► │  flag = 0（free）      │     │
  │  │  持有者  │  memory_order_  │  其他執行緒可競爭      │     │
  │  └──────────┘  release ────►  └────────────────────────┘     │
  │                 確保前面寫入                                 │
  │                 對其他執行緒可見                             │
  └──────────────────────────────────────────────────────────────┘

  memory_order 位置：
  ┌────────────────┬─────────────────────────────────────────────┐
  │  lock()        │  acquire  → 防止後方讀寫被提前到 lock 前    │
  │  unlock()      │  release  → 防止前方寫入被延遲到 unlock 後  │
  └────────────────┴─────────────────────────────────────────────┘
</code></pre>
<p>用 <code>atomic_flag</code> 或 CAS 標記鎖是否被占用。</p>
<h2 id="163-自旋成本"><a class="header" href="#163-自旋成本">16.3 自旋成本</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-65"><a class="header" href="#本小節示意圖-65">本小節示意圖</a></h3>
<pre><code class="language-text">低衝突 vs 高衝突時間軸

  ─── 低衝突場景（臨界區極短）───────────────────────────────────

  時間 ──────────────────────────────────────────────────────────►
        T+0      T+1us    T+2us    T+3us    T+4us

  T1   [鎖][工作][解鎖]
  T2                   [鎖][工作][解鎖]
  T3                                    [鎖][工作][解鎖]
  T4                                              [鎖][工作]...

  CPU  ████░░░░░████░░░░░████░░░░░████
       有效   空閒   有效   空閒
  → 效率高，自旋時間幾乎為零

  ─── 高衝突場景（多核競爭同一鎖）──────────────────────────────

  時間 ──────────────────────────────────────────────────────────►
        T+0      T+10us   T+20us   T+30us   T+40us

  T1   [鎖────────────────────────工作──────────────────][解鎖]
  T2   [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥][鎖──────工作──────][解]
  T3   [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥][鎖──]
  T4   [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥]

  Core 使用率：
  Core1 ████████████████████ 100%（T1 真正工作）
  Core2 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T2 白燒自旋）
  Core3 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T3 白燒自旋）
  Core4 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T4 白燒自旋）
        ↑
        CPU 使用率 100% 但 75% 是無效功！

  ┌──────────────────────────────────────────────────────────────┐
  │  高衝突下 Spin Lock 的問題：                                 │
  │  ・多個 Core 同時在旋轉 → 浪費電力與 CPU 時間                │
  │  ・Cache coherence 流量激增 → 總線飽和                       │
  │  ・其他任務無法使用被佔用的 Core                             │
  └──────────────────────────────────────────────────────────────┘
</code></pre>
<p>低衝突很快；高衝突會燒 CPU。</p>
<h2 id="164-工程補強"><a class="header" href="#164-工程補強">16.4 工程補強</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-66"><a class="header" href="#本小節示意圖-66">本小節示意圖</a></h3>
<pre><code class="language-text">自旋退避策略演進圖

  自旋失敗次數
  0        1        2        4        8       16      閾值
  │        │        │        │        │        │        │
  ▼        ▼        ▼        ▼        ▼        ▼        ▼
  ┌─────────────────────────────────────────────────────┐
  │ Plain  │ → 立即重試 CAS
  │  Spin  │   延遲 = 0
  └─────────────────────────────────────────────────────┘
       │ 失敗
       ▼
  ┌─────────────────────────────────────────────────────┐
  │ yield()│ → 讓出 CPU 時間片，讓持鎖者跑
  │        │   延遲 ≈ 1 排程週期（~100us）
  └─────────────────────────────────────────────────────┘
       │ 仍失敗
       ▼
  ┌─────────────────────────────────────────────────────┐
  │  Exponential Backoff                                │
                          │                             │
  │  delay = min(1ms × 2^n,                             │
  │              max_delay)                             │
                          │                             │
  │  retry 1: sleep 1ms                                 │
  │  retry 2: sleep 2ms                                 │
  │  retry 3: sleep 4ms                                 │
  │  retry 4: sleep 8ms  ──────►│ 抖動 (jitter) 避免
  │  retry 5: sleep 16ms        │ 所有執行緒同時重試
  └─────────────────────────────────────────────────────┘
       │ 超過閾值（例如 64ms）
       ▼
  ┌─────────────────────────────────────────────────────┐
  │  park() / futex_wait()                              │
                           │                            │
  │  執行緒進入睡眠                                     │
  │  OS 排程器管理                                      │
  │  鎖釋放時 unpark() 喚醒                             │
  │  CPU 完全釋放 → 零燒耗                              │
  └─────────────────────────────────────────────────────┘

  自旋次數 vs 退避延遲關係：

  延遲
  (ms)
  64 │                              ┌──────── park 阻塞
  32 │                          ────────────────────────┘
  16 │                      ────
   8 │                  ────
   4 │              ────
   2 │          ────
   1 │      ────
   0 │──────  yield
     └──────────────────────────── 自旋次數
      0   2   4   8  16  32  閾值
</code></pre>
<ul>
<li>指數退避（backoff）</li>
<li>達到閾值後改阻塞</li>
</ul>
<pre><code class="language-text">try CAS(lock, 0, 1)
fail -&gt; pause -&gt; retry
</code></pre>
<h2 id="示意圖-10"><a class="header" href="#示意圖-10">示意圖</a></h2>
<pre><code class="language-text">lock flag=0
T1 CAS(0-&gt;1) success 進入
T2 CAS(0-&gt;1) fail 自旋等待
</code></pre>
<h2 id="跨語言完整範例-15"><a class="header" href="#跨語言完整範例-15">跨語言完整範例</a></h2>
<h3 id="c--atomic_flag-自旋鎖4-執行緒並發測試"><a class="header" href="#c--atomic_flag-自旋鎖4-執行緒並發測試">C — atomic_flag 自旋鎖，4 執行緒並發測試</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;

#define THREADS 4
#define ITERS   50000

atomic_flag spin_lock = ATOMIC_FLAG_INIT;
long counter = 0;

void lock(void) {
    while (atomic_flag_test_and_set_explicit(&amp;spin_lock, memory_order_acquire))
        ;  /* spin */
}

void unlock(void) {
    atomic_flag_clear_explicit(&amp;spin_lock, memory_order_release);
}

void *worker(void *arg) {
    (void)arg;
    for (int i = 0; i &lt; ITERS; i++) {
        lock();
        counter++;
        unlock();
    }
    return NULL;
}

int main(void) {
    pthread_t tids[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tids[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tids[i], NULL);
    printf("counter = %ld (expected %d)\n", counter, THREADS * ITERS);
    return 0;
}
</code></pre>
<h3 id="c--stdatomic_flag-自旋鎖封裝"><a class="header" href="#c--stdatomic_flag-自旋鎖封裝">C++ — std::atomic_flag 自旋鎖封裝</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

class SpinLock {
    std::atomic_flag flag_ = ATOMIC_FLAG_INIT;
public:
    void lock() {
        while (flag_.test_and_set(std::memory_order_acquire))
            ;  /* spin */
    }
    void unlock() {
        flag_.clear(std::memory_order_release);
    }
};

int main() {
    SpinLock spin;
    long counter = 0;
    const int iters = 50000;
    auto task = [&amp;]() {
        for (int i = 0; i &lt; iters; i++) {
            spin.lock();
            counter++;
            spin.unlock();
        }
    };
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++)
        threads.emplace_back(task);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; 4 * iters &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rust--atomicbool-cas-自旋鎖"><a class="header" href="#rust--atomicbool-cas-自旋鎖">Rust — AtomicBool CAS 自旋鎖</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;

struct SpinLock(AtomicBool);

impl SpinLock {
    fn new() -&gt; Self { SpinLock(AtomicBool::new(false)) }
    fn lock(&amp;self) {
        while self.0
            .compare_exchange_weak(false, true, Ordering::Acquire, Ordering::Relaxed)
            .is_err()
        {
            std::hint::spin_loop();
        }
    }
    fn unlock(&amp;self) {
        self.0.store(false, Ordering::Release);
    }
}

fn main() {
    let spin = Arc::new(SpinLock::new());
    let counter = Arc::new(std::sync::atomic::AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..4 {
        let spin = Arc::clone(&amp;spin);
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..50_000 {
                spin.lock();
                counter.fetch_add(1, Ordering::Relaxed);
                spin.unlock();
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected 200000)", counter.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--atomicbool-cas-自旋鎖"><a class="header" href="#go--atomicbool-cas-自旋鎖">Go — atomic.Bool CAS 自旋鎖</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

type SpinLock struct{ held atomic.Bool }

func (s *SpinLock) Lock() {
    for !s.held.CompareAndSwap(false, true) {
        // spin
    }
}

func (s *SpinLock) Unlock() {
    s.held.Store(false)
}

func main() {
    var spin SpinLock
    var counter int64
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j &lt; 50_000; j++ {
                spin.Lock()
                counter++
                spin.Unlock()
            }
        }()
    }
    wg.Wait()
    fmt.Printf("counter = %d (expected 200000)\n", counter)
}
</code></pre>
<h3 id="python--ctypes-atomic-模擬-cas-自旋鎖"><a class="header" href="#python--ctypes-atomic-模擬-cas-自旋鎖">Python — ctypes atomic 模擬 CAS 自旋鎖</a></h3>
<pre><code class="language-python">"""Chapter 16: CAS spin lock — 4 threads, atomic counter verification."""
import threading
import time


class SpinLock:
    """用 threading.Lock 模擬 CAS atomic_flag 語意。"""

    def __init__(self):
        self._held = False
        self._internal = threading.Lock()

    def lock(self):
        while True:
            with self._internal:
                if not self._held:
                    self._held = True
                    return
            time.sleep(0)  # yield

    def unlock(self):
        with self._internal:
            self._held = False


def main():
    spin = SpinLock()
    counter = [0]
    iters = 50_000

    def worker():
        for _ in range(iters):
            spin.lock()
            counter[0] += 1
            spin.unlock()

    threads = [threading.Thread(target=worker) for _ in range(4)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    expected = 4 * iters
    print(f"counter = {counter[0]} (expected {expected})")
    assert counter[0] == expected, "競態條件！CAS 保護失效"
    print("通過：自旋鎖保護臨界區正確")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-15"><a class="header" href="#完整專案級範例python-15">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch16.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch16.py
</code></pre>
<pre><code class="language-python">"""Chapter 16: spin lock with exponential backoff."""
import threading
import time


class SpinLockWithBackoff:
    """帶指數退避的自旋鎖，高衝突時自動降低 CPU 浪費。"""

    MAX_BACKOFF_MS = 64

    def __init__(self):
        self._flag = False
        self._guard = threading.Lock()

    def lock(self):
        delay_ms = 1
        while True:
            with self._guard:
                if not self._flag:
                    self._flag = True
                    return
            # 指數退避：避免所有執行緒同時重試
            time.sleep(delay_ms / 1000)
            delay_ms = min(delay_ms * 2, self.MAX_BACKOFF_MS)

    def unlock(self):
        with self._guard:
            self._flag = False


if __name__ == "__main__":
    lk = SpinLockWithBackoff()
    state = {"x": 0}

    def work():
        for _ in range(5000):
            lk.lock()
            state["x"] += 1
            lk.unlock()

    ts = [threading.Thread(target=work) for _ in range(4)]
    for t in ts:
        t.start()
    for t in ts:
        t.join()
    print("x=", state["x"])
    assert state["x"] == 20000
    print("通過：指數退避自旋鎖保護正確")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第17章-讀寫鎖快取實戰"><a class="header" href="#第17章-讀寫鎖快取實戰">第17章 讀寫鎖快取實戰</a></h1>
<h2 id="171-場景"><a class="header" href="#171-場景">17.1 場景</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-67"><a class="header" href="#本小節示意圖-67">本小節示意圖</a></h3>
<pre><code class="language-text">讀寫比例與並發度對比

  典型快取存取分布：
  ┌───────────────────────────────────────────────────────────┐
  │  操作比例                                                 │
        │                                                     │
  │  Read  ████████████████████████████████████░  95%         │
  │  Write ██░                                    5%          │
        │                                                     │
  └───────────────────────────────────────────────────────────┘

  ─── 使用 Mutex（排他鎖）─────────────────────────────────────

  時間 ──────────────────────────────────────────────────────►
  R1   [讀─]
  R2       [等][讀─]
  R3             [等──][讀─]
  R4                       [等─────][讀─]
       ↑每次只有一個讀操作，其餘全部等待，嚴重浪費

  並發度：1 個同時（無論讀寫）

  ─── 使用 RWMutex（讀寫鎖）──────────────────────────────────

  時間 ──────────────────────────────────────────────────────►
  R1   [讀────────────────]
  R2   [讀────────────────]  ← 多個讀可以同時進行
  R3   [讀────────────────]
  R4   [讀────────────────]
  W1                      [等─][寫─][寫完，讀者可再進]

  並發度：讀者無限並發，寫者獨占

  ┌───────────────────────────────────────────────────────────┐
  │  RWMutex 帶來的效益（95% 讀場景）：                       │
  │  ・讀吞吐量提升 ~20x（從串行讀 → 並發讀）                 │
  │  ・寫操作仍然安全（獨占）                                 │
  │  ・適合：設定快取、查詢快取、計算結果快取等               │
  └───────────────────────────────────────────────────────────┘
</code></pre>
<p>讀多寫少的快取查詢。</p>
<h2 id="172-基本模式"><a class="header" href="#172-基本模式">17.2 基本模式</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-68"><a class="header" href="#本小節示意圖-68">本小節示意圖</a></h3>
<pre><code class="language-text">Cache 查找完整流程（含雙重檢查）

  客戶端請求 key
                                                                    │
       ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │  read_lock()  │  ← 允許多個讀者同時進入
  └───────┬─────────────────────────────────────────────────────────┘
                                                                    │
          ▼
  ┌───────────────┐    命中
  │  cache[key]   │ ──────────────────────────────────►  return value
  │  存在？                                                         │
  └───────┬─────────────────────────────────────────────────────────┘
          │ 未命中（miss）
          ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │  read_unlock()  │  ← 必須先釋放讀鎖，否則無法升級為寫鎖
  └───────┬─────────────────────────────────────────────────────────┘
                                                                    │
          ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │  write_lock() │  ← 等待所有讀者退出，獲得排他鎖
  └───────┬─────────────────────────────────────────────────────────┘
                                                                    │
          ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │  Double-Check: cache[key] 存在？   │  ← 二次確認！
  │                                    │    防止並發 miss 重複載入
  └───────┬─────────────────────────────────────────────────────────┘
                                               │                    │
          │ 已有（其他執行緒   │ 仍無
          │ 搶先載入了）                                            │
          ▼                    ▼
     return value        ┌──────────────────────────────────────────┐
                         │  load from                               │
                         │  DB / Source                             │
                         └──────┬───────────────────────────────────┘
                                                                    │
                                ▼
                         ┌──────────────────────────────────────────┐
                         │  cache[key]                              │
                         │    = value                               │
                         └──────┬───────────────────────────────────┘
                                                                    │
                                ▼
                         ┌──────────────────────────────────────────┐
                         │  write_unlock()                          │
                         └──────┬───────────────────────────────────┘
                                                                    │
                                ▼
                            return value

  ┌─────────────────────────────────────────────────────────────────┐
  │  為何需要雙重檢查（Double-Check）？                             │
         │                                                          │
  │  T1: miss → 釋放讀鎖 ─────────────────► 拿寫鎖 → load           │
  │  T2: miss → 釋放讀鎖 → 等待寫鎖 ─────► 拿寫鎖 → ???             │
         │                                                          │
  │  若無二次檢查：T1 load 後 T2 又 load → 重複查 DB！              │
  │  加上二次檢查：T2 拿到鎖後發現已有 → 直接返回 ✓                 │
  └─────────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>讀：拿讀鎖</li>
<li>未命中：升級流程（通常先釋放讀鎖，再拿寫鎖）</li>
<li>寫：更新後釋放寫鎖</li>
</ul>
<h2 id="173-結構設計對應-17311732"><a class="header" href="#173-結構設計對應-17311732">17.3 結構設計（對應 17.3.1~17.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-69"><a class="header" href="#本小節示意圖-69">本小節示意圖</a></h3>
<pre><code class="language-text">Cache 結構設計與 RWMutex 保護範圍

  ┌──────────────────────────────────────────────────────────┐
  │                   Cache 結構體                           │
   │                                                         │
  │  ┌─────────────────┐   ┌───────────────────────────────┐ │
  │  │  data: HashMap  │   │  RWMutex                      │ │
    │  │                 │   │                             │ │
  │  │  "user:1" → 42  │   │  RLock() / RUnlock()          │ │
  │  │  "user:2" → 18  │   │  ↑ 保護 data 的讀操作         │ │
  │  │  "user:3" → 99    │   │                             │ │
  │  │  ...            │   │  Lock() / Unlock()            │ │
  │  └─────────────────┘   │  ↑ 保護 data 的寫操作         │ │
  │                         └──────────────────────────────┘ │
  │  ┌──────────────────────────────────────────────────────┐│
  │  │  loader: fn(key) → value                             ││
  │  │  ↑ 當 cache miss 時，呼叫此函式載入資料              ││
  │  └──────────────────────────────────────────────────────┘│
  └──────────────────────────────────────────────────────────┘

  操作與鎖的對應關係：

  ┌──────────────────┬──────────────────┬────────────────────┐
  │     操作         │    使用的鎖      │     說明           │
  ├──────────────────┼──────────────────┼────────────────────┤
  │  Get (hit)       │  RLock/RUnlock   │  多讀者並發安全    │
  │  Get (miss)      │  先 RUnlock      │  釋放讀鎖後        │
  │                  │  再 Lock/Unlock  │  以寫鎖載入        │
  │  Set / Evict     │  Lock/Unlock     │  寫者獨占          │
  │  Len / Keys      │  RLock/RUnlock   │  只讀統計資訊      │
  └──────────────────┴──────────────────┴────────────────────┘

  多讀者並發示意：

  Reader1 ──[RLock]──[讀 data]──[RUnlock]──
  Reader2 ──[RLock]──[讀 data]──[RUnlock]──   ← 同時執行
  Reader3 ──[RLock]──[讀 data]──[RUnlock]──
                                                             │
                                          ▼
  Writer  ──────────────────────[Lock]──[寫 data]──[Unlock]──
                                 ↑
                           等所有 Reader 退出後才能進入
</code></pre>
<p>快取容器 + 讀寫鎖 + 載入函式。</p>
<h2 id="174-常見坑"><a class="header" href="#174-常見坑">17.4 常見坑</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-70"><a class="header" href="#本小節示意圖-70">本小節示意圖</a></h3>
<pre><code class="language-text">坑一：鎖升級死鎖

  ┌───────────────────────────────────────────────────────────────────┐
  │                    死鎖場景                                       │
           │                                                          │
  │  Thread A                   RWMutex                               │
  │  ─────────────────────────────────────────────────────            │
  │  RLock() ─────────────────► 讀鎖已獲得（readers=1）               │
  │  ... 處理中 ...                                                   │
  │  Lock() ──────────────────► 等待！因為讀鎖還在                    │
  │                             等所有讀者退出                        │
  │          ↑                         ↓                              │
  │          └──── A 持有讀鎖 ─────── A 等寫鎖 ────► 死鎖！           │
           │                                                          │
  │  正確做法：                                                       │
  │  RLock()  ─► 讀 ─► RUnlock() ─► Lock() ─► 寫 ─► Unlock()          │
  │              ↑必須先釋放讀鎖，才能升級為寫鎖                      │
  └───────────────────────────────────────────────────────────────────┘

坑二：缺少二次檢查 → 重複載入 DB

  ┌───────────────────────────────────────────────────────────────────┐
  │                 並發 Miss 場景                                    │
           │                                                          │
  │  時間 ──────────────────────────────────────────────────►         │
           │                                                          │
  │  T1: [RLock][miss][RUnlock]         [Lock][load DB!][Unlock]      │
  │  T2: [RLock][miss][RUnlock][等Lock─────────][load DB!][Unlock]    │
  │  T3: [RLock][miss][RUnlock][等等Lock──────────────][load DB!]     │
           │                                                          │
  │  ↑ 沒有二次檢查 → 3 個執行緒都去 load DB → N 倍壓力！             │
           │                                                          │
  │  ───────────────────────────────────────────────────────          │
           │                                                          │
  │  T1: [RLock][miss][RUnlock]         [Lock][load DB][Unlock]       │
  │  T2: [RLock][miss][RUnlock][等Lock─────][二次檢查 hit! ][Unlock]  │
  │  T3: [RLock][miss][RUnlock][等等Lock──────][二次檢查 hit!][Unlock]│
           │                                                          │
  │  ↑ 有二次檢查 → 只有 T1 load DB，T2/T3 直接命中 ✓                 │
  └───────────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>鎖升級死鎖</li>
<li>雙重檢查缺失造成重複載入</li>
</ul>
<pre><code class="language-text">read lock -&gt; miss -&gt; unlock read -&gt; lock write
          -&gt; check again -&gt; load -&gt; write -&gt; unlock
</code></pre>
<h2 id="示意圖-11"><a class="header" href="#示意圖-11">示意圖</a></h2>
<pre><code class="language-text">read lock -&gt; hit -&gt; return
read lock -&gt; miss -&gt; unlock read -&gt; write lock -&gt; load -&gt; write -&gt; unlock
</code></pre>
<h2 id="跨語言完整範例-16"><a class="header" href="#跨語言完整範例-16">跨語言完整範例</a></h2>
<h3 id="c--pthread-讀寫鎖保護-map-快取"><a class="header" href="#c--pthread-讀寫鎖保護-map-快取">C — pthread 讀寫鎖保護 map 快取</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define CACHE_SIZE 64

typedef struct { char key[32]; int value; int used; } Entry;

static Entry cache[CACHE_SIZE];
static pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

static int db_load(const char *key) {
    return (int)strlen(key) * 7;  /* 模擬資料庫查詢 */
}

int get_or_load(const char *key) {
    pthread_rwlock_rdlock(&amp;rwlock);
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (cache[i].used &amp;&amp; strcmp(cache[i].key, key) == 0) {
            int v = cache[i].value;
            pthread_rwlock_unlock(&amp;rwlock);
            return v;
        }
    }
    pthread_rwlock_unlock(&amp;rwlock);

    pthread_rwlock_wrlock(&amp;rwlock);
    /* 雙重檢查 */
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (cache[i].used &amp;&amp; strcmp(cache[i].key, key) == 0) {
            int v = cache[i].value;
            pthread_rwlock_unlock(&amp;rwlock);
            return v;
        }
    }
    int val = db_load(key);
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (!cache[i].used) {
            strncpy(cache[i].key, key, 31);
            cache[i].value = val;
            cache[i].used = 1;
            break;
        }
    }
    pthread_rwlock_unlock(&amp;rwlock);
    return val;
}

int main(void) {
    printf("alpha = %d\n", get_or_load("alpha"));
    printf("alpha = %d (cached)\n", get_or_load("alpha"));
    printf("beta  = %d\n", get_or_load("beta"));
    return 0;
}
</code></pre>
<h3 id="c--shared_mutex-讀寫鎖快取"><a class="header" href="#c--shared_mutex-讀寫鎖快取">C++ — shared_mutex 讀寫鎖快取</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;shared_mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

class RWCache {
    std::unordered_map&lt;std::string, int&gt; data_;
    mutable std::shared_mutex mu_;

    int load_from_db(const std::string &amp;key) {
        return static_cast&lt;int&gt;(key.size()) * 7;
    }
public:
    int get(const std::string &amp;key) {
        {
            std::shared_lock r(mu_);
            auto it = data_.find(key);
            if (it != data_.end()) return it-&gt;second;
        }
        std::unique_lock w(mu_);
        auto it = data_.find(key);  /* double-check */
        if (it != data_.end()) return it-&gt;second;
        int val = load_from_db(key);
        data_[key] = val;
        return val;
    }
};

int main() {
    RWCache cache;
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++) {
        threads.emplace_back([&amp;cache, i]() {
            std::string key = "key" + std::to_string(i % 2);
            for (int j = 0; j &lt; 100; j++) {
                int v = cache.get(key);
                (void)v;
            }
        });
    }
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "alpha=" &lt;&lt; cache.get("alpha") &lt;&lt; "\n";
    std::cout &lt;&lt; "完成：多讀者並發無競態\n";
}
</code></pre>
<h3 id="rust--rwlock-讀寫快取"><a class="header" href="#rust--rwlock-讀寫快取">Rust — RwLock<HashMap> 讀寫快取</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::thread;

struct RwCache {
    data: RwLock&lt;HashMap&lt;String, i32&gt;&gt;,
}

impl RwCache {
    fn new() -&gt; Self {
        RwCache { data: RwLock::new(HashMap::new()) }
    }
    fn get_or_load(&amp;self, key: &amp;str) -&gt; i32 {
        {
            let r = self.data.read().unwrap();
            if let Some(&amp;v) = r.get(key) { return v; }
        }
        let mut w = self.data.write().unwrap();
        if let Some(&amp;v) = w.get(key) { return v; }  /* double-check */
        let val = key.len() as i32 * 7;
        w.insert(key.to_string(), val);
        val
    }
}

fn main() {
    let cache = Arc::new(RwCache::new());
    let mut handles = vec![];
    for i in 0..4 {
        let c = Arc::clone(&amp;cache);
        handles.push(thread::spawn(move || {
            let key = format!("key{}", i % 2);
            for _ in 0..100 {
                let _ = c.get_or_load(&amp;key);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("alpha={}", cache.get_or_load("alpha"));
    println!("完成：Rust RwLock 快取正確");
}</code></pre></pre>
<h3 id="go--syncrwmutex-讀寫快取"><a class="header" href="#go--syncrwmutex-讀寫快取">Go — sync.RWMutex 讀寫快取</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

type RWCache struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewRWCache() *RWCache {
    return &amp;RWCache{data: make(map[string]int)}
}

func (c *RWCache) GetOrLoad(key string) int {
    c.mu.RLock()
    if v, ok := c.data[key]; ok {
        c.mu.RUnlock()
        return v
    }
    c.mu.RUnlock()

    c.mu.Lock()
    defer c.mu.Unlock()
    if v, ok := c.data[key]; ok { // double-check
        return v
    }
    val := len(key) * 7
    c.data[key] = val
    return val
}

func main() {
    cache := NewRWCache()
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id%2)
            for j := 0; j &lt; 100; j++ {
                cache.GetOrLoad(key)
            }
        }(i)
    }
    wg.Wait()
    fmt.Printf("alpha=%d\n", cache.GetOrLoad("alpha"))
    fmt.Println("完成：Go RWMutex 快取正確")
}
</code></pre>
<h3 id="python--threadingrlock-讀寫快取模擬"><a class="header" href="#python--threadingrlock-讀寫快取模擬">Python — threading.RLock 讀寫快取模擬</a></h3>
<pre><code class="language-python">"""Chapter 17: RW-lock cache — multi-reader concurrent, miss loads once."""
import threading
import time


class RWCache:
    def __init__(self, loader):
        self._data = {}
        self._lock = threading.Lock()
        self._readers = 0
        self._read_lock = threading.Lock()
        self._write_lock = threading.Lock()
        self._loader = loader

    def _rlock(self):
        with self._read_lock:
            self._readers += 1
            if self._readers == 1:
                self._write_lock.acquire()

    def _runlock(self):
        with self._read_lock:
            self._readers -= 1
            if self._readers == 0:
                self._write_lock.release()

    def get(self, key):
        self._rlock()
        val = self._data.get(key)
        self._runlock()
        if val is not None:
            return val
        with self._write_lock:
            if key in self._data:       # double-check
                return self._data[key]
            val = self._loader(key)
            self._data[key] = val
            return val


def main():
    load_count = [0]

    def db_load(key):
        load_count[0] += 1
        time.sleep(0.01)               # 模擬 DB 延遲
        return len(key) * 7

    cache = RWCache(db_load)
    results = []
    lock = threading.Lock()

    def reader(key):
        v = cache.get(key)
        with lock:
            results.append(v)

    threads = [threading.Thread(target=reader, args=("alpha",)) for _ in range(8)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    print(f"alpha 值: {results[0]}, 所有結果一致: {len(set(results)) == 1}")
    print(f"DB 實際載入次數: {load_count[0]} (應為 1，雙重檢查生效)")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-16"><a class="header" href="#完整專案級範例python-16">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch17.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch17.py
</code></pre>
<pre><code class="language-python">"""Chapter 17: rw-lock cache (simple)."""
import threading

cache = {}
lock = threading.RLock()


def get_or_load(k: str) -&gt; int:
    with lock:
        if k in cache:
            return cache[k]
    with lock:
        if k not in cache:
            cache[k] = len(k)
        return cache[k]


if __name__ == "__main__":
    print(get_or_load("alpha"))
    print(get_or_load("alpha"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第18章-aqs-可重入鎖實戰"><a class="header" href="#第18章-aqs-可重入鎖實戰">第18章 AQS 可重入鎖實戰</a></h1>
<h2 id="181-目標"><a class="header" href="#181-目標">18.1 目標</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-71"><a class="header" href="#本小節示意圖-71">本小節示意圖</a></h3>
<pre><code class="language-text">手寫鎖 vs OS Mutex 功能對比

  ┌──────────────────────┬──────────────────┬──────────────────────┐
  │       功能           │   手寫可重入鎖   │     OS Mutex         │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  互斥保護            │  ✓               │  ✓                   │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  可重入              │  ✓ 計數器追蹤    │  △ 依 OS/語言而定    │
  │  (同執行緒多次鎖)    │    state 欄位    │    pthread 預設不可  │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  可阻塞等待          │  ✓ park/unpark   │  ✓                   │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  可喚醒              │  ✓ unpark 精確   │  ✓                   │
  │                      │    喚醒指定執行緒│                      │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  可超時              │  ✓ 需自行實作    │  △ 部分 OS 支援      │
  │  (tryLock + timeout) │    計時邏輯      │    timedwait         │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  可中斷              │  ✓ 需自行實作    │  △ 依實作而定        │
  │  (interrupt 喚醒)    │    中斷標記      │                      │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  公平性控制          │  ✓ 可選公平/    │  ✗ 通常 OS 決定       │
  │                      │    非公平佇列    │                      │
  ├──────────────────────┼──────────────────┼──────────────────────┤
  │  自訂條件變數數量    │  ✓ 多個 Condition│  △ 有限              │
  └──────────────────────┴──────────────────┴──────────────────────┘

  目標：自己做出「可重入 + 可阻塞等待 + 可喚醒」的鎖，
        同時支援超時與中斷路徑。
</code></pre>
<p>自己做出「可重入 + 可阻塞等待 + 可喚醒」的鎖。</p>
<h2 id="182-狀態定義"><a class="header" href="#182-狀態定義">18.2 狀態定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-72"><a class="header" href="#本小節示意圖-72">本小節示意圖</a></h3>
<pre><code class="language-text">可重入鎖的三個核心欄位

  ┌───────────────────────────────────────────────────────────┐
  │                   ReentrantLock 結構                      │
   │                                                          │
  │  ┌────────────────────────────────────────────────────┐   │
  │  │  state: AtomicInt                                  │   │
    │  │                                                  │   │
  │  │   0    → 鎖空閒（free）                            │   │
  │  │   1    → 被持有一次                                │   │
  │  │   2    → 同一執行緒重入兩次                        │   │
  │  │   n    → 同一執行緒重入 n 次                       │   │
    │  │                                                  │   │
  │  │  作用：追蹤重入深度，state→0 才真正釋放鎖          │   │
  │  └────────────────────────────────────────────────────┘   │
   │                                                          │
  │  ┌────────────────────────────────────────────────────┐   │
  │  │  owner: Thread (nullable)                          │   │
    │  │                                                  │   │
  │  │   null     → 無人持有                              │   │
  │  │   Thread A → Thread A 持有                         │   │
    │  │                                                  │   │
  │  │  作用：判斷當前執行緒是否為持有者                  │   │
  │  │        若是 → state++（重入）                      │   │
  │  │        若否 → 進入等待佇列                         │   │
  │  └────────────────────────────────────────────────────┘   │
   │                                                          │
  │  ┌────────────────────────────────────────────────────┐   │
  │  │  waiters: Queue&lt;Thread&gt;                            │   │
    │  │                                                  │   │
  │  │   [Thread B] → [Thread C] → [Thread D] → null      │   │
    │  │                                                  │   │
  │  │  作用：FIFO 佇列儲存等待的執行緒                   │   │
  │  │        公平鎖：按入隊順序喚醒                      │   │
  │  │        非公平鎖：允許搶占                          │   │
  │  └────────────────────────────────────────────────────┘   │
  └───────────────────────────────────────────────────────────┘

  三個欄位的協作：

  owner=Thread A, state=2, waiters=[B, C]

  Thread A 再次 lock() → owner==A → state=3（重入）
  Thread B 呼叫 lock() → owner!=B → 入隊，park()
</code></pre>
<ul>
<li><code>state</code>: 重入次數</li>
<li><code>owner</code>: 持有者執行緒</li>
<li>queue: 等待節點</li>
</ul>
<h2 id="183-獲取與釋放對應-18311833"><a class="header" href="#183-獲取與釋放對應-18311833">18.3 獲取與釋放（對應 18.3.1~18.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-73"><a class="header" href="#本小節示意圖-73">本小節示意圖</a></h3>
<pre><code class="language-text">可重入鎖狀態機

  ┌──────────────────────────────────────────────────────────────────┐
  │  lock() 流程                                                     │
  └──────────────────────────────────────────────────────────────────┘

  Thread 呼叫 lock()
                                                                     │
         ▼
  ┌──────────────────┐   是    ┌─────────────────────────────────────┐
  │ owner == current │ ──────► │  state++（重入）      │──► 返回
  │ 執行緒？         │         │  state=1→2→3→...                    │
  └──────┬───────────┘         └─────────────────────────────────────┘
         │ 否
         ▼
  ┌──────────────────┐   是    ┌─────────────────────────────────────┐
  │  state == 0？    │ ──────► │  CAS(state, 0, 1)                   │
  │  鎖空閒？        │         │  owner = current      │──► 進入臨界區
  └──────┬───────────┘         └─────────────────────────────────────┘
         │ 否（鎖被他人持有）
         ▼
  ┌──────────────────────────────────────────────────────────────────┐
  │  入隊（enqueue）                                                 │
  │  park()睡眠等待  │◄──────────────────────────────────────────────┐
  └──────┬───────────────────────┘                                   │
         │ 被 unpark() 喚醒                                          │
         ▼                                                           │
  ┌──────────────────┐   失敗（被搶占）                              │
  │  retry: 重新嘗試 │ ─────────────────────────────────►            ┘
  │  CAS(0→1)                                                        │
  └──────────────────────────────────────────────────────────────────┘

  ┌──────────────────────────────────────────────────────────────────┐
  │  unlock() 流程                                                   │
  └──────────────────────────────────────────────────────────────────┘

  Thread 呼叫 unlock()
                                                                     │
         ▼
  ┌──────────────────────────────────────────────────────────────────┐
  │  assert owner == current（必須是持有者才能解鎖）                 │
  └──────────────────────────────────────────────────────────────────┘
                                                                     │
         ▼
         state--
                                                                     │
         ├─── state &gt; 0 ──► 仍有重入層，繼續持有鎖，返回
                                                                     │
         └─── state == 0 ──► 真正釋放
                                                                     │
                    ▼
             owner = null
                                                                     │
                    ▼
         ┌───────────────────────────────────────────────────────────┐
         │  waiters 佇列有人？                                       │
         └──────┬────────────────────────────────────────────────────┘
                │ 有              │ 無
                ▼                 ▼
         取出隊首 Thread        鎖空閒
         unpark() 喚醒          等待下次競爭

  重入計數示意：
  ┌──────────────────────────────────────────────────────────────────┐
  │  outer() {          inner() {                                    │
  │    lock()  state=1    lock()  state=2                            │
  │    inner()            ...                                        │
  │    unlock() state=1   unlock() state=1                           │
  │  }                  }                                            │
                  │                                                  │
  │  state: 1 ──► 2 ──► 1 ──► 0（真正釋放）                          │
  └──────────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>owner 再次進入：<code>state++</code></li>
<li>其他執行緒：排隊等待</li>
<li>釋放：<code>state--</code> 到 0 才真正解鎖</li>
</ul>
<h2 id="184-測試面向"><a class="header" href="#184-測試面向">18.4 測試面向</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-74"><a class="header" href="#本小節示意圖-74">本小節示意圖</a></h3>
<pre><code class="language-text">可重入鎖測試矩陣

  ┌─────────────────────┬────────────────────────┬─────────────────────────┐
  │     測試面向        │     測試方法            │     驗收標準           │
  ├─────────────────────┼────────────────────────┼─────────────────────────┤
  │  可重入正確性       │  同一執行緒連續 lock()  │  不死鎖                │
  │                     │  N 次後 unlock() N 次   │  state 歸零後其他執行  │
  │                     │  驗證臨界區資料一致性   │  緒可正常獲得鎖        │
  ├─────────────────────┼────────────────────────┼─────────────────────────┤
  │  競爭公平性         │  M 個執行緒並發競爭     │  每個執行緒等待時間    │
  │                     │  記錄各自獲鎖時間       │  差異在合理範圍內      │
  │                     │  計算標準差             │  （公平模式）          │
  ├─────────────────────┼────────────────────────┼─────────────────────────┤
  │  中斷路徑           │  執行緒等待鎖時         │  中斷後執行緒正確退出  │
  │                     │  從另一執行緒發送中斷   │  不留殭屍              │
  │                     │  驗證等待執行緒退出     │  鎖狀態保持一致        │
  ├─────────────────────┼────────────────────────┼─────────────────────────┤
  │  超時路徑           │  tryLock(timeout=100ms) │  超時後返回 false      │
  │                     │  持鎖者睡眠 200ms       │  不死鎖                │
  │                     │  等待者應超時返回       │  計時誤差 &lt; 10ms       │
  ├─────────────────────┼────────────────────────┼─────────────────────────┤
  │  多條件變數         │  producer/consumer 模型 │  signal 精確喚醒一個   │
  │                     │  condition.await()      │  signalAll 喚醒全部    │
  │                     │  condition.signal()     │  不丟失喚醒            │
  ├─────────────────────┼────────────────────────┼─────────────────────────┤
  │  壓力測試           │  1000 執行緒 × 10000    │  計數器最終值正確      │
  │                     │  次 lock/unlock         │  無資料競態            │
  │                     │  原子計數器累加         │  無死鎖                │
  └─────────────────────┴────────────────────────┴─────────────────────────┘

  測試覆蓋路徑圖：

  lock()
  ├─ owner == self ─► state++ ─► [可重入路徑] ✓
  ├─ state == 0    ─► CAS 成功 ─► [首次獲取路徑] ✓
  ├─ state == 0    ─► CAS 失敗 ─► retry ─► [競爭路徑] ✓
  ├─ state &gt; 0     ─► park() ─► unpark ─► [等待喚醒路徑] ✓
  ├─ state &gt; 0     ─► park() ─► interrupt ─► [中斷路徑] ✓
  └─ state &gt; 0     ─► tryLock + timeout ─► [超時路徑] ✓
</code></pre>
<ul>
<li>可重入正確性</li>
<li>競爭時公平性/吞吐</li>
<li>中斷與超時路徑</li>
</ul>
<h2 id="示意圖-12"><a class="header" href="#示意圖-12">示意圖</a></h2>
<pre><code class="language-text">owner=T1, state=2 (重入2次)
T1 unlock -&gt; state=1
T1 unlock -&gt; state=0 -&gt; 喚醒下一個
</code></pre>
<h2 id="跨語言完整範例-17"><a class="header" href="#跨語言完整範例-17">跨語言完整範例</a></h2>
<h3 id="c--pthread_mutex_t-遞迴鎖pthread_mutex_recursive"><a class="header" href="#c--pthread_mutex_t-遞迴鎖pthread_mutex_recursive">C — pthread_mutex_t 遞迴鎖（PTHREAD_MUTEX_RECURSIVE）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

static pthread_mutex_t mu;
static int shared_value = 0;

void inner_work(void) {
    pthread_mutex_lock(&amp;mu);      /* 重入：同執行緒第二次鎖 */
    shared_value += 10;
    printf("inner: shared_value = %d\n", shared_value);
    pthread_mutex_unlock(&amp;mu);
}

void outer_work(void) {
    pthread_mutex_lock(&amp;mu);      /* 第一次鎖 */
    shared_value += 1;
    printf("outer before inner: shared_value = %d\n", shared_value);
    inner_work();                 /* 呼叫 inner，不應死鎖 */
    printf("outer after inner: shared_value = %d\n", shared_value);
    pthread_mutex_unlock(&amp;mu);
}

int main(void) {
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&amp;attr);
    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&amp;mu, &amp;attr);
    pthread_mutexattr_destroy(&amp;attr);

    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, (void *(*)(void *))outer_work, NULL);
    pthread_create(&amp;t2, NULL, (void *(*)(void *))outer_work, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("最終 shared_value = %d (expected 22)\n", shared_value);
    pthread_mutex_destroy(&amp;mu);
    return 0;
}
</code></pre>
<h3 id="c--stdrecursive_mutex-可重入鎖"><a class="header" href="#c--stdrecursive_mutex-可重入鎖">C++ — std::recursive_mutex 可重入鎖</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

std::recursive_mutex rmu;
int shared_value = 0;

void inner_work() {
    std::lock_guard&lt;std::recursive_mutex&gt; lk(rmu);  /* 重入 */
    shared_value += 10;
    std::cout &lt;&lt; "inner: " &lt;&lt; shared_value &lt;&lt; "\n";
}

void outer_work() {
    std::lock_guard&lt;std::recursive_mutex&gt; lk(rmu);  /* 首次鎖 */
    shared_value += 1;
    inner_work();  /* 同執行緒再次鎖，不應死鎖 */
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++)
        threads.emplace_back(outer_work);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "最終 shared_value = " &lt;&lt; shared_value
              &lt;&lt; " (expected 44)\n";
}
</code></pre>
<h3 id="rust--parking_lotreentrantmutex-可重入鎖"><a class="header" href="#rust--parking_lotreentrantmutex-可重入鎖">Rust — parking_lot::ReentrantMutex 可重入鎖</a></h3>
<pre><pre class="playground"><code class="language-rust">use parking_lot::ReentrantMutex;
use std::cell::Cell;
use std::sync::Arc;
use std::thread;

fn inner_work(lock: &amp;ReentrantMutex&lt;Cell&lt;i32&gt;&gt;) {
    let guard = lock.lock();          /* 重入：同執行緒第二次 */
    guard.set(guard.get() + 10);
    println!("inner: {}", guard.get());
}

fn outer_work(lock: Arc&lt;ReentrantMutex&lt;Cell&lt;i32&gt;&gt;&gt;) {
    let guard = lock.lock();          /* 首次鎖 */
    guard.set(guard.get() + 1);
    drop(guard);                      /* Rust 需手動 drop 才能重入 */
    inner_work(&amp;lock);
}

fn main() {
    let lock = Arc::new(ReentrantMutex::new(Cell::new(0)));
    let mut handles = vec![];
    for _ in 0..4 {
        let l = Arc::clone(&amp;lock);
        handles.push(thread::spawn(move || outer_work(l)));
    }
    for h in handles { h.join().unwrap(); }
    println!("最終值 = {}", lock.lock().get());
}</code></pre></pre>
<h3 id="go--syncmutex--輔助函式go-無原生-recursive-mutex用呼叫鏈迴避"><a class="header" href="#go--syncmutex--輔助函式go-無原生-recursive-mutex用呼叫鏈迴避">Go — sync.Mutex + 輔助函式（Go 無原生 recursive mutex，用呼叫鏈迴避）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

// Go 的 sync.Mutex 不可重入，正確做法是把鎖傳遞給子函式
// 而非在子函式重複 Lock 同一把鎖
type ReentrantGuard struct {
    mu    sync.Mutex
    owner int64
    depth int
    once  sync.Mutex
}

var mu sync.Mutex
var sharedValue int

// outer 持鎖後直接呼叫 inner（不再重複鎖）
func inner(val *int) {
    *val += 10
    fmt.Printf("inner: shared_value = %d\n", *val)
}

func outer() {
    mu.Lock()
    defer mu.Unlock()
    sharedValue += 1
    inner(&amp;sharedValue) // inner 不重複 Lock，由 outer 持有鎖
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            outer()
        }()
    }
    wg.Wait()
    fmt.Printf("最終 shared_value = %d (expected 44)\n", sharedValue)
}
</code></pre>
<h3 id="python--threadingrlock-可重入鎖"><a class="header" href="#python--threadingrlock-可重入鎖">Python — threading.RLock 可重入鎖</a></h3>
<pre><code class="language-python">"""Chapter 18: reentrant lock — outer calls inner, both lock same RLock."""
import threading

rlock = threading.RLock()
shared_value = 0


def inner_work():
    with rlock:           # RLock 允許同執行緒第二次進入
        global shared_value
        shared_value += 10
        print(f"inner: shared_value = {shared_value}")


def outer_work():
    with rlock:           # 首次獲得鎖
        global shared_value
        shared_value += 1
        inner_work()      # 同執行緒再次 with rlock，不應死鎖


def main():
    threads = [threading.Thread(target=outer_work) for _ in range(4)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    print(f"最終 shared_value = {shared_value} (expected 44)")
    assert shared_value == 44, "RLock 可重入失敗！"
    print("通過：RLock 可重入，outer 呼叫 inner 不死鎖")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-17"><a class="header" href="#完整專案級範例python-17">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch18.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch18.py
</code></pre>
<pre><code class="language-python">"""Chapter 18: reentrant lock."""
import threading

r = threading.RLock()


def outer():
    with r:
        inner()


def inner():
    with r:
        print("reentered")


if __name__ == "__main__":
    outer()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第19章-分散式鎖架構"><a class="header" href="#第19章-分散式鎖架構">第19章 分散式鎖架構</a></h1>
<h2 id="191-為什麼需要分散式鎖"><a class="header" href="#191-為什麼需要分散式鎖">19.1 為什麼需要分散式鎖</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-75"><a class="header" href="#本小節示意圖-75">本小節示意圖</a></h3>
<pre><code class="language-text">單節點 vs 多節點鎖的邊界

  ─── 單節點（JVM Mutex 夠用）─────────────────────────────────

  ┌───────────────────────────────────────────────────────────┐
  │           App Instance                                    │
                       │                                      │
  │  Thread A ───────────────────────┐                        │
  │             ├─► [JVM Mutex] ─► DB                         │
  │  Thread B ───────────────────────┘                        │
  │   (等待)                                                  │
  └───────────────────────────────────────────────────────────┘
  ✓ 同一 JVM 內，mutex 可保護共享資源

  ─── 多節點（JVM Mutex 失效）────────────────────────────────

  ┌─────────────────────┐       ┌─────────────────────────────┐
  │   App Instance 1    │       │   App Instance 2            │
          │                     │       │                     │
  │  [JVM Lock A]       │       │  [JVM Lock B]               │
  │  ↑ 只保護本 JVM     │       │  ↑ 只保護本 JVM             │
  └──────────┬──────────┘       └──────────┬──────────────────┘
                                │                             │
             │ 都能同時存取                                   │
             ▼                             ▼
  ┌───────────────────────────────────────────────────────────┐
  │              共享資源：DB / Redis / 文件                  │
       │                                                      │
  │  Lock A 和 Lock B 互不可見 → 兩個實例同時操作 → 競態      │
  └───────────────────────────────────────────────────────────┘

  ✗ 跨 JVM / 跨進程 / 跨機器 → 需要分散式鎖

  ─── 分散式鎖解法 ────────────────────────────────────────────

  ┌─────────────────────┐       ┌─────────────────────────────┐
  │   App Instance 1    │       │   App Instance 2            │
  └──────────┬──────────┘       └──────────┬──────────────────┘
                                │                             │
             │ 先搶鎖                       │ 搶鎖失敗，等待
             ▼                             ▼
  ┌───────────────────────────────────────────────────────────┐
  │           Redis / ZooKeeper（分散式鎖服務）               │
       │                                                      │
  │   lock:order = "instance-1-uuid"  TTL=10s                 │
  └───────────────────────────────────────────────────────────┘
             │ 持有鎖
             ▼
  ┌───────────────────────────────────────────────────────────┐
  │                    共享資源：DB                           │
  └───────────────────────────────────────────────────────────┘
</code></pre>
<p>單機鎖只能管單進程，服務多副本時會失效。</p>
<h2 id="192-超賣案例對應-19211922"><a class="header" href="#192-超賣案例對應-19211922">19.2 超賣案例（對應 19.2.1~19.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-76"><a class="header" href="#本小節示意圖-76">本小節示意圖</a></h3>
<pre><code class="language-text">read-modify-write 競態導致超賣

  時間軸 ──────────────────────────────────────────────────────►
           T+0      T+1      T+2      T+3      T+4      T+5

  App1    [讀 stock]                  [扣減]   [寫 stock=0]
           stock=1                    stock=1-1=0

  App2              [讀 stock]                  [扣減]   [寫 stock=-1]
                     stock=1                    stock=1-1=0
                     ↑ 讀到舊值！                ↑ 再次扣減 → 超賣！

  ┌─────────────────────────────────────────────────────────────────┐
  │  問題根源：Read-Modify-Write 非原子                             │
         │                                                          │
  │  Step 1: stock = DB.read("stock_001")   → stock = 1             │
  │  Step 2: if stock &gt; 0: stock -= 1       → stock = 0             │
  │  Step 3: DB.write("stock_001", stock)   → stock = 0             │
         │                                                          │
  │  兩個 App 在 Step 1 和 Step 3 之間沒有互斥                      │
  │  → 都讀到 stock=1 → 都認為可以扣減 → stock 變 -1                │
  └─────────────────────────────────────────────────────────────────┘

  正確做法：加分散式鎖後

  App1    [取鎖 ✓][讀 stock=1][扣減][寫 stock=0][釋放鎖]
  App2    [等鎖─────────────────────────────][取鎖][讀 stock=0][售罄]

  結果：stock = 0（正確），不超賣
</code></pre>
<p>多節點同時扣庫存，若無跨節點互斥，庫存會變負數。</p>
<h2 id="193-jvm-本地鎖邊界對應-19311932"><a class="header" href="#193-jvm-本地鎖邊界對應-19311932">19.3 JVM 本地鎖邊界（對應 19.3.1~19.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-77"><a class="header" href="#本小節示意圖-77">本小節示意圖</a></h3>
<pre><code class="language-text">JVM 本地鎖的可見範圍邊界

  ┌───────────────────────────────────────────────────────────────┐
  │  機器 A                                                       │
  │  ┌─────────────────────────────────────────────────────────┐  │
  │  │  App Instance 1 (JVM)                                   │  │
   │  │                                                        │  │
  │  │  synchronized(lockObj) { ... }  ← JVM 鎖                │  │
  │  │  ┌───────────────────────────┐                          │  │
  │  │  │  Thread Pool              │                          │  │
  │  │  │  T1 ───┐                  │                          │  │
  │  │  │       ├─► [JVM Lock] ✓    │                          │  │
  │  │  │  T2 ───┘                  │                          │  │
  │  │  └───────────────────────────┘                          │  │
  │  └─────────────────────────────────────────────────────────┘  │
  └───────────────────────────────────────────────────────────────┘
                      │ JVM Lock 邊界到此為止
                      │ 鎖的狀態不會跨越這條線
  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
  網路                                                            │
  ┌────────────────────▼──────────────────────────────────────────┐
  │  機器 B                                                       │
  │  ┌─────────────────────────────────────────────────────────┐  │
  │  │  App Instance 2 (JVM)                                   │  │
   │  │                                                        │  │
  │  │  synchronized(lockObj) { ... }  ← 完全獨立的 JVM 鎖     │  │
  │  │  ↑ 和機器A的鎖物件不同，互不可見                        │  │
  │  └─────────────────────────────────────────────────────────┘  │
  └───────────────────────────────────────────────────────────────┘
                                                                  │
                      ▼
  ┌───────────────────────────────────────────────────────────────┐
  │  共享資源：MySQL / Redis                                      │
  │  兩個 App 可以同時操作 → 競態！                               │
  └───────────────────────────────────────────────────────────────┘

  結論：synchronized 只在同 JVM 內有效，
        水平擴展後必須用外部分散式鎖。
</code></pre>
<p><code>synchronized</code> 只在同 JVM 內有效。</p>
<h2 id="194-分散式鎖要求對應-19411942"><a class="header" href="#194-分散式鎖要求對應-19411942">19.4 分散式鎖要求（對應 19.4.1~19.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-78"><a class="header" href="#本小節示意圖-78">本小節示意圖</a></h3>
<pre><code class="language-text">分散式鎖五大需求與實現挑戰

  ┌───────────────────────────────────────────────────────────────┐
  │  需求 1：互斥性（Mutual Exclusion）                           │
  │  同一時刻只有一個客戶端持有鎖                                 │
  │  實現：Redis SET NX（Not Exist）原子指令                      │
  │  挑戰：網路分區時可能出現兩個持有者                           │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  需求 2：不死鎖（No Deadlock）                                │
  │  持鎖客戶端崩潰後，鎖必須自動釋放                             │
  │  實現：TTL 自動過期（SET NX PX 10000）                        │
  │  挑戰：TTL 設定多長？太短 → 任務未完鎖已過期                  │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  需求 3：可重入（Reentrancy）                                 │
  │  同一客戶端可多次獲取同一把鎖                                 │
  │  實現：鎖值包含 clientID，每次重入計數                        │
  │  挑戰：需要 Lua 腳本保證 check-increment 原子性               │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  需求 4：高可用（High Availability）                          │
  │  鎖服務本身不能是單點                                         │
  │  實現：Redis Sentinel / Cluster；ZooKeeper Quorum             │
  │  挑戰：主從切換窗口期可能導致鎖丟失                           │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  需求 5：可續租（Watchdog / Lease Renewal）                   │
  │  任務執行時間超過 TTL 時，自動延長鎖的生命週期                │
  │  實現：後台執行緒定期 EXPIRE key new_ttl                      │
  │  挑戰：續租執行緒本身崩潰 → 鎖不再續租 → 自然過期             │
  └───────────────────────────────────────────────────────────────┘

  各需求依賴關係：
  互斥 ──► NX 指令
  不死鎖 ──► TTL
  誤刪保護 ──► UUID value
  可重入 ──► Lua 原子 check-increment
  可續租 ──► Watchdog 執行緒
</code></pre>
<ul>
<li>互斥</li>
<li>可釋放（不死鎖）</li>
<li>故障可恢復</li>
<li>最好可重入/可續租</li>
</ul>
<h2 id="195-apcp-取捨對應-19511954"><a class="header" href="#195-apcp-取捨對應-19511954">19.5 AP/CP 取捨（對應 19.5.1~19.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-79"><a class="header" href="#本小節示意圖-79">本小節示意圖</a></h3>
<pre><code class="language-text">CAP 定理與分散式鎖選型

           一致性 (C)
              ▲
                                                             │
              │   CP 區域
              │   ZooKeeper ●
              │   etcd      ●
                                                             │
                                                             │
  ────────────┼────────────────────► 可用性 (A)
                                                             │
              │   AP 區域
              │              ● Redis (主從)
              │              ● Redis Cluster
                                                             │
  (P = 分區容忍，實際分散式系統必須接受 P)

  ─── Redis (偏 AP) ──────────────────────────────────────────

  優點：
  ・極高吞吐（單機 10萬+ QPS）
  ・低延遲（sub-millisecond）
  ・部署簡單

  弱點：
  ・主從複製非同步 → 主節點掛掉切換期間，新主可能無鎖記錄
  ・Cluster 模式 → SET NX 無法跨 slot 原子操作
  ・Redlock 演算法有爭議（時鐘漂移問題）

  適用：電商庫存、快取更新、冪等控制等容忍極短暫鎖丟失的場景

  ─── ZooKeeper (偏 CP) ──────────────────────────────────────

  優點：
  ・強一致性（Zab 協議 Quorum 提交）
  ・臨時節點 + Watcher 天然支援鎖失效通知
  ・公平鎖（順序節點）

  弱點：
  ・寫入延遲高（需要多數節點確認）
  ・單機 QPS 約 1 萬（vs Redis 10 萬+）
  ・ZooKeeper 本身是有狀態的複雜系統

  適用：金融交易、配置管理、Leader 選舉等強一致性要求的場景

  ┌──────────────────────────────────────────────────────────┐
  │  選型建議：                                              │
  │  ・高吞吐 + 可接受極短暫不一致 → Redis                   │
  │  ・強一致 + 低吞吐可接受     → ZooKeeper / etcd          │
  └──────────────────────────────────────────────────────────┘
</code></pre>
<p>Redis 常偏 AP；ZooKeeper 常偏 CP。</p>
<h2 id="196-redis-鎖演進對應-196119612"><a class="header" href="#196-redis-鎖演進對應-196119612">19.6 Redis 鎖演進（對應 19.6.1~19.6.12）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-80"><a class="header" href="#本小節示意圖-80">本小節示意圖</a></h3>
<pre><code class="language-text">Redis 分散式鎖四代演進

  ─────────────────────────────────────────────────────────────
  V1：SET NX（最簡版）
  ─────────────────────────────────────────────────────────────

  SET lock_key 1 NX
                                                              │
       ▼
  ✓ 獲得鎖
  DEL lock_key  ← 崩潰時沒執行 → 鎖永久存在 → 死鎖！

  問題：無 TTL，崩潰後永不釋放

  ─────────────────────────────────────────────────────────────
  V2：SET NX PX ttl（加 TTL）
  ─────────────────────────────────────────────────────────────

  SET lock_key 1 NX PX 10000
                                                              │
       ▼
  ✓ 獲得鎖（10秒後自動過期）
  DEL lock_key  ← 若任務執行時間 &gt; 10s，鎖已被其他人拿走
                  此時 DEL 刪掉別人的鎖！→ 誤刪！

  問題：鎖的 value 沒有身份，誰都可以刪

  ─────────────────────────────────────────────────────────────
  V3：SET NX PX + Lua 原子 check-delete（加身份驗證）
  ─────────────────────────────────────────────────────────────

  SET lock_key {uuid} NX PX 10000
                                                              │
       ▼
  ✓ 獲得鎖
  解鎖時執行 Lua 腳本（原子）：
  ┌───────────────────────────────────────────────────────────┐
  │  if redis.call('GET', key) == uuid then                   │
  │      return redis.call('DEL', key)                        │
  │  else                                                     │
  │      return 0  -- 不是我的鎖，不刪                        │
  │  end                                                      │
  └───────────────────────────────────────────────────────────┘

  問題：任務執行超過 TTL → 鎖過期 → 他人取鎖 → 兩個持有者！

  ─────────────────────────────────────────────────────────────
  V4：Lua + Watchdog 續租（完整版）
  ─────────────────────────────────────────────────────────────

  ┌───────────────────────────────────────────────────────────┐
   │                                                          │
  │  主執行緒                   Watchdog 執行緒               │
  │  ──────────────────────     ────────────────────────      │
  │  SET lock {uuid} NX PX 30s                                │
  │  開始執行業務邏輯 ─────────► 每 10s 執行：                │
  │                             EXPIRE lock 30s (續租)        │
  │  業務完成                   ↑ 確保鎖不過期                │
  │  Lua check-delete ─────────► Watchdog 停止                │
   │                                                          │
  │  若主執行緒崩潰：                                         │
  │  Watchdog 也停止 → 鎖 TTL 自然倒數 → 30s 後自動釋放       │
  └───────────────────────────────────────────────────────────┘

  演進總結：
  ┌──────┬──────────────────┬─────────────────────────────────┐
  │  版本 │  解決的問題       │  引入的問題                   │
  ├──────┼──────────────────┼─────────────────────────────────┤
  │  V1  │  互斥            │  崩潰 → 死鎖                    │
  │  V2  │  死鎖（TTL）      │  誤刪他人的鎖                  │
  │  V3  │  誤刪（UUID+Lua） │  任務超時鎖過期                │
  │  V4  │  超時（Watchdog） │  Watchdog 複雜度增加           │
  └──────┴──────────────────┴─────────────────────────────────┘
</code></pre>
<ol>
<li><code>SET key val NX PX ttl</code></li>
<li><code>finally</code> 解鎖</li>
<li>用 Lua 比對 value 再刪（防誤刪）</li>
<li>看門狗續租（避免任務未完鎖先過期）</li>
</ol>
<pre><code class="language-text">ClientA set lock=uuidA ttl=10s
ClientB 不能覆蓋
unlock 必須檢查 value==uuidA
</code></pre>
<h2 id="示意圖-13"><a class="header" href="#示意圖-13">示意圖</a></h2>
<pre><code class="language-text">App1 --SET NX PX--&gt; Redis(lock:order)
App2 --SET NX PX--&gt; fail (已被占用)
App1 --Lua check value then del--&gt; unlock
</code></pre>
<h2 id="跨語言完整範例-18"><a class="header" href="#跨語言完整範例-18">跨語言完整範例</a></h2>
<h3 id="c--mockredis-模擬-set-nx-px--lua-check-delete"><a class="header" href="#c--mockredis-模擬-set-nx-px--lua-check-delete">C — MockRedis 模擬 SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;pthread.h&gt;

#define KEY_MAX 64
#define VAL_MAX 64

typedef struct {
    char key[KEY_MAX];
    char val[VAL_MAX];
    long expire_ms;        /* UNIX 毫秒時間戳，0 表示無記錄 */
    int  used;
} RedisEntry;

#define STORE_SIZE 16
static RedisEntry store[STORE_SIZE];
static pthread_mutex_t store_mu = PTHREAD_MUTEX_INITIALIZER;

static long now_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &amp;ts);
    return ts.tv_sec * 1000L + ts.tv_nsec / 1000000L;
}

/* SET key val NX PX ttl → 1: 成功, 0: 已存在 */
int redis_set_nx_px(const char *key, const char *val, int ttl_ms) {
    pthread_mutex_lock(&amp;store_mu);
    long now = now_ms();
    int slot = -1;
    for (int i = 0; i &lt; STORE_SIZE; i++) {
        if (store[i].used &amp;&amp; strcmp(store[i].key, key) == 0) {
            if (store[i].expire_ms &gt; now) { /* 鎖仍有效 */
                pthread_mutex_unlock(&amp;store_mu);
                return 0;
            }
            slot = i;  /* 已過期，可覆蓋 */
            break;
        }
        if (!store[i].used &amp;&amp; slot == -1) slot = i;
    }
    if (slot == -1) { pthread_mutex_unlock(&amp;store_mu); return 0; }
    strncpy(store[slot].key, key, KEY_MAX - 1);
    strncpy(store[slot].val, val, VAL_MAX - 1);
    store[slot].expire_ms = now + ttl_ms;
    store[slot].used = 1;
    pthread_mutex_unlock(&amp;store_mu);
    return 1;
}

/* Lua: if GET(key)==val then DEL(key) end → 1: 刪成功, 0: 不是自己的鎖 */
int redis_lua_unlock(const char *key, const char *val) {
    pthread_mutex_lock(&amp;store_mu);
    for (int i = 0; i &lt; STORE_SIZE; i++) {
        if (store[i].used &amp;&amp; strcmp(store[i].key, key) == 0) {
            if (strcmp(store[i].val, val) == 0) {
                store[i].used = 0;
                pthread_mutex_unlock(&amp;store_mu);
                return 1;
            }
            break;
        }
    }
    pthread_mutex_unlock(&amp;store_mu);
    return 0;
}

int main(void) {
    const char *key = "lock:order";
    const char *uuid_a = "client-A-uuid";
    const char *uuid_b = "client-B-uuid";

    int ok = redis_set_nx_px(key, uuid_a, 10000);
    printf("Client A 加鎖: %s\n", ok ? "成功" : "失敗");

    ok = redis_set_nx_px(key, uuid_b, 10000);
    printf("Client B 加鎖: %s (應為失敗)\n", ok ? "成功" : "失敗");

    /* Client B 嘗試刪 Client A 的鎖 → 應失敗 */
    ok = redis_lua_unlock(key, uuid_b);
    printf("Client B 解鎖: %s (應為失敗)\n", ok ? "成功" : "失敗");

    ok = redis_lua_unlock(key, uuid_a);
    printf("Client A 解鎖: %s (應為成功)\n", ok ? "成功" : "失敗");

    ok = redis_set_nx_px(key, uuid_b, 10000);
    printf("Client B 再次加鎖: %s (應為成功)\n", ok ? "成功" : "失敗");
    return 0;
}
</code></pre>
<h3 id="c--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#c--mockredis-set-nx-px--lua-check-delete">C++ — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;

class MockRedis {
    struct Entry { std::string val; long long expire_ms; };
    std::unordered_map&lt;std::string, Entry&gt; store_;
    std::mutex mu_;

    long long now_ms() {
        using namespace std::chrono;
        return duration_cast&lt;milliseconds&gt;(
            steady_clock::now().time_since_epoch()).count();
    }
public:
    bool set_nx_px(const std::string &amp;key, const std::string &amp;val, int ttl_ms) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        auto it = store_.find(key);
        if (it != store_.end() &amp;&amp; it-&gt;second.expire_ms &gt; now_ms())
            return false;
        store_[key] = {val, now_ms() + ttl_ms};
        return true;
    }
    bool lua_unlock(const std::string &amp;key, const std::string &amp;val) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        auto it = store_.find(key);
        if (it != store_.end() &amp;&amp; it-&gt;second.val == val) {
            store_.erase(it);
            return true;
        }
        return false;
    }
};

int main() {
    MockRedis redis;
    std::string key = "lock:order";
    std::string uuid_a = "client-A-uuid";
    std::string uuid_b = "client-B-uuid";

    std::cout &lt;&lt; "A 加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_a, 10000) &lt;&lt; "\n";
    std::cout &lt;&lt; "B 加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_b, 10000)
              &lt;&lt; " (應為0)\n";
    std::cout &lt;&lt; "B 解鎖: " &lt;&lt; redis.lua_unlock(key, uuid_b)
              &lt;&lt; " (應為0，誤刪保護生效)\n";
    std::cout &lt;&lt; "A 解鎖: " &lt;&lt; redis.lua_unlock(key, uuid_a) &lt;&lt; "\n";
    std::cout &lt;&lt; "B 再加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_b, 10000) &lt;&lt; "\n";
}
</code></pre>
<h3 id="rust--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#rust--mockredis-set-nx-px--lua-check-delete">Rust — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

struct MockRedis {
    store: Mutex&lt;HashMap&lt;String, (String, Instant)&gt;&gt;,
}

impl MockRedis {
    fn new() -&gt; Self {
        MockRedis { store: Mutex::new(HashMap::new()) }
    }
    fn set_nx_px(&amp;self, key: &amp;str, val: &amp;str, ttl_ms: u64) -&gt; bool {
        let mut store = self.store.lock().unwrap();
        if let Some((_, exp)) = store.get(key) {
            if exp.elapsed() &lt; Duration::from_millis(0) {
                return false; // still valid
            }
        }
        let entry = store.entry(key.to_string()).or_insert_with(|| {
            (String::new(), Instant::now())
        });
        if entry.1.elapsed().as_millis() == 0 &amp;&amp; !entry.0.is_empty() {
            return false;
        }
        *entry = (val.to_string(), Instant::now() + Duration::from_millis(ttl_ms));
        true
    }
    fn lua_unlock(&amp;self, key: &amp;str, val: &amp;str) -&gt; bool {
        let mut store = self.store.lock().unwrap();
        if let Some((v, _)) = store.get(key) {
            if v == val {
                store.remove(key);
                return true;
            }
        }
        false
    }
}

fn main() {
    let redis = Arc::new(MockRedis::new());
    println!("A 加鎖: {}", redis.set_nx_px("lock:order", "uuid-a", 10000));
    println!("B 加鎖: {} (應為false)", redis.set_nx_px("lock:order", "uuid-b", 10000));
    println!("B 解鎖: {} (應為false，誤刪保護)", redis.lua_unlock("lock:order", "uuid-b"));
    println!("A 解鎖: {}", redis.lua_unlock("lock:order", "uuid-a"));
    println!("B 再加鎖: {}", redis.set_nx_px("lock:order", "uuid-b", 10000));
}</code></pre></pre>
<h3 id="go--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#go--mockredis-set-nx-px--lua-check-delete">Go — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type entry struct {
    val    string
    expiry time.Time
}

type MockRedis struct {
    mu    sync.Mutex
    store map[string]entry
}

func NewMockRedis() *MockRedis {
    return &amp;MockRedis{store: make(map[string]entry)}
}

func (r *MockRedis) SetNXPX(key, val string, ttl time.Duration) bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    if e, ok := r.store[key]; ok &amp;&amp; time.Now().Before(e.expiry) {
        return false
    }
    r.store[key] = entry{val, time.Now().Add(ttl)}
    return true
}

// LuaUnlock 模擬原子 check-delete
func (r *MockRedis) LuaUnlock(key, val string) bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    if e, ok := r.store[key]; ok &amp;&amp; e.val == val {
        delete(r.store, key)
        return true
    }
    return false
}

func main() {
    redis := NewMockRedis()
    ttl := 10 * time.Second
    fmt.Println("A 加鎖:", redis.SetNXPX("lock:order", "uuid-a", ttl))
    fmt.Println("B 加鎖:", redis.SetNXPX("lock:order", "uuid-b", ttl), "(應為false)")
    fmt.Println("B 解鎖:", redis.LuaUnlock("lock:order", "uuid-b"), "(應為false，誤刪保護)")
    fmt.Println("A 解鎖:", redis.LuaUnlock("lock:order", "uuid-a"))
    fmt.Println("B 再加鎖:", redis.SetNXPX("lock:order", "uuid-b", ttl))
}
</code></pre>
<h3 id="python--mockredis-set-nx-px--lua-check-delete多執行緒驗證"><a class="header" href="#python--mockredis-set-nx-px--lua-check-delete多執行緒驗證">Python — MockRedis SET NX PX + Lua check-delete（多執行緒驗證）</a></h3>
<pre><code class="language-python">"""Chapter 19: distributed lock protocol — MockRedis NX PX + Lua check-delete."""
import threading
import time
import uuid


class MockRedis:
    """模擬 Redis SET NX PX 與 Lua 原子解鎖。"""

    def __init__(self):
        self._store = {}          # key → (value, expire_time)
        self._mu = threading.Lock()

    def set_nx_px(self, key: str, val: str, ttl_ms: int) -&gt; bool:
        """SET key val NX PX ttl → True: 成功取鎖"""
        deadline = time.monotonic() + ttl_ms / 1000
        with self._mu:
            cur = self._store.get(key)
            if cur and cur[1] &gt; time.monotonic():
                return False       # 鎖仍有效，NX 失敗
            self._store[key] = (val, deadline)
            return True

    def lua_unlock(self, key: str, val: str) -&gt; bool:
        """原子 check-and-delete：只有 value 匹配才刪除"""
        with self._mu:
            cur = self._store.get(key)
            if cur and cur[0] == val:
                del self._store[key]
                return True
            return False           # 不是自己的鎖，拒絕刪除


def acquire_and_work(redis: MockRedis, client_id: str, results: list):
    lock_key = "lock:order"
    token = f"{client_id}:{uuid.uuid4()}"
    ok = redis.set_nx_px(lock_key, token, 3000)
    results.append((client_id, "acquired" if ok else "failed"))
    if ok:
        time.sleep(0.05)          # 模擬業務處理
        released = redis.lua_unlock(lock_key, token)
        results.append((client_id, "released" if released else "release_failed"))


def main():
    redis = MockRedis()

    # 基本流程測試
    uuid_a = "client-A"
    ok = redis.set_nx_px("lock:order", uuid_a, 5000)
    print(f"A 加鎖: {ok}")                          # True
    ok = redis.set_nx_px("lock:order", "client-B", 5000)
    print(f"B 加鎖: {ok} (應為 False)")             # False
    ok = redis.lua_unlock("lock:order", "client-B")
    print(f"B 解鎖: {ok} (應為 False，誤刪保護)")   # False
    ok = redis.lua_unlock("lock:order", uuid_a)
    print(f"A 解鎖: {ok}")                          # True

    # 並發競爭測試
    print("\n並發競爭測試（10 客戶端搶同一把鎖）：")
    results = []
    threads = [
        threading.Thread(target=acquire_and_work,
                         args=(redis, f"client-{i}", results))
        for i in range(10)
    ]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    acquired = [r for r in results if r[1] == "acquired"]
    print(f"成功取鎖數量: {len(acquired)} (應為 1，互斥保證)")
    assert len(acquired) == 1, "互斥性失敗！"
    print("通過：分散式鎖互斥性正確")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-18"><a class="header" href="#完整專案級範例python-18">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch19.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch19.py
</code></pre>
<pre><code class="language-python">"""Chapter 19: distributed lock protocol (mocked redis)."""
import time


class MockRedis:
    def __init__(self):
        self.store = {}

    def set_nx_px(self, key: str, val: str, ttl_ms: int) -&gt; bool:
        now = time.time() * 1000
        cur = self.store.get(key)
        if cur and cur[1] &gt; now:
            return False
        self.store[key] = (val, now + ttl_ms)
        return True

    def unlock_if_value(self, key: str, val: str) -&gt; bool:
        cur = self.store.get(key)
        if cur and cur[0] == val:
            del self.store[key]
            return True
        return False


if __name__ == "__main__":
    r = MockRedis()
    owner = "uuid-a"
    ok = r.set_nx_px("lock:order", owner, 3000)
    print("lock acquired", ok)
    print("unlock", r.unlock_if_value("lock:order", owner))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第20章-秒殺系統架構"><a class="header" href="#第20章-秒殺系統架構">第20章 秒殺系統架構</a></h1>
<h2 id="201-電商基礎架構"><a class="header" href="#201-電商基礎架構">20.1 電商基礎架構</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-81"><a class="header" href="#本小節示意圖-81">本小節示意圖</a></h3>
<pre><code class="language-text">電商系統分層架構

  使用者請求
                                                           │
       ▼
  ┌────────────────────────────────────────────────────────┐
  │  接入層                                                │
  │  ┌──────────────┐    ┌───────────────┐                 │
  │  │     CDN      │    │    Nginx      │                 │
  │  │  靜態資源    │    │  反向代理     │                 │
  │  │  快取        │    │  負載均衡     │                 │
  │  └──────────────┘    └───────────────┘                 │
  └────────────────────────────┬───────────────────────────┘
                               │ 動態請求
                               ▼
  ┌────────────────────────────────────────────────────────┐
  │  閘道層                                                │
  │  ┌──────────────┐    ┌───────────────┐                 │
  │  │  限流        │    │  認證/鑑權    │                 │
  │  │  Token Bucket│    │  JWT / Session │                │
  │  └──────────────┘    └───────────────┘                 │
  └────────────────────────────┬───────────────────────────┘
                                                           │
                               ▼
  ┌────────────────────────────────────────────────────────┐
  │  業務層                                                │
  │  ┌──────────────────┐  ┌───────────────────┐           │
  │  │    訂單服務      │  │    庫存服務       │           │
  │  │  OrderService    │  │  StockService     │           │
  │  │  防重 / 支付     │  │  扣減 / 補償      │           │
  │  └────────┬─────────┘  └────────┬──────────┘           │
  └───────────┼─────────────────────┼──────────────────────┘
                                     │                     │
              ▼                     ▼
  ┌────────────────────────────────────────────────────────┐
  │  快取層                                                │
  │  ┌───────────────────────────────────────┐             │
  │  │  Redis Cluster                        │             │
  │  │  ・庫存計數（stock:sku:001 = 1000）   │             │
  │  │  ・防重 Token（setnx order:uid）      │             │
  │  │  ・限流計數器                         │             │
  │  └───────────────────────────────────────┘             │
  └────────────────────────────┬───────────────────────────┘
                               │ 讀未命中 / 最終持久化
                               ▼
  ┌────────────────────────────────────────────────────────┐
  │  資料層                                                │
  │  ┌───────────────────────────────────────┐             │
  │  │  MySQL（主從分離）                    │             │
  │  │  ・訂單表 / 庫存表                    │             │
  │  │  ・對賬記錄                           │             │
  │  └───────────────────────────────────────┘             │
  └────────────────────────────────────────────────────────┘
              │                     ↑
              ▼                     │ Consumer 消費
  ┌────────────────────────────────────────────────────────┐
  │  異步層                                                │
  │  ┌──────────────────┐  ┌───────────────────┐           │
  │  │  MQ（Kafka/RMQ） │  │  Consumer Worker  │           │
  │  │  削峰平滑流量     │  │  非同步落庫      │           │
  │  └──────────────────┘  └───────────────────┘           │
  └────────────────────────────────────────────────────────┘
</code></pre>
<p>入口層、業務層、資料層、異步層缺一不可。</p>
<h2 id="202-秒殺特性對應-20212022"><a class="header" href="#202-秒殺特性對應-20212022">20.2 秒殺特性（對應 20.2.1~20.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-82"><a class="header" href="#本小節示意圖-82">本小節示意圖</a></h3>
<pre><code class="language-text">正常流量 vs 秒殺瞬間流量對比

  QPS
  (萬)
  100 │         ▐█▌
      │         ███
      │         ███
   50 │         ███
      │         ███
      │         ███
   10 │─────────███──────────────────────────────────── 正常基線
    1 │         ███████████████████████
      │         ████████████████████████████
    0 └─────────┼──────────────────────────────────────► 時間
              秒殺   ←── 持續約 5 分鐘 ───►  流量回落
              開始
              T0

  ┌────────────────────────────────────────────────────────────┐
  │  秒殺瞬間特性：                                            │
     │                                                         │
  │  ・流量是平時的 100x（10萬 QPS vs 正常 1000 QPS）          │
  │  ・熱點 key：少數 SKU 被高頻存取（Redis 熱點問題）         │
  │  ・超賣風險：多節點並發扣減同一庫存                        │
  │  ・重複下單：用戶多次點擊「搶購」按鈕                      │
  │  ・容錯窗口極短：5 分鐘內必須解決，無法慢慢修              │
  └────────────────────────────────────────────────────────────┘

  關鍵挑戰：
  ┌─────────────────┬──────────────────────────────────────────┐
  │  問題            │  應對策略                               │
  ├─────────────────┼──────────────────────────────────────────┤
  │  熱點 key        │  庫存分段（多個 Redis key 分散）        │
  │  超賣            │  Lua 原子扣減 + 回滾                    │
  │  重複下單        │  SETNX 冪等 Token                       │
  │  DB 打爆         │  異步 MQ 削峰                           │
  └─────────────────┴──────────────────────────────────────────┘
</code></pre>
<p>高峰值、瞬時流量、熱點資料、低容錯窗口。</p>
<h2 id="203-活動前中後對應-20312032"><a class="header" href="#203-活動前中後對應-20312032">20.3 活動前中後（對應 20.3.1~20.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-83"><a class="header" href="#本小節示意圖-83">本小節示意圖</a></h3>
<pre><code class="language-text">秒殺活動生命週期時間軸

  ─── 活動前（T0 之前）───────────────────────────────────────

  T-24h    T-1h      T-10min   T0（秒殺開始）
                             │         │           │         │
    ▼         ▼           ▼         ▼
  [庫存    [壓測       [暖機      [流量
   資料     模擬        Redis      湧入]
   預熱]    100x        庫存]
            流量]                ← 必須在 T0 前完成所有準備

  預熱快取：
  ・提前 SET stock:sku:001 1000（庫存寫入 Redis）
  ・提前載入商品詳情到快取（避免秒殺時打 DB）

  壓測：
  ・使用 wrk/JMeter 模擬 10萬 QPS
  ・確認系統瓶頸、調整連線池/執行緒池

  擴容：
  ・水平擴展應用層（K8s 預先 scale out）
  ・Redis 記憶體確認充裕

  ─── 秒殺進行中（T0 ~ T0+5min）──────────────────────────────

  T0              T0+1min         T0+5min
                          │                 │                │
   ▼                 ▼                ▼
  [限流閘道]      [庫存售罄]      [流量回落]
  [MQ 緩衝]       [標記售罄標誌]  [等待 MQ 消化]
  [降級靜態頁]     [拒絕後續請求]

  ─── 活動後（T0+5min 之後）─────────────────────────────────

  T0+5min      T0+1h         T0+24h
                                │            │               │
      ▼            ▼               ▼
  [Consumer   [對賬：         [縮容：
   消化 MQ]    Redis庫存      釋放多餘
  [落庫訂單]   vs DB庫存]    應用實例]
               [補償異常單]
</code></pre>
<ul>
<li>前：預熱快取、壓測、擴容</li>
<li>中：限流、降級、削峰</li>
<li>後：對賬、補償、回放</li>
</ul>
<h2 id="204-同步與異步下單對應-20412042"><a class="header" href="#204-同步與異步下單對應-20412042">20.4 同步與異步下單（對應 20.4.1~20.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-84"><a class="header" href="#本小節示意圖-84">本小節示意圖</a></h3>
<pre><code class="language-text">同步下單 vs 異步下單對比

  ─── 同步下單（直接寫 DB）───────────────────────────────────

  User ──► API Server ──► MySQL DB
                                                 │             │
                │             │ 每次請求直接寫 DB
                │◄────────────┘ 響應 200ms~2s
                                                               │
  問題：
  ・10 萬 QPS → DB 無法承受（通常 MySQL 上限 1000~5000 QPS）
  ・響應時間長 → 連線池耗盡 → 雪崩

  時間軸：
  Req1 ──► [API] ──────[DB寫]──► 回應
  Req2 ──► [API] ──────[DB寫]──► 回應
  ...
  Req1000 ──► [API] ──► DB 超載！逾時！

  ─── 異步下單（MQ 削峰）──────────────────────────────────────

  User ──► API Server ──► MQ (Kafka) ──► Consumer ──► MySQL DB
                                │              │               │
                │              │ 毫秒級入隊    │ 按 DB 速率消費
                │◄─────────────┘               │ （平滑寫入）
                │ 立即返回「搶購成功，訂單處理中」

  時間軸：
  T=0:   User 請求 API → 入 MQ → 立即返回（&lt; 10ms）
  T=1s:  Consumer 消費 MQ → 寫 DB（每秒 5000 條）
  T=20s: 所有訂單落庫完成

  ┌────────────────────────────────────────────────────────────┐
  │  比較                                                      │
  │  ┌──────────────┬────────────────┬──────────────────────┐  │
  │  │              │  同步下單       │  異步下單           │  │
  │  ├──────────────┼────────────────┼──────────────────────┤  │
  │  │  響應時間    │  200ms~2s      │  &lt; 10ms              │  │
  │  │  DB 峰值壓力 │  = 用戶 QPS    │  Consumer 速率控制   │  │
  │  │  用戶體驗    │  等待結果      │  樂觀返回+通知       │  │
  │  │  複雜度      │  低            │  高（需 MQ+補償）    │  │
  │  └──────────────┴────────────────┴──────────────────────┘  │
  └────────────────────────────────────────────────────────────┘
</code></pre>
<p>同步直寫簡單但容易打爆；異步用 MQ 平滑流量。</p>
<h2 id="205-扣庫存策略對應-20512055"><a class="header" href="#205-扣庫存策略對應-20512055">20.5 扣庫存策略（對應 20.5.1~20.5.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-85"><a class="header" href="#本小節示意圖-85">本小節示意圖</a></h3>
<pre><code class="language-text">三種扣庫存時機比較

  ─── 策略一：下單時扣庫存 ──────────────────────────────────

  用戶下單 ─► 扣減 stock ─► 建立訂單 ─► 等待支付 ─► 支付完成
                                                                 │
                └► 若超時未支付 → 需要定時任務歸還庫存

  優點：超賣風險低（下單即鎖定）
  缺點：惡意用戶可佔庫存不付款；持鎖時間長

  ─── 策略二：付款時扣庫存 ──────────────────────────────────

  用戶下單 ─► 建立訂單(不扣庫存) ─► 支付完成 ─► 扣減 stock
                                                                 │
                                                   └► 可能已無庫存
                                                      → 超賣！

  優點：庫存利用率高
  缺點：超賣風險高（多人下單 → 同時支付 → 最後才扣庫存）

  ─── 策略三：預扣 + 支付確認（最安全）────────────────────

  用戶下單
                                                                 │
       ▼
  Redis 預扣：DECR stock:sku:001
                                                                 │
       ├── 成功（&gt;= 0）─► 建立預訂單（鎖定庫存）
                                             │                   │
       │                   ▼
       │             用戶支付
                                             │                   │
       │             ┌─────┴─────────────────────────────────────┐
                                      │             │            │
       │          支付成功      支付失敗/超時
                                      │             │            │
       │          DB 落庫      補償：INCR stock 歸還
                                                                 │
       └── 失敗（&lt; 0）─► INCR 回滾 ─► 返回售罄

  ┌──────────────────────────────────────────────────────────────┐
  │  策略對比                                                    │
  │  ┌──────────┬──────────┬──────────┬───────────────────────┐  │
  │  │  策略    │  超賣風險 │  持鎖時間 │  補償複雜度         │  │
  │  ├──────────┼──────────┼──────────┼───────────────────────┤  │
  │  │  下單扣  │  低       │  長       │  定時任務歸還       │  │
  │  │  付款扣  │  高       │  短       │  超賣後補           │  │
  │  │  預扣+確認│ 極低     │  中       │  INCR 補償          │  │
  │  └──────────┴──────────┴──────────┴───────────────────────┘  │
  └──────────────────────────────────────────────────────────────┘
</code></pre>
<p>下單扣、付款扣、預扣各有一致性風險。</p>
<h2 id="206-redis-庫存與防超賣對應-20612064"><a class="header" href="#206-redis-庫存與防超賣對應-20612064">20.6 Redis 庫存與防超賣（對應 20.6.1~20.6.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-86"><a class="header" href="#本小節示意圖-86">本小節示意圖</a></h3>
<pre><code class="language-text">Redis Lua 原子扣減防超賣 + SETNX 防重下單

  ─── Lua 原子扣減流程 ─────────────────────────────────────

  用戶請求
                                                           │
       ▼
  ┌────────────────────────────────────────────────────────┐
  │  Lua 腳本（原子執行，不被中斷）                        │
    │                                                      │
  │  local stock = redis.call('DECR', KEYS[1])             │
    │                                                      │
  │  if stock &gt;= 0 then                                    │
  │      return 1  -- 扣減成功                             │
  │  else                                                  │
  │      redis.call('INCR', KEYS[1])  -- 回滾              │
  │      return 0  -- 售罄                                 │
  │  end                                                   │
  └────────────────────────────────────────────────────────┘
       │ 返回 1 or 0
                                                           │
       ├── 1（成功）──► 進入下單流程
                                                           │
       └── 0（售罄）──► 返回「已售罄」頁面

  ─── SETNX 防重下單 ───────────────────────────────────────

  用戶 uid=1001 點擊搶購
                                                           │
       ▼
  SETNX order:1001:sku:001 "1"  EX 300
                                                           │
       ├── 成功（首次）──► 允許下單
                                                           │
       └── 失敗（已有）──► 返回「您已下單，請勿重複」

  ─── 整體防超賣流程 ───────────────────────────────────────

  請求進入
                                                           │
       ▼
  [限流檢查：令牌桶]
       │ 通過
       ▼
  [防重檢查：SETNX order:uid:sku]
       │ 非重複
       ▼
  [Lua 原子扣庫存：DECR stock:sku]
       │ stock &gt;= 0
       ▼
  [入 MQ 異步落庫]
                                                           │
       ▼
  [返回：「搶購成功」]
</code></pre>
<p>原子扣減 + 分段庫存 + 防重 + 風控。</p>
<h2 id="207-系統與網路優化對應-20712074"><a class="header" href="#207-系統與網路優化對應-20712074">20.7 系統與網路優化（對應 20.7.1~20.7.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-87"><a class="header" href="#本小節示意圖-87">本小節示意圖</a></h3>
<pre><code class="language-text">系統調優清單

  ┌───────────────────────────────────────────────────────────────┐
  │  OS 層優化                                                    │
   │                                                              │
  │  ・ulimit -n 65535   → 增大最大檔案/連線數                    │
  │  ・/proc/sys/net/core/somaxconn → 增大 listen backlog         │
  │  ・TCP_NODELAY → 關閉 Nagle 算法，降低延遲                    │
  │  ・vm.swappiness=1 → 減少 swap，避免延遲尖刺                  │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  網路層優化                                                   │
   │                                                              │
  │  ・TCP keepalive → 複用連線，避免頻繁三次握手                 │
  │  ・SO_REUSEPORT → 多個 worker 共用同一 port，核心分流         │
   │                                                              │
  │    ┌──────────┐  ┌──────────┐  ┌────────────┐                 │
  │    │ Worker 1 │  │ Worker 2 │  │ Worker 3   │                 │
  │    │  :8080   │  │  :8080   │  │  :8080     │                 │
  │    └──────────┘  └──────────┘  └────────────┘                 │
  │         ↑              ↑              ↑                       │
  │    核心按 CPU 親和性分發連線（SO_REUSEPORT）                  │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  連線池優化                                                   │
   │                                                              │
  │  DB 連線池：                                                  │
  │  ・pool_size = CPU核數 × 2（避免過多上下文切換）              │
  │  ・max_overflow = pool_size × 2                               │
  │  ・pool_timeout = 30s（避免無限等待）                         │
   │                                                              │
  │  Redis 連線池：                                               │
  │  ・每個應用節點保持 10~50 個長連線                            │
  │  ・避免頻繁 connect/disconnect                                │
  └───────────────────────────────────────────────────────────────┘

  ┌───────────────────────────────────────────────────────────────┐
  │  CDN 與靜態資源                                               │
   │                                                              │
  │  用戶 ──► CDN（命中） ──► 直接返回靜態頁（不過業務層）        │
  │       └── CDN（未命中）──► 回源 Nginx ──► 快取                │
   │                                                              │
  │  秒殺頁面應 100% 靜態化：                                     │
  │  ・商品詳情頁：提前生成 HTML                                  │
  │  ・圖片/JS/CSS：CDN 邊緣節點快取                              │
  │  ・倒計時：前端 JS 本地計算，不請求後端                       │
  └───────────────────────────────────────────────────────────────┘

  整體優化效益：

  項目          優化前      優化後
  ────────────────────────────────
  最大 QPS      1萬         20萬
  P99 延遲      500ms       20ms
  DB 壓力       100%        10%（MQ 削峰）
  CPU 使用率    90%（白旋） 60%（有效計算）
</code></pre>
<p>OS 參數、連線池、TCP 調優、機房拓樸都影響上限。</p>
<pre><code class="language-text">User -&gt; Gateway -&gt; RateLimit -&gt; MQ -&gt; OrderSvc -&gt; Stock(Redis/DB)
</code></pre>
<h2 id="示意圖-14"><a class="header" href="#示意圖-14">示意圖</a></h2>
<pre><code class="language-text">Client -&gt; Gateway -&gt; RateLimiter -&gt; MQ -&gt; OrderWorker -&gt; RedisStock -&gt; DB
高峰流量先削峰，再異步消化
</code></pre>
<h2 id="跨語言完整範例-19"><a class="header" href="#跨語言完整範例-19">跨語言完整範例</a></h2>
<h3 id="c--秒殺核心原子庫存扣減--防重--令牌桶限流"><a class="header" href="#c--秒殺核心原子庫存扣減--防重--令牌桶限流">C — 秒殺核心：原子庫存扣減 + 防重 + 令牌桶限流</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define MAX_USERS   100
#define INIT_STOCK  5

/* ── 令牌桶限流 ── */
typedef struct {
    atomic_int tokens;
    int capacity;
    pthread_mutex_t mu;
} TokenBucket;

void bucket_init(TokenBucket *b, int cap) {
    atomic_init(&amp;b-&gt;tokens, cap);
    b-&gt;capacity = cap;
    pthread_mutex_init(&amp;b-&gt;mu, NULL);
}

int bucket_take(TokenBucket *b) {
    int t = atomic_fetch_sub(&amp;b-&gt;tokens, 1);
    return t &gt; 0;
}

/* ── 防重（冪等）表 ── */
static int order_submitted[MAX_USERS];
static pthread_mutex_t idem_mu = PTHREAD_MUTEX_INITIALIZER;

int check_and_mark(int uid) {
    pthread_mutex_lock(&amp;idem_mu);
    int dup = order_submitted[uid];
    if (!dup) order_submitted[uid] = 1;
    pthread_mutex_unlock(&amp;idem_mu);
    return !dup;  /* 1: 首次, 0: 重複 */
}

/* ── 庫存原子扣減 ── */
static atomic_int stock = ATOMIC_VAR_INIT(INIT_STOCK);

int deduct_stock(void) {
    int cur = atomic_fetch_sub(&amp;stock, 1);
    if (cur &gt; 0) return 1;
    atomic_fetch_add(&amp;stock, 1);  /* 回滾 */
    return 0;
}

/* ── 秒殺主流程 ── */
typedef struct { int uid; TokenBucket *bucket; int *results; } Task;

void *seckill(void *arg) {
    Task *t = (Task *)arg;
    int uid = t-&gt;uid;
    /* 限流 */
    if (!bucket_take(t-&gt;bucket)) { t-&gt;results[uid] = -1; return NULL; }
    /* 防重 */
    if (!check_and_mark(uid)) { t-&gt;results[uid] = -2; return NULL; }
    /* 扣庫存 */
    t-&gt;results[uid] = deduct_stock() ? 1 : 0;
    return NULL;
}

int main(void) {
    TokenBucket bucket;
    bucket_init(&amp;bucket, 20);  /* 限流：每批最多 20 個請求 */

    int results[MAX_USERS] = {0};
    pthread_t tids[MAX_USERS];
    Task tasks[MAX_USERS];

    for (int i = 0; i &lt; MAX_USERS; i++) {
        tasks[i] = (Task){i, &amp;bucket, results};
        pthread_create(&amp;tids[i], NULL, seckill, &amp;tasks[i]);
    }
    for (int i = 0; i &lt; MAX_USERS; i++) pthread_join(tids[i], NULL);

    int success = 0;
    for (int i = 0; i &lt; MAX_USERS; i++) if (results[i] == 1) success++;
    printf("成功購買人數: %d (初始庫存 %d)\n", success, INIT_STOCK);
    printf("剩餘庫存: %d (應為 0)\n", atomic_load(&amp;stock));
    return 0;
}
</code></pre>
<h3 id="c--秒殺核心原子庫存--防重--令牌桶"><a class="header" href="#c--秒殺核心原子庫存--防重--令牌桶">C++ — 秒殺核心：原子庫存 + 防重 + 令牌桶</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

class TokenBucket {
    std::atomic&lt;int&gt; tokens_;
public:
    TokenBucket(int cap) : tokens_(cap) {}
    bool take() {
        int t = tokens_.fetch_sub(1, std::memory_order_acq_rel);
        return t &gt; 0;
    }
};

class IdempotentGuard {
    std::unordered_set&lt;int&gt; seen_;
    std::mutex mu_;
public:
    bool mark_first(int uid) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        return seen_.insert(uid).second;
    }
};

class StockManager {
    std::atomic&lt;int&gt; stock_;
public:
    StockManager(int init) : stock_(init) {}
    bool deduct() {
        int cur = stock_.fetch_sub(1, std::memory_order_acq_rel);
        if (cur &gt; 0) return true;
        stock_.fetch_add(1, std::memory_order_acq_rel);  /* 回滾 */
        return false;
    }
    int remaining() const { return stock_.load(); }
};

int main() {
    const int USER_COUNT = 100;
    const int INIT_STOCK = 5;

    TokenBucket bucket(20);
    IdempotentGuard idem;
    StockManager stock(INIT_STOCK);
    std::atomic&lt;int&gt; success_count{0};

    auto seckill = [&amp;](int uid) {
        if (!bucket.take()) return;          /* 限流 */
        if (!idem.mark_first(uid)) return;   /* 防重 */
        if (stock.deduct()) {
            success_count.fetch_add(1, std::memory_order_relaxed);
        }
    };

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; USER_COUNT; i++)
        threads.emplace_back(seckill, i);
    for (auto &amp;t : threads) t.join();

    std::cout &lt;&lt; "成功購買人數: " &lt;&lt; success_count.load()
              &lt;&lt; " (初始庫存 " &lt;&lt; INIT_STOCK &lt;&lt; ")\n";
    std::cout &lt;&lt; "剩餘庫存: " &lt;&lt; stock.remaining() &lt;&lt; " (應為 0)\n";
}
</code></pre>
<h3 id="rust--秒殺核心atomici32-原子庫存--hashset-防重"><a class="header" href="#rust--秒殺核心atomici32-原子庫存--hashset-防重">Rust — 秒殺核心：AtomicI32 原子庫存 + HashSet 防重</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;
use std::sync::{Arc, Mutex, atomic::{AtomicI32, Ordering}};
use std::thread;

struct Seckill {
    stock: AtomicI32,
    seen: Mutex&lt;HashSet&lt;u32&gt;&gt;,
    tokens: AtomicI32,
}

impl Seckill {
    fn new(init_stock: i32, rate_limit: i32) -&gt; Self {
        Seckill {
            stock: AtomicI32::new(init_stock),
            seen: Mutex::new(HashSet::new()),
            tokens: AtomicI32::new(rate_limit),
        }
    }
    fn try_buy(&amp;self, uid: u32) -&gt; &amp;'static str {
        if self.tokens.fetch_sub(1, Ordering::AcqRel) &lt;= 0 {
            self.tokens.fetch_add(1, Ordering::AcqRel);
            return "限流拒絕";
        }
        {
            let mut seen = self.seen.lock().unwrap();
            if !seen.insert(uid) { return "重複下單"; }
        }
        let cur = self.stock.fetch_sub(1, Ordering::AcqRel);
        if cur &gt; 0 { "購買成功" } else {
            self.stock.fetch_add(1, Ordering::AcqRel);
            "售罄"
        }
    }
}

fn main() {
    let sk = Arc::new(Seckill::new(5, 20));
    let mut handles = vec![];
    for uid in 0..100u32 {
        let sk = Arc::clone(&amp;sk);
        handles.push(thread::spawn(move || {
            let result = sk.try_buy(uid);
            if result == "購買成功" {
                println!("uid={} 購買成功", uid);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("剩餘庫存: {} (應為 0)", sk.stock.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--秒殺核心syncatomic-庫存--syncmap-防重"><a class="header" href="#go--秒殺核心syncatomic-庫存--syncmap-防重">Go — 秒殺核心：sync/atomic 庫存 + sync.Map 防重</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var (
    stock      int64 = 5
    tokens     int64 = 20
    orderSeen  sync.Map
    successCnt int64
)

func rateLimitPass() bool {
    t := atomic.AddInt64(&amp;tokens, -1)
    return t &gt;= 0
}

func markFirst(uid int) bool {
    _, loaded := orderSeen.LoadOrStore(uid, struct{}{})
    return !loaded
}

func deductStock() bool {
    cur := atomic.AddInt64(&amp;stock, -1)
    if cur &gt;= 0 {
        return true
    }
    atomic.AddInt64(&amp;stock, 1) // 回滾
    return false
}

func seckill(uid int, wg *sync.WaitGroup) {
    defer wg.Done()
    if !rateLimitPass() {
        return
    }
    if !markFirst(uid) {
        return
    }
    if deductStock() {
        atomic.AddInt64(&amp;successCnt, 1)
    }
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go seckill(i, &amp;wg)
    }
    wg.Wait()
    fmt.Printf("成功購買人數: %d (初始庫存 5)\n", atomic.LoadInt64(&amp;successCnt))
    fmt.Printf("剩餘庫存: %d (應為 0)\n", atomic.LoadInt64(&amp;stock))
}
</code></pre>
<h3 id="python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流"><a class="header" href="#python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流">Python — 秒殺核心：MockRedis Lua 原子扣減 + SETNX 防重 + 限流</a></h3>
<pre><code class="language-python">"""Chapter 20: seckill core — atomic stock deduct + idempotent + rate limit."""
import threading
import time


class MockRedis:
    """模擬 Redis 的原子操作：DECR（Lua）與 SETNX。"""

    def __init__(self):
        self._data = {}
        self._mu = threading.Lock()

    def set(self, key: str, value):
        with self._mu:
            self._data[key] = value

    def setnx(self, key: str, value) -&gt; bool:
        """SET key value NX → True: 首次設置成功"""
        with self._mu:
            if key in self._data:
                return False
            self._data[key] = value
            return True

    def lua_deduct_stock(self, key: str) -&gt; bool:
        """原子：DECR key → if &lt; 0: INCR (回滾) return False"""
        with self._mu:
            cur = self._data.get(key, 0)
            if cur &lt;= 0:
                return False
            self._data[key] = cur - 1
            return True

    def get(self, key: str):
        with self._mu:
            return self._data.get(key)


class TokenBucket:
    def __init__(self, capacity: int, refill_per_sec: int):
        self._tokens = capacity
        self._capacity = capacity
        self._refill_rate = refill_per_sec
        self._last_refill = time.monotonic()
        self._mu = threading.Lock()

    def take(self) -&gt; bool:
        with self._mu:
            now = time.monotonic()
            elapsed = now - self._last_refill
            self._tokens = min(
                self._capacity,
                self._tokens + int(elapsed * self._refill_rate)
            )
            self._last_refill = now
            if self._tokens &gt; 0:
                self._tokens -= 1
                return True
            return False


def run_seckill(user_count: int = 100, init_stock: int = 5):
    redis = MockRedis()
    bucket = TokenBucket(capacity=20, refill_per_sec=10)

    redis.set("stock:sku:001", init_stock)

    results = {"success": 0, "sold_out": 0, "limited": 0, "dup": 0}
    results_lock = threading.Lock()

    def buyer(uid: int):
        # 步驟 1：限流
        if not bucket.take():
            with results_lock:
                results["limited"] += 1
            return

        # 步驟 2：防重下單（SETNX）
        order_key = f"order:{uid}:sku:001"
        if not redis.setnx(order_key, "1"):
            with results_lock:
                results["dup"] += 1
            return

        # 步驟 3：Lua 原子扣庫存
        if redis.lua_deduct_stock("stock:sku:001"):
            with results_lock:
                results["success"] += 1
        else:
            with results_lock:
                results["sold_out"] += 1

    threads = [threading.Thread(target=buyer, args=(uid,)) for uid in range(user_count)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    remaining = redis.get("stock:sku:001")
    print(f"初始庫存: {init_stock}")
    print(f"成功購買: {results['success']} (應 &lt;= {init_stock})")
    print(f"售罄拒絕: {results['sold_out']}")
    print(f"限流拒絕: {results['limited']}")
    print(f"重複下單: {results['dup']}")
    print(f"剩餘庫存: {remaining} (應為 0 或正數，不能為負)")
    assert results["success"] &lt;= init_stock, "超賣！"
    assert remaining &gt;= 0, "庫存為負數！"
    print("通過：原子扣減防止超賣，SETNX 防止重複下單")


if __name__ == "__main__":
    run_seckill(user_count=100, init_stock=5)
</code></pre>
<h2 id="完整專案級範例python-19"><a class="header" href="#完整專案級範例python-19">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch20.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch20.py
</code></pre>
<pre><code class="language-python">"""Chapter 20: seckill pipeline demo."""
import queue
import threading

stock = 5
q: queue.Queue[str] = queue.Queue()
mu = threading.Lock()


def worker():
    global stock
    while True:
        user = q.get()
        if user == "STOP":
            return
        with mu:
            if stock &gt; 0:
                stock -= 1
                print(user, "success, left", stock)
            else:
                print(user, "sold out")


if __name__ == "__main__":
    t = threading.Thread(target=worker)
    t.start()
    for i in range(10):
        q.put(f"u{i}")
    q.put("STOP")
    t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附錄ccrustgopython-對照速查"><a class="header" href="#附錄ccrustgopython-對照速查">附錄：C/C++/Rust/Go/Python 對照速查</a></h1>
<div class="table-wrapper"><table><thead><tr><th>主題</th><th>C/C++</th><th>Rust</th><th>Go</th><th>Python</th></tr></thead><tbody>
<tr><td>執行單元</td><td>pthread / std::thread</td><td>std::thread / tokio::spawn</td><td>goroutine</td><td>threading.Thread</td></tr>
<tr><td>互斥鎖</td><td>pthread_mutex / std::mutex</td><td>Mutex&lt;T&gt;</td><td>sync.Mutex</td><td>threading.Lock()</td></tr>
<tr><td>讀寫鎖</td><td>pthread_rwlock / std::shared_mutex</td><td>RwLock&lt;T&gt;</td><td>sync.RWMutex</td><td>threading.RLock()</td></tr>
<tr><td>條件變數</td><td>pthread_cond / condition_variable</td><td>Condvar</td><td>sync.Cond</td><td>threading.Condition</td></tr>
<tr><td>原子操作</td><td>stdatomic.h / std::atomic</td><td>Atomic* (SeqCst/Acquire/Release)</td><td>sync/atomic</td><td>threading.Lock()(模擬)</td></tr>
<tr><td>信號量</td><td>sem_t / counting_semaphore</td><td>Mutex+Condvar / tokio::Semaphore</td><td>channel(buffered)</td><td>threading.Semaphore</td></tr>
<tr><td>執行緒本地</td><td>__thread / thread_local</td><td>thread_local!</td><td>context.Context(顯式傳遞)</td><td>threading.local()</td></tr>
<tr><td>執行緒池</td><td>自建 / OpenMP</td><td>rayon::ThreadPool / tokio</td><td>worker+channel 慣例</td><td>ThreadPoolExecutor</td></tr>
<tr><td>中斷/取消</td><td>stop flag / std::stop_token</td><td>無內建，用 channel</td><td>context.WithCancel</td><td>threading.Event</td></tr>
<tr><td>記憶體順序</td><td>memory_order_*</td><td>Ordering::*</td><td>sync/atomic (無細粒度)</td><td>GIL 保證(CPython)</td></tr>
<tr><td>無鎖計數器</td><td>atomic_fetch_add</td><td>fetch_add(Ordering)</td><td>atomic.AddInt64</td><td>需 Lock(GIL 不保證)</td></tr>
<tr><td>分散式鎖</td><td>不內建</td><td>不內建</td><td>不內建</td><td>不內建(需 Redis 等)</td></tr>
</tbody></table>
</div>
<h2 id="一個跨語言都成立的原則"><a class="header" href="#一個跨語言都成立的原則">一個跨語言都成立的原則</a></h2>
<p>先保證正確性，再談吞吐。</p>
<pre><code class="language-text">正確性(資料不錯) -&gt; 可用性(不死鎖) -&gt; 效能(夠快)
</code></pre>
<h2 id="共同最小模板"><a class="header" href="#共同最小模板">共同最小模板</a></h2>
<pre><code class="language-text">1) 先用 atomic 解決單變數競態
2) 需要複合一致性時改用 lock
3) 併發量大再加 queue/pool/backpressure
</code></pre>
<pre><code class="language-c">// C: atomic -&gt; mutex 升級路徑
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
atomic_int counter = 0;          // 單變數競態 → atomic
pthread_mutex_t mu;              // 複合操作 → mutex
</code></pre>
<pre><code class="language-cpp">// C++: atomic -&gt; mutex 升級路徑
#include &lt;atomic&gt;
#include &lt;mutex&gt;
std::atomic&lt;int&gt; counter{0};    // 單變數
std::mutex mu;                  // 複合操作
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust: Atomic* -&gt; Mutex/RwLock
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::{Mutex, RwLock};
static COUNTER: AtomicI32 = AtomicI32::new(0);  // 單變數
let shared = Mutex::new(HashMap::new());         // 複合操作
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-go">// Go: sync/atomic -&gt; sync.Mutex/RWMutex
import "sync/atomic"
import "sync"
var counter atomic.Int64          // 單變數
var mu sync.Mutex                 // 複合操作
</code></pre>
<pre><code class="language-python"># Python: Lock 保護複合操作（CPython GIL 不保證原子性）
import threading
lock = threading.Lock()
counter = 0                       # 不安全（GIL 不保證 counter += 1）
with lock:                        # 安全的複合操作
    counter += 1
</code></pre>
<h2 id="python-特別說明"><a class="header" href="#python-特別說明">Python 特別說明</a></h2>
<div class="table-wrapper"><table><thead><tr><th>項目</th><th>CPython 行為</th><th>注意事項</th></tr></thead><tbody>
<tr><td>GIL（全域直譯器鎖）</td><td>同一時刻只有一個執行緒跑 Python bytecode</td><td>I/O 密集可受益，CPU 密集用 multiprocessing</td></tr>
<tr><td><code>counter += 1</code></td><td><strong>不是原子</strong>（3 條 bytecode：LOAD/BINARY_ADD/STORE）</td><td>需加 Lock</td></tr>
<tr><td><code>threading.Lock</code></td><td>OS mutex 封裝</td><td>可跨執行緒互斥</td></tr>
<tr><td><code>threading.RLock</code></td><td>可重入鎖</td><td>同執行緒可多次 acquire</td></tr>
<tr><td>真正並行</td><td><code>multiprocessing</code> / <code>concurrent.futures.ProcessPoolExecutor</code></td><td>各自有獨立 GIL</td></tr>
<tr><td>異步並發</td><td><code>asyncio</code>（單執行緒事件迴圈）</td><td>適合 I/O 密集，非多核並行</td></tr>
</tbody></table>
</div>
<h2 id="選型快速決策"><a class="header" href="#選型快速決策">選型快速決策</a></h2>
<pre><code class="language-text">需要多核 CPU 並行運算？
  ├─ 是 → C/C++/Rust/Go（Python 用 multiprocessing）
  └─ 否（I/O 密集）→ 各語言都行，Python asyncio 亦可

需要極低延遲無 GC？
  └─ C/C++/Rust

需要記憶體安全無 data race 編譯期保證？
  └─ Rust

需要最簡單的並發模型？
  └─ Go（goroutine + channel）

需要快速腳本/原型？
  └─ Python（注意 GIL 限制）
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
