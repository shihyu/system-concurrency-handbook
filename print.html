<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>高並發編程通用概念（跨 Java/C++/Rust/Go）</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/beautiful-mermaid.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">高並發編程通用概念（跨 Java/C++/Rust/Go）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言如何讀這本並發書"><a class="header" href="#前言如何讀這本並發書">前言：如何讀這本並發書</a></h1>
<p>這本書雖然以 Java 展開，但大部分核心概念都不是 Java 專屬，而是所有高並發系統都要面對的通用問題。</p>
<h2 id="三句話抓重點"><a class="header" href="#三句話抓重點">三句話抓重點</a></h2>
<ol>
<li>並發問題的根源是「多執行單元同時碰同一份資料」。</li>
<li>解法分三層：語言層（原子/鎖）、執行時層（排程/執行緒池）、架構層（分散式鎖/削峰）。</li>
<li>高吞吐不是只靠語法，而是整條鏈路一起優化。</li>
</ol>
<h2 id="統一心智模型"><a class="header" href="#統一心智模型">統一心智模型</a></h2>
<pre><code class="language-text">請求 -&gt; 任務切分 -&gt; 排隊 -&gt; 執行 -&gt; 寫回資料
           |         |       |
         分工      背壓    一致性
</code></pre>
<h2 id="語言對照最小表"><a class="header" href="#語言對照最小表">語言對照最小表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>通用概念</th><th>Java</th><th>C/C++</th><th>Rust</th><th>Go</th></tr></thead><tbody>
<tr><td>執行單元</td><td>Thread</td><td>std::thread/pthread</td><td>std::thread</td><td>goroutine</td></tr>
<tr><td>互斥</td><td>synchronized/Lock</td><td>mutex</td><td>Mutex<T></td><td>sync.Mutex</td></tr>
<tr><td>原子</td><td>Atomic*</td><td>std::atomic</td><td>Atomic*</td><td>sync/atomic</td></tr>
<tr><td>可見性順序</td><td>JMM</td><td>C++ memory model</td><td>同 C++ 原子語義</td><td>Go memory model</td></tr>
</tbody></table>
</div>
<h2 id="閱讀建議"><a class="header" href="#閱讀建議">閱讀建議</a></h2>
<ul>
<li>先讀第 1~6 章建立底層觀念。</li>
<li>再讀第 7~14 章看語言與框架實作。</li>
<li>最後讀第 15~20 章把概念落到工程。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第1章-作業系統與線程調度"><a class="header" href="#第1章-作業系統與線程調度">第1章 作業系統與線程調度</a></h1>
<h2 id="11-計算機基礎對應-111112"><a class="header" href="#11-計算機基礎對應-111112">1.1 計算機基礎（對應 1.1.1~1.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖"><a class="header" href="#本小節示意圖">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["馮諾伊曼架構: CPU 記憶體 I/O"]
  N2["CPU"]
  N3["控制單元 算術邏輯 暫存器組"]
  N4["(CU) 單元(ALU) R0 R1 R2 ... R15"]
  N5["系統匯流排（System Bus）"]
  N6["記憶體 I/O 裝置"]
  N7["(RAM) 磁碟/網路/鍵盤"]
  N8["快取層次（速度由快到慢，容量由小到大）"]
  N9["速度: 最快 最慢"]
  N10["容量: 最小 最大"]
  N11["Register L1$ L2$ L3$ RAM Disk"]
  N12["~1ns ~4ns ~12ns ~30ns ~100ns ~10ms"]
  N13["&amp;lt;1KB 64KB 512KB 8MB GB 級別 TB級"]
  N14["核心獨享 核心獨享 核心獨享 插槽共享 DRAM 持久化"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N4 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N8 --&gt; N12
  N8 --&gt; N13
  N13 --&gt; N14
</code></pre>
<p>重點：CPU 做計算，記憶體放資料，I/O 負責進出。</p>
<p>白話例子：廚房裡，廚師=CPU，冰箱=記憶體，外送窗口=I/O。快取好比廚師的備料台，常用食材放在手邊，不用每次跑去冰箱。</p>
<h2 id="12-多核與多-cpu對應-121125"><a class="header" href="#12-多核與多-cpu對應-121125">1.2 多核與多 CPU（對應 1.2.1~1.2.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-1"><a class="header" href="#本小節示意圖-1">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["單核時間切片（Concurrency，並發但非並行）"]
  N2["時間軸"]
  N3["Core0 T1 T2 T1 T3 T2 T1 T3"]
  N4["Context Switch Context Switch"]
  N5["（上下文切換，有額外成本）"]
  N6["多核真並行（Parallelism）"]
  N7["時間軸"]
  N8["Core0 T1 T1 T1 T1 T1 T1"]
  N9["Core1 T2 T2 T2 T2 T2 T2"]
  N10["Core2 T3 T3 T3 T3 T3 T3"]
  N11["Core3 T4 T4 T4 T4 T4 T4"]
  N12["真正同時執行，吞吐量 ≈ 單核 × 核心數"]
  N13["NUMA 多插槽架構（跨 Socket 成本警示）"]
  N14["Socket 0 Socket 1"]
  N15["Core0 Core1 ... Core4 Core5 ..."]
  N16["L3 Cache (共享) L3 Cache (共享)"]
  N17["Local RAM Local RAM"]
  N18["QPI / UPI 互連"]
  N19["（跨 Socket 延遲 ≈ 本地 RAM 的 2~3 倍）"]
  N20["⚠ 跨 Socket 存取 Remote RAM 比 Local RAM 慢得多，設計時盡量讓執行緒存取本地記憶體"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N3 --&gt; N4
  N3 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N11 --&gt; N12
  N0 --&gt; N13
  N13 --&gt; N14
  N13 --&gt; N15
  N13 --&gt; N16
  N13 --&gt; N17
  N17 --&gt; N18
  N18 --&gt; N19
  N13 --&gt; N20
</code></pre>
<p>重點：</p>
<ul>
<li>單核：同時只能真做一件事，靠時間切換看起來像同時。</li>
<li>多核：可真並行。</li>
<li>多 CPU：更多插槽，但跨 Socket 總線協調成本高。</li>
</ul>
<h2 id="13-線程模型對應-131133"><a class="header" href="#13-線程模型對應-131133">1.3 線程模型（對應 1.3.1~1.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-2"><a class="header" href="#本小節示意圖-2">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["三種線程模型對比"]
  N2["模型 1: 1:1 模型（Java / C++ / Rust 標準線程）"]
  N3["User Space [Thread A] [Thread B] [Thread C]"]
  N4["每個用戶線程"]
  N5["Kernel Space [KThread] [KThread] [KThread] 直接對應一個核心線程"]
  N6["CPU Core [Core 0] [Core 1] [Core 2]"]
  N7["優點: OS 直接調度，真正並行；阻塞不影響其他線程"]
  N8["缺點: 線程創建/切換成本高（syscall），線程數受 OS 限制"]
  N9["模型 2: M:1 模型（舊版 Green Thread / 早期 JVM）"]
  N10["User Space [Thread A][Thread B][Thread C][Thread D][Thread E]"]
  N11["User-Level Scheduler"]
  N12["Kernel Space [KThread] 只有一個核心線程"]
  N13["CPU Core [Core 0]"]
  N14["優點: 切換快（不需要 syscall）"]
  N15["缺點: 任一線程阻塞 整個進程卡住；無法利用多核"]
  N16["模型 3: M:N 模型（Go goroutine / Erlang process）"]
  N17["User Space [G1][G2][G3][G4][G5][G6][G7][G8] N 個 goroutine（可達百萬）"]
  N18["[P0 Queue] [P1 Queue] [P2 Queue] M 個邏輯處理器（≈CPU核數）"]
  N19["Kernel Space [KThread0] [KThread1] [KThread2] K 個核心線程"]
  N20["CPU Core [Core 0] [Core 1] [Core 2]"]
  N21["優點: 輕量（goroutine ~2KB），阻塞自動切換，真並行"]
  N22["缺點: Runtime 複雜；Work Stealing 調度有額外開銷"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
</code></pre>
<ul>
<li>使用者線程：切換快，但碰到阻塞可能整批卡住。</li>
<li>核心線程：由 OS 調度，隔離好，成本較高。</li>
<li>混合模型：兩者折衷，Go 是最成功的 M:N 實作之一。</li>
</ul>
<h2 id="14-java-線程與-os-線程映射"><a class="header" href="#14-java-線程與-os-線程映射">1.4 Java 線程與 OS 線程映射</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-3"><a class="header" href="#本小節示意圖-3">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Java 線程完整映射鏈"]
  N2["Java 層 JVM 層 OS 層 硬體層"]
  N3["new Thread()"]
  N4["Java API"]
  N5["thread.start()"]
  N6["JNI 呼叫"]
  N7["JVM Native pthread_create()"]
  N8["Thread Code"]
  N9["Linux syscall"]
  N10["OS Kernel"]
  N11["pthread /"]
  N12["clone()"]
  N13["調度"]
  N14["CPU Core"]
  N15["執行機器碼"]
  N16["Java 線程狀態機"]
  N17["start() run() 結束"]
  N18["OS 分配時間片"]
  N19["NEW RUNNABLE TERMINATED"]
  N20["synchronized/IO 阻塞"]
  N21["BLOCKED WAITING TIMED_WAITING"]
  N22["(等待鎖) (wait/join/ (sleep/"]
  N23["park 無超時) wait有超時)"]
  N24["鎖釋放 notify/ 超時/"]
  N25["unpark interrupt"]
  N26["RUNNABLE（重新競爭）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N3 --&gt; N4
  N1 --&gt; N5
  N5 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N9 --&gt; N10
  N9 --&gt; N11
  N9 --&gt; N12
  N12 --&gt; N13
  N9 --&gt; N14
  N9 --&gt; N15
  N0 --&gt; N16
  N16 --&gt; N17
  N16 --&gt; N18
  N16 --&gt; N19
  N19 --&gt; N20
  N19 --&gt; N21
  N19 --&gt; N22
  N19 --&gt; N23
  N23 --&gt; N24
  N23 --&gt; N25
  N25 --&gt; N26
</code></pre>
<p>Java 的 <code>Thread</code> 最終也要跑在 OS 調度上。C/C++/Rust/Go 一樣，差別主要在 runtime 包裝方式。</p>
<h2 id="跨語言對照"><a class="header" href="#跨語言對照">跨語言對照</a></h2>
<div class="table-wrapper"><table><thead><tr><th>概念</th><th>C</th><th>C++</th><th>Rust</th><th>Go</th></tr></thead><tbody>
<tr><td>執行單元</td><td>pthread</td><td>std::thread</td><td>std::thread</td><td>goroutine（M:N）</td></tr>
<tr><td>啟動方式</td><td>pthread_create</td><td>thread.detach/join</td><td>thread::spawn</td><td>go func()</td></tr>
<tr><td>核數查詢</td><td>sysconf</td><td>thread::hardware_concurrency</td><td>num_cpus crate</td><td>runtime.NumCPU()</td></tr>
<tr><td>線程模型</td><td>1:1（OS pthread）</td><td>1:1（OS pthread）</td><td>1:1（OS pthread）</td><td>M:N（Go runtime）</td></tr>
</tbody></table>
</div>
<h2 id="示意圖"><a class="header" href="#示意圖">示意圖</a></h2>
<pre><code class="language-text">多核並行執行示意（兩核四線程）：

時間軸 ────────────────────────────────────────────►
       ┌──────┬──────┬──────┬──────┬──────┬──────┐
Core0  │  T1  │  T1  │  T1  │  T3  │  T3  │  T3  │
       ├──────┼──────┼──────┼──────┼──────┼──────┤
Core1  │  T2  │  T2  │  T2  │  T4  │  T4  │  T4  │
       └──────┴──────┴──────┴──────┴──────┴──────┘
                           ▲
                      Context Switch
        （T1/T2 → T3/T4，OS 調度器決定切換時機）
</code></pre>
<h2 id="跨語言完整範例"><a class="header" href="#跨語言完整範例">跨語言完整範例</a></h2>
<p>建立 2 個執行緒各自打印 tick，並印出 CPU 核心數。</p>
<h3 id="cpthread"><a class="header" href="#cpthread">C（pthread）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

struct args { const char *name; int ticks; };

void *tick_worker(void *arg) {
    struct args *a = (struct args *)arg;
    for (int i = 0; i &lt; a-&gt;ticks; i++) {
        printf("%s tick %d\n", a-&gt;name, i);
        usleep(50000);
    }
    return NULL;
}

int main(void) {
    long cpu_count = sysconf(_SC_NPROCESSORS_ONLN);
    printf("cpu_count = %ld\n", cpu_count);

    pthread_t t1, t2;
    struct args a1 = {"T1", 3}, a2 = {"T2", 3};
    pthread_create(&amp;t1, NULL, tick_worker, &amp;a1);
    pthread_create(&amp;t2, NULL, tick_worker, &amp;a2);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -o tick tick.c -lpthread &amp;&amp; ./tick
</code></pre>
<h3 id="cstdthread"><a class="header" href="#cstdthread">C++（std::thread）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

void tick_worker(const std::string &amp;name, int ticks) {
    for (int i = 0; i &lt; ticks; i++) {
        std::cout &lt;&lt; name &lt;&lt; " tick " &lt;&lt; i &lt;&lt; "\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

int main() {
    unsigned int cores = std::thread::hardware_concurrency();
    std::cout &lt;&lt; "cpu_count = " &lt;&lt; cores &lt;&lt; "\n";

    std::thread t1(tick_worker, "T1", 3);
    std::thread t2(tick_worker, "T2", 3);
    t1.join();
    t2.join();
    return 0;
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o tick tick.cpp -lpthread &amp;&amp; ./tick
</code></pre>
<h3 id="ruststdthread"><a class="header" href="#ruststdthread">Rust（std::thread）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn tick_worker(name: &amp;str, ticks: u32) {
    for i in 0..ticks {
        println!("{} tick {}", name, i);
        thread::sleep(Duration::from_millis(50));
    }
}

fn main() {
    let cpu_count = std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(1);
    println!("cpu_count = {}", cpu_count);

    let t1 = thread::spawn(|| tick_worker("T1", 3));
    let t2 = thread::spawn(|| tick_worker("T2", 3));
    t1.join().unwrap();
    t2.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine"><a class="header" href="#gogoroutine">Go（goroutine）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func tickWorker(name string, ticks int, wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i &lt; ticks; i++ {
        fmt.Printf("%s tick %d\n", name, i)
        time.Sleep(50 * time.Millisecond)
    }
}

func main() {
    fmt.Printf("cpu_count = %d\n", runtime.NumCPU())

    var wg sync.WaitGroup
    wg.Add(2)
    go tickWorker("T1", 3, &amp;wg)
    go tickWorker("T2", 3, &amp;wg)
    wg.Wait()
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonthreading"><a class="header" href="#pythonthreading">Python（threading）</a></h3>
<pre><code class="language-python">import os
import threading
import time

def tick_worker(name: str, ticks: int):
    for i in range(ticks):
        print(f"{name} tick {i}")
        time.sleep(0.05)

if __name__ == "__main__":
    print(f"cpu_count = {os.cpu_count()}")
    t1 = threading.Thread(target=tick_worker, args=("T1", 3))
    t2 = threading.Thread(target=tick_worker, args=("T2", 3))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
</code></pre>
<pre><code class="language-bash">python3 tick.py
</code></pre>
<h2 id="完整專案級範例python"><a class="header" href="#完整專案級範例python">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch01.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch01.py
</code></pre>
<pre><code class="language-python">"""Chapter 01: OS scheduling and threads.

展示：
1. 印出 CPU 核心數
2. 建立 2 個執行緒各自打印 tick
3. 觀察執行緒交錯輸出（並發）
"""
import os
import threading
import time


def work(name: str, ticks: int = 3):
    for i in range(ticks):
        print(f"{name} tick {i}", flush=True)
        time.sleep(0.05)


if __name__ == "__main__":
    print(f"cpu_count = {os.cpu_count()}")
    t1 = threading.Thread(target=work, args=("T1",))
    t2 = threading.Thread(target=work, args=("T2",))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print("done")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第2章-並發基礎概念與風險"><a class="header" href="#第2章-並發基礎概念與風險">第2章 並發基礎概念與風險</a></h1>
<h2 id="21-基本名詞對應-211219"><a class="header" href="#21-基本名詞對應-211219">2.1 基本名詞（對應 2.1.1~2.1.9）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-4"><a class="header" href="#本小節示意圖-4">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["進程 vs 線程"]
  N2["Process 進程（資源容器）"]
  N3["虛擬記憶體空間 / 檔案描述符 / 信號處理器"]
  N4["Thread A Thread B Thread C"]
  N5["(執行單位) (執行單位) (執行單位)"]
  N6["Stack Stack Stack"]
  N7["PC/暫存器 PC/暫存器 PC/暫存器"]
  N8["共享 Heap / 全域變數"]
  N9["並發 Concurrency（交錯推進，不一定同時）"]
  N10["時間軸"]
  N11["Core0 A B A C B C A B C"]
  N12["切換 切換（Context Switch）"]
  N13["並行 Parallelism（真正同時，需要多核）"]
  N14["時間軸"]
  N15["Core0 A A A A A A"]
  N16["Core1 B B B B B B"]
  N17["同步 Sync（呼叫後阻塞等待結果）"]
  N18["caller [發出請求] [等待中...] [得到結果] 繼續往下"]
  N19["異步 Async（呼叫後立即返回，結果晚點通知）"]
  N20["caller [發出請求] 繼續做其他事情 ..."]
  N21["[callback/future 收到結果]"]
  N22["阻塞 Blocking（等待期間執行流停住）"]
  N23["T1: [發出 I/O 請求] ░░░░░░░░ WAIT ░░░░░░░░ [繼續]"]
  N24["這段時間 CPU 不執行此線程"]
  N25["非阻塞 Non-blocking（不停住，改輪詢或事件驅動）"]
  N26["T1: [發出 I/O 請求] [做其他工作] [輪詢/事件] [繼續]"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N0 --&gt; N9
  N9 --&gt; N10
  N9 --&gt; N11
  N11 --&gt; N12
  N0 --&gt; N13
  N13 --&gt; N14
  N13 --&gt; N15
  N13 --&gt; N16
  N0 --&gt; N17
  N17 --&gt; N18
  N0 --&gt; N19
  N19 --&gt; N20
  N20 --&gt; N21
  N0 --&gt; N22
  N22 --&gt; N23
  N23 --&gt; N24
  N0 --&gt; N25
  N25 --&gt; N26
</code></pre>
<ul>
<li>進程：資源容器。</li>
<li>線程：執行單位。</li>
<li>並發：交錯進行。</li>
<li>並行：同時進行。</li>
<li>同步/異步：拿結果的方式。</li>
<li>阻塞/非阻塞：等待時是否卡住執行流。</li>
</ul>
<h2 id="22-三大風險對應-221223"><a class="header" href="#22-三大風險對應-221223">2.2 三大風險（對應 2.2.1~2.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-5"><a class="header" href="#本小節示意圖-5">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["並發三大風險三角形"]
  N2["安全性（Safety）"]
  N3["結果正確性"]
  N4["典型症狀"]
  N5["・counter 結果偏小"]
  N6["・資料庫記錄重複"]
  N7["・賬戶餘額計算錯誤"]
  N8["三者往往互相影響"]
  N9["活躍性（Liveness） 效能（Performance）"]
  N10["程式能繼續推進 速度是否夠快"]
  N11["典型症狀: 典型症狀"]
  N12["・死鎖 Deadlock ・鎖競爭（Contention）"]
  N13["T1 等 T2 的鎖 ・上下文切換過多"]
  N14["T2 等 T1 的鎖 ・快取失效（Cache Miss）"]
  N15["・飢餓 Starvation ・假共享（False Sharing）"]
  N16["低優先級線程永遠"]
  N17["搶不到鎖 解法: 鎖粒度、CAS、"]
  N18["・活鎖 Livelock 無鎖結構、線程池調優"]
  N19["雙方都在讓步但都"]
  N20["無法推進"]
  N21["三者關係"]
  N22["・過度加鎖 安全性高，但效能差"]
  N23["・不加鎖 效能好，但安全性崩潰"]
  N24["・鎖粒度錯 可能同時損失效能和活躍性（死鎖）"]
  N25["死鎖示意（T1/T2 互等）"]
  N26["T1: [持有 Lock A] [等待 Lock B] 永久阻塞"]
  N27["T2: [持有 Lock B] [等待 Lock A] 永久阻塞"]
  N28["循環等待"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N7 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N0 --&gt; N21
  N21 --&gt; N22
  N21 --&gt; N23
  N21 --&gt; N24
  N0 --&gt; N25
  N25 --&gt; N26
  N25 --&gt; N27
  N27 --&gt; N28
</code></pre>
<ul>
<li>安全性：結果錯（資料競爭）。</li>
<li>活躍性：做不完（死鎖/飢餓/活鎖）。</li>
<li>效能：做得慢（鎖競爭、上下文切換）。</li>
</ul>
<h2 id="23-鎖分類對應-231238"><a class="header" href="#23-鎖分類對應-231238">2.3 鎖分類（對應 2.3.1~2.3.8）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-6"><a class="header" href="#本小節示意圖-6">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["鎖分類樹狀圖"]
  N2["鎖"]
  N3["悲觀/樂觀 公平/非公平 可重入/不可 共享/獨占 自旋/阻塞"]
  N4["重入"]
  N5["悲觀鎖 公平鎖 可重入鎖 共享鎖 自旋鎖"]
  N6["先鎖再操作 FIFO 排隊 同線程可 多讀者 忙等"]
  N7["多次獲得 同時持有 適合短臨"]
  N8["例: 例: 界區"]
  N9["Mutex Java 例: 例"]
  N10["ReentrantLock Java RWLock"]
  N11["(fair=true) Reentrant ReadLock"]
  N12["Lock"]
  N13["樂觀鎖 非公平鎖 獨占鎖 阻塞鎖"]
  N14["先操作後 可插隊 不可重入 同時只有 掛起線程"]
  N15["校驗衝突 同線程再 一個持有 適合長臨"]
  N16["例: 次獲取 界區"]
  N17["例: CAS/ Java 死鎖 例"]
  N18["MVCC Reentrant Mutex/ 例: OS"]
  N19["Lock WriteLock futex"]
  N20["(預設)"]
  N21["各鎖使用場景選擇指引"]
  N22["場景 推薦鎖類型"]
  N23["讀多寫少 共享讀鎖（RWLock）"]
  N24["衝突少 樂觀鎖（CAS/MVCC）"]
  N25["衝突多 悲觀鎖（Mutex）"]
  N26["臨界區極短 自旋鎖（SpinLock）"]
  N27["臨界區較長 阻塞鎖（OS Mutex）"]
  N28["需要遞迴獲取 可重入鎖（ReentrantLock）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N0 --&gt; N21
  N21 --&gt; N22
  N21 --&gt; N23
  N21 --&gt; N24
  N21 --&gt; N25
  N21 --&gt; N26
  N21 --&gt; N27
  N21 --&gt; N28
</code></pre>
<ul>
<li>悲觀/樂觀</li>
<li>公平/非公平</li>
<li>可重入/不可重入</li>
<li>可中斷/不可中斷</li>
<li>共享/獨占</li>
<li>自旋/阻塞</li>
</ul>
<p>白話例子：</p>
<ul>
<li>公平鎖像銀行抽號，先到先得。</li>
<li>非公平鎖像空位誰搶到誰先辦。</li>
<li>可重入鎖像房間主人可以再進自己的房間；不可重入則會把自己鎖在外面。</li>
</ul>
<h2 id="示意圖-1"><a class="header" href="#示意圖-1">示意圖</a></h2>
<pre><code class="language-text">競態條件（Race Condition）導致丟失更新：

  時間軸 ─────────────────────────────────────────────────►
         Step 1          Step 2          Step 3
  T1: ──►[read x=0] ──► [計算 0+1=1] ──►           [write x=1] ──►
  T2: ──►[read x=0] ────────────────────►[計算 0+1=1] ──► [write x=1]

  預期：x = 2
  實際：x = 1  ← T1 的更新被 T2 覆蓋，丟失一次遞增！
</code></pre>
<h2 id="跨語言完整範例-1"><a class="header" href="#跨語言完整範例-1">跨語言完整範例</a></h2>
<p>無鎖版 vs 加鎖版 counter++（展示 race condition）。</p>
<h3 id="cpthread--無鎖加鎖對比"><a class="header" href="#cpthread--無鎖加鎖對比">C（pthread + 無鎖/加鎖對比）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define THREADS 4
#define ITER    100000

long unsafe_counter = 0;
long safe_counter = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *unsafe_inc(void *arg) {
    for (int i = 0; i &lt; ITER; i++)
        unsafe_counter++;   /* 非原子，有競態 */
    return NULL;
}

void *safe_inc(void *arg) {
    for (int i = 0; i &lt; ITER; i++) {
        pthread_mutex_lock(&amp;lock);
        safe_counter++;     /* 加鎖保護，結果正確 */
        pthread_mutex_unlock(&amp;lock);
    }
    return NULL;
}

int main(void) {
    pthread_t tid[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, unsafe_inc, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("unsafe_counter = %ld (expected %d)\n", unsafe_counter, THREADS * ITER);

    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, safe_inc, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("safe_counter   = %ld (expected %d)\n", safe_counter, THREADS * ITER);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -O0 -o race race.c -lpthread &amp;&amp; ./race
</code></pre>
<h3 id="cstdthread--stdmutex"><a class="header" href="#cstdthread--stdmutex">C++（std::thread + std::mutex）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

const int THREADS = 4, ITER = 100000;
long unsafe_counter = 0;
long safe_counter = 0;
std::mutex lock;

void unsafe_inc() {
    for (int i = 0; i &lt; ITER; i++)
        unsafe_counter++;
}

void safe_inc() {
    for (int i = 0; i &lt; ITER; i++) {
        std::lock_guard&lt;std::mutex&gt; g(lock);
        safe_counter++;
    }
}

void run(void(*fn)()) {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) ts.emplace_back(fn);
    for (auto &amp;t : ts) t.join();
}

int main() {
    run(unsafe_inc);
    std::cout &lt;&lt; "unsafe: " &lt;&lt; unsafe_counter &lt;&lt; " (expected " &lt;&lt; THREADS*ITER &lt;&lt; ")\n";
    run(safe_inc);
    std::cout &lt;&lt; "safe:   " &lt;&lt; safe_counter   &lt;&lt; " (expected " &lt;&lt; THREADS*ITER &lt;&lt; ")\n";
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -O0 -o race race.cpp -lpthread &amp;&amp; ./race
</code></pre>
<h3 id="ruststdthread--mutex-vs-atomici64"><a class="header" href="#ruststdthread--mutex-vs-atomici64">Rust（std::thread + Mutex vs AtomicI64）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::sync::atomic::{AtomicI64, Ordering};
use std::thread;

const THREADS: usize = 4;
const ITER: i64 = 100_000;

fn main() {
    // 加鎖版：結果正確
    let safe = Arc::new(Mutex::new(0i64));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;safe);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { *c.lock().unwrap() += 1; }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("safe (mutex):  {} (expected {})", *safe.lock().unwrap(), THREADS as i64 * ITER);

    // 原子版：無鎖且正確
    let atomic = Arc::new(AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;atomic);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { c.fetch_add(1, Ordering::Relaxed); }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("safe (atomic): {} (expected {})", atomic.load(Ordering::SeqCst), THREADS as i64 * ITER);
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine--syncmutex-vs-atomic"><a class="header" href="#gogoroutine--syncmutex-vs-atomic">Go（goroutine + sync.Mutex vs atomic）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

const threads, iter = 4, 100_000

func main() {
    // 無鎖（競態，結果通常偏小）
    var unsafe_counter int64
    var wg sync.WaitGroup
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                unsafe_counter++ // data race!
            }
        }()
    }
    wg.Wait()
    fmt.Printf("unsafe:  %d (expected %d)\n", unsafe_counter, threads*iter)

    // 原子版（無鎖且正確）
    var safe_counter int64
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                atomic.AddInt64(&amp;safe_counter, 1)
            }
        }()
    }
    wg.Wait()
    fmt.Printf("safe:    %d (expected %d)\n", safe_counter, threads*iter)
}
</code></pre>
<pre><code class="language-bash">go run main.go
# 加 -race 旗標可偵測競態：
go run -race main.go
</code></pre>
<h3 id="pythonthreading--lock-對比"><a class="header" href="#pythonthreading--lock-對比">Python（threading + Lock 對比）</a></h3>
<pre><code class="language-python">import threading

THREADS, ITER = 4, 100_000

unsafe_counter = 0
safe_counter = 0
lock = threading.Lock()

def unsafe_inc():
    global unsafe_counter
    for _ in range(ITER):
        unsafe_counter += 1   # Python GIL 下通常安全，但不保證

def safe_inc():
    global safe_counter
    for _ in range(ITER):
        with lock:
            safe_counter += 1

def run_threads(fn):
    ts = [threading.Thread(target=fn) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()

run_threads(unsafe_inc)
print(f"unsafe: {unsafe_counter} (expected {THREADS * ITER})")
run_threads(safe_inc)
print(f"safe:   {safe_counter} (expected {THREADS * ITER})")
</code></pre>
<pre><code class="language-bash">python3 race.py
</code></pre>
<h2 id="完整專案級範例python-1"><a class="header" href="#完整專案級範例python-1">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch02.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch02.py
</code></pre>
<pre><code class="language-python">"""Chapter 02: race risk and lock.

展示：
1. 無鎖版 counter（可能有競態，Python GIL 有時會掩蓋，但 C/Rust/Go 明確可見）
2. 有鎖版 counter（結果正確，永遠等於 THREADS * ITER）
"""
import threading

THREADS = 4
ITER = 50_000

counter = 0
lock = threading.Lock()


def inc(n: int):
    global counter
    for _ in range(n):
        with lock:
            counter += 1


if __name__ == "__main__":
    threads = [threading.Thread(target=inc, args=(ITER,)) for _ in range(THREADS)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    print(f"counter = {counter} (expected {THREADS * ITER})")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第3章-三大核心問題分工同步互斥"><a class="header" href="#第3章-三大核心問題分工同步互斥">第3章 三大核心問題：分工、同步、互斥</a></h1>
<h2 id="31-分工對應-311312"><a class="header" href="#31-分工對應-311312">3.1 分工（對應 3.1.1~3.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-7"><a class="header" href="#本小節示意圖-7">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["任務切分流水線（Pipeline 分工）"]
  N2["原始任務（序列）"]
  N3["Input Parse Compute Store （全部串行，吞吐量受限）"]
  N4["分工並行化（三個執行緒分擔不同角色）"]
  N5["資料流向"]
  N6["Queue1 Queue2"]
  N7["Input Parse Compute"]
  N8["(讀取資料) Thread T1 Thread T2"]
  N9["Queue3"]
  N10["Store"]
  N11["Thread T3"]
  N12["時間軸對比"]
  N13["串行（總時間 = T_parse + T_compute + T_store）"]
  N14["Parse Compute Store"]
  N15["流水線並行（穩態吞吐量 ≈ max(T_parse, T_compute, T_store) 決定瓶頸）"]
  N16["Time: 1 2 3 4 5 6"]
  N17["T1: [P1][P2][P3][P4][P5][P6] Parse"]
  N18["T2: [C1][C2][C3][C4][C5] Compute（等 P1 完）"]
  N19["T3: [S1][S2][S3][S4] Store（等 C1 完）"]
  N20["穩態後三個階段同時跑，吞吐量 ≈ 串行的 3 倍"]
  N21["⚠ 注意: Stage 之間必須用 Queue 緩衝（解耦速率差異）"]
  N22["⚠ 注意: 最慢的 Stage 決定整個 Pipeline 的上限（木桶效應）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N19 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
</code></pre>
<p>把任務切成可平行的小任務，減少單點瓶頸。</p>
<h2 id="32-同步對應-321322"><a class="header" href="#32-同步對應-321322">3.2 同步（對應 3.2.1~3.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-8"><a class="header" href="#本小節示意圖-8">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["同步: 因果關係約束（T1 完成 T2 才能開始）"]
  N2["因果關係圖"]
  N3["Thread T1 Thread T2"]
  N4["[計算數據]"]
  N5["[準備結果]"]
  N6["signal / notify / set()"]
  N7["done 事件 等待 done"]
  N8["(已發出) wait() 阻塞"]
  N9["收到通知"]
  N10["[開始消費結果]"]
  N11["[繼續往下執行]"]
  N12["時間軸視角（等待/喚醒機制）"]
  N13["時間"]
  N14["T1: [工作][工作][工作] signal"]
  N15["T2: [wait...]░░░░░░░░░░░░░░░░░░░░░░░░ [繼續執行]"]
  N16["T2 被阻塞 T1 發出信號後 T2 喚醒"]
  N17["常見同步原語對比"]
  N18["原語 語意"]
  N19["Event/Flag 1:N 通知，一次性或可重置"]
  N20["Semaphore 計數信號量，允許 N 個執行緒同時通過"]
  N21["Barrier 所有參與者都到達後才一起放行"]
  N22["CountDown 計數到 0 後通知等待者"]
  N23["Condition wait/notify，配合鎖使用"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N5 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N15 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
</code></pre>
<p>約束「先後順序」，避免讀到半成品。</p>
<h2 id="33-互斥對應-331332"><a class="header" href="#33-互斥對應-331332">3.3 互斥（對應 3.3.1~3.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-9"><a class="header" href="#本小節示意圖-9">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["互斥: 臨界區保護（同一時間只有一個執行緒進入）"]
  N2["臨界區（Critical Section）"]
  N3["lock()"]
  N4["Thread 1 正在執行"]
  N5["成功，進入 counter++"]
  N6["lock()"]
  N7["Thread 2 阻塞等待..."]
  N8["失敗，排隊 ░░░░░░░░░░░░░░"]
  N9["lock()"]
  N10["Thread 3 阻塞等待..."]
  N11["失敗，排隊 ░░░░░░░░░░░░░░"]
  N12["鎖的生命週期"]
  N13["Thread 1: lock() [臨界區] unlock()"]
  N14["獲取鎖（進入） 釋放鎖"]
  N15["Thread 2: lock() 阻塞....... [臨界區] unlock()"]
  N16["T1 持有鎖時 T1 unlock 後"]
  N17["T2 被阻塞 T2 被喚醒"]
  N18["互斥保護的是「操作的不可分性」，確保中間狀態不被其他執行緒看見。"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N13 --&gt; N14
  N1 --&gt; N15
  N15 --&gt; N16
  N15 --&gt; N17
  N1 --&gt; N18
</code></pre>
<p>同一時間只允許一個執行單元修改共享資料。</p>
<p>白話例子：結帳金額是共享資源，兩個收銀機同時改同筆訂單會亂掉；互斥鎖好比「正在服務中，請稍候」的牌子。</p>
<h2 id="示意圖-2"><a class="header" href="#示意圖-2">示意圖</a></h2>
<pre><code class="language-text">三大核心問題綜合示意（Pipeline + 同步 + 互斥）：

  ┌──────────┐       Queue        ┌──────────────┐      Queue      ┌──────────┐
  │ Producer │ ──────────────────►│    Buffer    │───────────────► │ Consumer │
  │  Thread  │  (互斥：每次只有   │  (同步：      │ (互斥：每次只有  │  Thread  │
  │ 生產資料  │   一個寫入者)      │  Buffer 非空  │  一個讀取者)     │ 消費資料  │
  └──────────┘                    │  才能消費）   │                 └──────────┘
                                  └──────────────┘

  分工：Producer 和 Consumer 各自獨立執行（分工）
  同步：Consumer 等待 Buffer 有資料（同步）
  互斥：Buffer 的讀寫必須互斥，防止資料損毀（互斥）
</code></pre>
<h2 id="跨語言完整範例-2"><a class="header" href="#跨語言完整範例-2">跨語言完整範例</a></h2>
<p>三執行緒 Pipeline（Producer → Buffer → Consumer），展示分工 + 同步 + 互斥。</p>
<h3 id="cpthread--condition-variable"><a class="header" href="#cpthread--condition-variable">C（pthread + condition variable）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define BUFFER_SIZE 8
#define ITEMS 10

int buffer[BUFFER_SIZE];
int head = 0, tail = 0, count = 0;
int done = 0;

pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full  = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;

void *producer(void *arg) {
    for (int i = 0; i &lt; ITEMS; i++) {
        pthread_mutex_lock(&amp;mu);
        while (count == BUFFER_SIZE)
            pthread_cond_wait(&amp;not_full, &amp;mu);
        buffer[tail] = i;
        tail = (tail + 1) % BUFFER_SIZE;
        count++;
        printf("[Producer] put %d\n", i);
        pthread_cond_signal(&amp;not_empty);
        pthread_mutex_unlock(&amp;mu);
    }
    pthread_mutex_lock(&amp;mu);
    done = 1;
    pthread_cond_signal(&amp;not_empty);
    pthread_mutex_unlock(&amp;mu);
    return NULL;
}

void *consumer(void *arg) {
    while (1) {
        pthread_mutex_lock(&amp;mu);
        while (count == 0 &amp;&amp; !done)
            pthread_cond_wait(&amp;not_empty, &amp;mu);
        if (count == 0 &amp;&amp; done) { pthread_mutex_unlock(&amp;mu); break; }
        int val = buffer[head];
        head = (head + 1) % BUFFER_SIZE;
        count--;
        printf("[Consumer] got %d\n", val);
        pthread_cond_signal(&amp;not_full);
        pthread_mutex_unlock(&amp;mu);
    }
    return NULL;
}

int main(void) {
    pthread_t p, c;
    pthread_create(&amp;p, NULL, producer, NULL);
    pthread_create(&amp;c, NULL, consumer, NULL);
    pthread_join(p, NULL);
    pthread_join(c, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -o pipeline pipeline.c -lpthread &amp;&amp; ./pipeline
</code></pre>
<h3 id="cstdthread--condition_variable"><a class="header" href="#cstdthread--condition_variable">C++（std::thread + condition_variable）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;queue&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

const int ITEMS = 10;
std::queue&lt;int&gt; buffer;
std::mutex mu;
std::condition_variable not_empty;
bool producer_done = false;

void producer() {
    for (int i = 0; i &lt; ITEMS; i++) {
        std::unique_lock&lt;std::mutex&gt; lock(mu);
        buffer.push(i);
        std::cout &lt;&lt; "[Producer] put " &lt;&lt; i &lt;&lt; "\n";
        not_empty.notify_one();
    }
    std::unique_lock&lt;std::mutex&gt; lock(mu);
    producer_done = true;
    not_empty.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock&lt;std::mutex&gt; lock(mu);
        not_empty.wait(lock, [] { return !buffer.empty() || producer_done; });
        if (buffer.empty()) break;
        int val = buffer.front(); buffer.pop();
        std::cout &lt;&lt; "[Consumer] got " &lt;&lt; val &lt;&lt; "\n";
    }
}

int main() {
    std::thread p(producer), c(consumer);
    p.join(); c.join();
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o pipeline pipeline.cpp -lpthread &amp;&amp; ./pipeline
</code></pre>
<h3 id="ruststdsyncmpsc-channel"><a class="header" href="#ruststdsyncmpsc-channel">Rust（std::sync::mpsc channel）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

const ITEMS: i32 = 10;

fn main() {
    let (tx, rx) = mpsc::channel::&lt;i32&gt;();

    let producer = thread::spawn(move || {
        for i in 0..ITEMS {
            println!("[Producer] put {}", i);
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(10));
        }
        // tx 在此 drop，channel 自動關閉
    });

    let consumer = thread::spawn(move || {
        for val in rx {   // rx 迭代到 channel 關閉為止
            println!("[Consumer] got {}", val);
        }
        println!("[Consumer] done");
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine--channel"><a class="header" href="#gogoroutine--channel">Go（goroutine + channel）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

const items = 10

func producer(ch chan&lt;- int) {
    for i := 0; i &lt; items; i++ {
        fmt.Printf("[Producer] put %d\n", i)
        ch &lt;- i
        time.Sleep(10 * time.Millisecond)
    }
    close(ch)
}

func consumer(ch &lt;-chan int) {
    for val := range ch {
        fmt.Printf("[Consumer] got %d\n", val)
    }
    fmt.Println("[Consumer] done")
}

func main() {
    ch := make(chan int, 4)  // 緩衝 channel 作為 buffer
    go producer(ch)
    consumer(ch)             // 主 goroutine 當 consumer
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonqueuequeue--threading"><a class="header" href="#pythonqueuequeue--threading">Python（queue.Queue + threading）</a></h3>
<pre><code class="language-python">import queue
import threading

ITEMS = 10
buf: queue.Queue[int] = queue.Queue(maxsize=4)

def producer():
    for i in range(ITEMS):
        buf.put(i)                   # 滿了就阻塞（同步）
        print(f"[Producer] put {i}")
    buf.put(None)                    # 哨兵值通知結束

def consumer():
    while True:
        val = buf.get()              # 空了就阻塞（同步）
        if val is None:
            break
        print(f"[Consumer] got {val}")
    print("[Consumer] done")

if __name__ == "__main__":
    t_prod = threading.Thread(target=producer)
    t_cons = threading.Thread(target=consumer)
    t_prod.start()
    t_cons.start()
    t_prod.join()
    t_cons.join()
</code></pre>
<pre><code class="language-bash">python3 pipeline.py
</code></pre>
<h2 id="完整專案級範例python-2"><a class="header" href="#完整專案級範例python-2">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch03.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch03.py
</code></pre>
<pre><code class="language-python">"""Chapter 03: split work + sync.

展示三大核心問題：
1. 分工：Producer 和 Consumer 各自獨立執行
2. 同步：Consumer 等待 Buffer 有資料（queue.Queue 內建阻塞語意）
3. 互斥：Queue 內部使用鎖保護 Buffer 讀寫
"""
import queue
import threading

buf: queue.Queue[int] = queue.Queue()
barrier = threading.Barrier(3)


def worker(name: str):
    s = 0
    while True:
        try:
            s += buf.get_nowait()
        except queue.Empty:
            break
    print(name, "partial=", s)
    barrier.wait()


if __name__ == "__main__":
    for i in range(1, 11):
        buf.put(i)
    ts = [threading.Thread(target=worker, args=(f"W{i}",)) for i in (1, 2)]
    for t in ts:
        t.start()
    barrier.wait()
    print("all workers reached sync point")
    for t in ts:
        t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4章-本質問題原子性可見性有序性"><a class="header" href="#第4章-本質問題原子性可見性有序性">第4章 本質問題：原子性、可見性、有序性</a></h1>
<h2 id="41-背景對應-411415"><a class="header" href="#41-背景對應-411415">4.1 背景（對應 4.1.1~4.1.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-10"><a class="header" href="#本小節示意圖-10">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["程式從源碼到執行的完整路徑，每個階段都可能引入問題"]
  N2["源碼（Source Code）"]
  N3["int x = 0;"]
  N4["x++;"]
  N5["編譯器優化 潛在問題: 指令重排、死碼刪除"]
  N6["(Compiler) volatile/memory_order 可控制"]
  N7["機器碼 一條 x++ 變成三條指令"]
  N8["(Machine Code) LOAD r1, [x]"]
  N9["ADD r1, 1"]
  N10["STORE [x], r1"]
  N11["CPU 亂序執行 潛在問題: Out-of-Order Execution"]
  N12["(OoOE Pipeline) CPU 可調整指令執行順序提升效率"]
  N13["Store Buffer L1 Cache L2 Cache 潛在問題: 可見性"]
  N14["(寫入緩衝) (核心私有) (核心私有) 一個核心的寫入"]
  N15["對其他核心不立即可見"]
  N16["L3 Cache 所有核心共享，但同步有延遲"]
  N17["Main Memory (RAM) 最終一致，但時序不保證"]
  N18["結論: 你以為的「按順序、立即可見」在並發環境中都是假設！"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N4 --&gt; N5
  N4 --&gt; N6
  N4 --&gt; N7
  N4 --&gt; N8
  N4 --&gt; N9
  N9 --&gt; N10
  N4 --&gt; N11
  N4 --&gt; N12
  N4 --&gt; N13
  N4 --&gt; N14
  N4 --&gt; N15
  N15 --&gt; N16
  N15 --&gt; N17
  N1 --&gt; N18
</code></pre>
<p>CPU、快取、編譯器優化都會讓「你以為的順序」和實際執行不同。</p>
<h2 id="42-原子性對應-421424"><a class="header" href="#42-原子性對應-421424">4.2 原子性（對應 4.2.1~4.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-11"><a class="header" href="#本小節示意圖-11">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["x++ 非原子性拆解（Read-Modify-Write 三步）"]
  N2["高層語義（你寫的）"]
  N3["x++ 看起來是一個操作"]
  N4["實際機器碼（三個獨立步驟）"]
  N5["LOAD(x) ADD(1) STORE(x)"]
  N6["r1 = x r1 = r1+1 x = r1"]
  N7["任何兩步之間都可能被其他執行緒打斷！"]
  N8["兩個執行緒交錯導致丟失更新（Lost Update）"]
  N9["初始狀態: x = 0"]
  N10["時間 Thread T1 Thread T2"]
  N11["t1 ① LOAD r1_T1 = x = 0"]
  N12["t2 ① LOAD r1_T2 = x = 0"]
  N13["t3 ② ADD r1_T1 = 0 + 1 = 1"]
  N14["t4 ② ADD r1_T2 = 0 + 1 = 1"]
  N15["t5 ③ STORE x = r1_T1 = 1"]
  N16["t6 ③ STORE x = r1_T2 = 1"]
  N17["預期結果: x = 2"]
  N18["實際結果: x = 1 T1 的遞增被 T2 覆蓋，一次更新永久丟失！"]
  N19["解法: 原子指令（LOCK XADD / fetch_add）確保三步不可分割"]
  N20["LOCK XADD [x], 1 一條不可分割的原子指令"]
  N21["等價於: 原子地 x = x + 1，中間態對其他 CPU 不可見"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N10 --&gt; N11
  N10 --&gt; N12
  N10 --&gt; N13
  N10 --&gt; N14
  N10 --&gt; N15
  N10 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
</code></pre>
<p><code>x++</code> 不是原子，實際是讀、改、寫三步。</p>
<h2 id="43-可見性對應-431434"><a class="header" href="#43-可見性對應-431434">4.3 可見性（對應 4.3.1~4.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-12"><a class="header" href="#本小節示意圖-12">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["快取不一致導致可見性問題"]
  N2["Core 0 Core 1"]
  N3["Thread T1（寫入方） Thread T2（讀取方）"]
  N4["x = 42; while (x == 0) { }"]
  N5["// 期望讀到 42"]
  N6["L1 Cache L1 Cache"]
  N7["x = 42 (新) x = 0 (舊)"]
  N8["cache coherence 協議 Core1 讀到的是舊值！"]
  N9["（MESI 狀態機） 可能永遠看不到 x=42"]
  N10["需要 memory barrier 刷新"]
  N11["MESI 快取一致性協議狀態"]
  N12["狀態 含義"]
  N13["Modified 本核心有最新值，其他核心的副本無效"]
  N14["Exclusive 只有本核心有此快取行，且與記憶體一致"]
  N15["Shared 多個核心都有此快取行，且與記憶體一致"]
  N16["Invalid 此快取行無效，需要重新從記憶體/其他核心讀取"]
  N17["解法: 使用 volatile（Java）/ atomic store（C++/Rust/Go）"]
  N18["強制寫入時刷到記憶體，讀取時從記憶體重新讀。"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N7 --&gt; N8
  N7 --&gt; N9
  N9 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
</code></pre>
<p>A 執行緒改值，B 不一定立刻看得到，可能讀到舊快取。</p>
<h2 id="44-有序性對應-441444"><a class="header" href="#44-有序性對應-441444">4.4 有序性（對應 4.4.1~4.4.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-13"><a class="header" href="#本小節示意圖-13">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["指令重排導致有序性問題"]
  N2["程式員視角（期望的執行順序）"]
  N3["Writer 執行緒 Reader 執行緒"]
  N4["① data = 42 ③ if (ready == true)"]
  N5["② ready = true ④ print(data) // 期望印出 42"]
  N6["CPU/編譯器重排後（實際可能的執行順序）"]
  N7["Writer 執行緒 Reader 執行緒"]
  N8["② ready = true ① 和 ② 被重排！"]
  N9["①' data = 42 ③ if (ready == true) 看到 ready=true"]
  N10["④ print(data) 但 data 還是舊值！"]
  N11["時間軸視角"]
  N12["時間"]
  N13["Writer: [ready=true] ...... [data=42] 重排後 ready 先寫"]
  N14["Reader: [讀到 ready=true] [讀 data] 此時 data 可能還是 0！"]
  N15["為什麼 CPU 會重排？"]
  N16["CPU 保證: 單執行緒內的語義不變（as-if-serial）"]
  N17["CPU 不保證: 跨執行緒的全域可見順序"]
  N18["data 和 ready 在單執行緒內沒有依賴關係"]
  N19["CPU/編譯器認為可以任意調換順序"]
  N20["解法: Memory Barrier（記憶體屏障）"]
  N21["Writer: data = 42"]
  N22["StoreStore Barrier（禁止跨屏障的寫重排）"]
  N23["ready = true"]
  N24["Reader: if (ready)"]
  N25["LoadLoad Barrier（禁止跨屏障的讀重排）"]
  N26["print(data) 現在保證讀到正確的 data"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N9 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N21 --&gt; N22
  N21 --&gt; N23
  N1 --&gt; N24
  N24 --&gt; N25
  N24 --&gt; N26
</code></pre>
<p>指令可能重排，只要單執行緒語義不變，編譯器就可能調整。</p>
<h2 id="45-綜合解法對應-451452"><a class="header" href="#45-綜合解法對應-451452">4.5 綜合解法（對應 4.5.1~4.5.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-14"><a class="header" href="#本小節示意圖-14">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["三種問題 vs 三種解法對比"]
  N2["解法 原子性 ✓/✗ 可見性 ✓/✗ 有序性 ✓/✗ 適用場景"]
  N3["原子類型 ✓ ✓ 部分✓ 計數器、狀態旗標"]
  N4["(atomic int等) CAS/fetch_add 強制刷新 依 memory_order 無鎖演算法"]
  N5["互斥鎖 ✓ ✓ ✓ 複雜臨界區"]
  N6["(mutex/lock) 鎖保護整段 解鎖時刷新 鎖保證 HB 關係 讀寫都有的情況"]
  N7["記憶體屏障 ✗ ✓ ✓ 底層程式庫開發"]
  N8["(memory_order) 不解決原子性 禁止快取優化 禁止重排 硬體驅動開發"]
  N9["選擇指引"]
  N10["需要原子計數/旗標？"]
  N11["優先選 atomic（零鎖開銷）"]
  N12["臨界區有多個操作需要一起保護？"]
  N13["必須選 mutex（原子類型只能保護單個變數）"]
  N14["寫底層庫、需要精細控制記憶體順序？"]
  N15["結合 atomic + 精確的 memory_order"]
  N16["producer-consumer 資料傳遞？"]
  N17["atomic flag（ready） + 適當 memory_order，或直接用 channel/queue"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N10 --&gt; N11
  N1 --&gt; N12
  N12 --&gt; N13
  N1 --&gt; N14
  N14 --&gt; N15
  N1 --&gt; N16
  N16 --&gt; N17
</code></pre>
<ul>
<li>原子類 + CAS</li>
<li>鎖</li>
<li>記憶體屏障/語言記憶體模型規則</li>
</ul>
<h2 id="示意圖-3"><a class="header" href="#示意圖-3">示意圖</a></h2>
<pre><code class="language-text">完整問題場景（寫端/讀端的可見性與有序性）：

  Writer:
    data = 42;     // Step 1：寫資料
    ready = true;  // Step 2：設旗標

  Reader:
    if (ready)     // Step 3：讀旗標
        print(data) // Step 4：讀資料

  若重排/不可見：可能讀到 ready=true 但 data=舊值（0 或垃圾值）
  解法：ready 使用 atomic，並在 writer 側加 release 屏障，reader 側加 acquire 屏障
</code></pre>
<h2 id="跨語言完整範例-3"><a class="header" href="#跨語言完整範例-3">跨語言完整範例</a></h2>
<p>用 atomic flag 安全地在兩個執行緒間傳遞數據（producer-consumer with ready flag）。</p>
<h3 id="cgcc-__atomic-內建函式"><a class="header" href="#cgcc-__atomic-內建函式">C（GCC __atomic 內建函式）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;unistd.h&gt;

int data = 0;
atomic_int ready = 0;

void *writer(void *arg) {
    data = 42;                                       /* 先寫資料 */
    atomic_store_explicit(&amp;ready, 1,                 /* 再設旗標，release 語意 */
                          memory_order_release);
    return NULL;
}

void *reader(void *arg) {
    while (!atomic_load_explicit(&amp;ready,             /* 等待旗標，acquire 語意 */
                                 memory_order_acquire))
        ;                                            /* 自旋等待 */
    printf("reader got data = %d\n", data);          /* 保證看到 data=42 */
    return NULL;
}

int main(void) {
    pthread_t w, r;
    pthread_create(&amp;r, NULL, reader, NULL);
    usleep(10000);
    pthread_create(&amp;w, NULL, writer, NULL);
    pthread_join(w, NULL);
    pthread_join(r, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -std=c11 -o ready ready.c -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="cstdatomic-with-memory_order"><a class="header" href="#cstdatomic-with-memory_order">C++（std::atomic with memory_order）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;

int data = 0;
std::atomic&lt;bool&gt; ready{false};

void writer() {
    data = 42;                                     // 先寫資料
    ready.store(true, std::memory_order_release);  // release：之前的寫對 acquire 端可見
}

void reader() {
    while (!ready.load(std::memory_order_acquire)) // acquire：保證讀到 writer 的所有寫入
        std::this_thread::yield();
    std::cout &lt;&lt; "reader got data = " &lt;&lt; data &lt;&lt; "\n";
}

int main() {
    std::thread r(reader);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::thread w(writer);
    w.join();
    r.join();
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o ready ready.cpp -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="ruststdsyncatomic-with-ordering"><a class="header" href="#ruststdsyncatomic-with-ordering">Rust（std::sync::atomic with Ordering）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

static mut DATA: i32 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn main() {
    let reader = thread::spawn(|| {
        while !READY.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let val = unsafe { DATA };
        println!("reader got data = {}", val);
    });

    thread::sleep(Duration::from_millis(10));

    let writer = thread::spawn(|| {
        unsafe { DATA = 42; }                       // 先寫資料
        READY.store(true, Ordering::Release);        // release 屏障後設旗標
    });

    writer.join().unwrap();
    reader.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gosyncatomic--channel-作為-ready-信號"><a class="header" href="#gosyncatomic--channel-作為-ready-信號">Go（sync/atomic + channel 作為 ready 信號）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

var (
    data  int32
    ready atomic.Bool
)

func writer() {
    atomic.StoreInt32(&amp;data, 42)  // 寫資料
    ready.Store(true)             // 設旗標（Go atomic 已包含適當 memory barrier）
}

func reader() {
    for !ready.Load() {           // 等待旗標
        time.Sleep(time.Microsecond)
    }
    fmt.Printf("reader got data = %d\n", atomic.LoadInt32(&amp;data))
}

func main() {
    go reader()
    time.Sleep(10 * time.Millisecond)
    go writer()
    time.Sleep(100 * time.Millisecond) // 等兩個 goroutine 完成
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonthreadingevent-作為-ready-信號"><a class="header" href="#pythonthreadingevent-作為-ready-信號">Python（threading.Event 作為 ready 信號）</a></h3>
<pre><code class="language-python">import threading
import time

data = {"value": None}
ready = threading.Event()   # Event 內建 happens-before 語意

def writer():
    data["value"] = 42      # 先寫資料
    ready.set()             # 設旗標（Event.set() 保證可見性）

def reader():
    ready.wait()            # 阻塞等待旗標（比自旋更節省 CPU）
    print(f"reader got data = {data['value']}")

if __name__ == "__main__":
    t_reader = threading.Thread(target=reader)
    t_reader.start()
    time.sleep(0.02)
    t_writer = threading.Thread(target=writer)
    t_writer.start()
    t_writer.join()
    t_reader.join()
</code></pre>
<pre><code class="language-bash">python3 ready.py
</code></pre>
<h2 id="完整專案級範例python-3"><a class="header" href="#完整專案級範例python-3">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch04.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch04.py
</code></pre>
<pre><code class="language-python">"""Chapter 04: visibility/order via event.

展示：
1. Writer 先寫資料，再設旗標（模擬正確的 release 語意）
2. Reader 等待旗標後讀資料（模擬正確的 acquire 語意）
3. threading.Event 內建 happens-before 保證，確保讀到正確值
"""
import threading
import time

ready = threading.Event()
data = {"value": None}


def writer():
    data["value"] = 42      # Step 1：先寫資料
    ready.set()             # Step 2：設旗標（之後的 reader 保證看到 data=42）


def reader():
    ready.wait()            # 等待旗標（阻塞直到 writer 呼叫 set()）
    print("read value =", data["value"])   # 保證印出 42


if __name__ == "__main__":
    t1 = threading.Thread(target=writer)
    t2 = threading.Thread(target=reader)
    t2.start()
    time.sleep(0.02)
    t1.start()
    t1.join()
    t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第5章-原子性底層"><a class="header" href="#第5章-原子性底層">第5章 原子性底層</a></h1>
<h2 id="51-原子性定義"><a class="header" href="#51-原子性定義">5.1 原子性定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-15"><a class="header" href="#本小節示意圖-15">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["原子性定義: 「不可被拆開觀察，要嘛全成功，要嘛回到原狀」"]
  N2["骰子比喻（原子操作的語意）"]
  N3["原子操作（Atomic）"]
  N4["狀態 A 狀態 B"]
  N5["(x=0) 不可見中間態 (x=1)"]
  N6["其他執行緒只能看到 A 或 B，永遠看不到「介於中間的半完成狀態」"]
  N7["✓ 成功"]
  N8["非原子操作（Non-Atomic）: x++ 的危險"]
  N9["非原子操作（x++）"]
  N10["狀態 A 中間態（可被觀察！） 狀態 B"]
  N11["(x=0) (x=1)"]
  N12["① LOAD r1=0 ③ STORE x=1"]
  N13["② ADD r1=r1+1"]
  N14["（r1 在暫存器，"]
  N15["此刻 x 仍是 0）"]
  N16["其他執行緒在 ① 和 ③ 之間可以讀取 x=0 的舊值！"]
  N17["比喻: 銀行轉帳必須是原子的"]
  N18["轉帳 $100: 扣款 A 帳戶 + 入款 B 帳戶"]
  N19["原子（正確）"]
  N20["[A=1000, B=500] [A=900, B=600] 只有這兩種狀態"]
  N21["非原子（危險）"]
  N22["[A=1000, B=500]"]
  N23["↓ 扣款 A"]
  N24["[A=900, B=500] 此刻系統崩潰，$100 憑空消失！"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
</code></pre>
<p>一個操作不可被拆開觀察，要嘛全成，要嘛全不成。</p>
<h2 id="52-cpu-如何做原子對應-521523"><a class="header" href="#52-cpu-如何做原子對應-521523">5.2 CPU 如何做原子（對應 5.2.1~5.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-16"><a class="header" href="#本小節示意圖-16">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["CPU 實現原子操作的三種方式"]
  N2["方式 1: 總線鎖（Bus Lock）—— 老方法，代價高"]
  N3["CPU0 CPU1 CPU2 CPU3"]
  N4["系統匯流排（Bus）"]
  N5["記憶體（RAM）"]
  N6["CPU0 執行 LOCK 指令時"]
  N7["① 拉低 LOCK# 信號線，獨占整條匯流排"]
  N8["② 其他 CPU 的記憶體存取全部被阻塞"]
  N9["③ 完成操作後釋放 LOCK# 信號線"]
  N10["缺點: 鎖住整條匯流排，其他無關的記憶體操作也被阻塞，性能差"]
  N11["方式 2: 快取鎖（Cache Lock）+ MESI 協議 —— 現代主流"]
  N12["CPU0 CPU1"]
  N13["L1 Cache L1 Cache"]
  N14["[x] M [x] I M=Modified, I=Invalid"]
  N15["CPU0 對 x 做原子操作時"]
  N16["① CPU0 將 x 所在的快取行標記為 Modified（獨占修改）"]
  N17["② 通過 MESI 協議，通知 CPU1 其快取行變為 Invalid（無效）"]
  N18["③ CPU0 完成修改後，數據透過快取一致性協議同步"]
  N19["優點: 只鎖定快取行，不鎖整條匯流排，範圍更小、性能更好"]
  N20["限制: 跨快取行（Cache Line Boundary）的操作仍需要總線鎖"]
  N21["方式 3: CAS 指令（Compare-And-Swap）—— 無鎖演算法基石"]
  N22["x86 指令: CMPXCHG（Compare and Exchange）"]
  N23["偽代碼（原子執行，不可被中斷）"]
  N24["atomic {"]
  N25["if (*addr == expected) {"]
  N26["*addr = new_value;"]
  N27["return SUCCESS;"]
  N28["} else {"]
  N29["return FAIL; // 呼叫方通常自旋重試"]
  N30["優點: 無鎖、輕量；缺點: ABA 問題（需加版本號解決）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
  N0 --&gt; N30
</code></pre>
<ul>
<li>總線鎖（老方法）</li>
<li>快取鎖（現代常見）</li>
<li>原子指令（如 CAS）</li>
</ul>
<h2 id="53-互斥鎖模型對應-531532"><a class="header" href="#53-互斥鎖模型對應-531532">5.3 互斥鎖模型（對應 5.3.1~5.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-17"><a class="header" href="#本小節示意圖-17">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["互斥鎖完整生命週期（含 OS 阻塞/喚醒路徑）"]
  N2["Thread 1 時間軸"]
  N3["[正常執行] [lock()] [臨界區工作] [unlock()] [正常執行]"]
  N4["成功獲取鎖（快路徑， 釋放鎖"]
  N5["futex 不陷入核心）"]
  N6["進入臨界區 喚醒等待佇列中的 Thread 2"]
  N7["Thread 2 時間軸（競爭失敗的情況）"]
  N8["[正常執行] [lock()] ░░░░░░░░░░░░░░░░░░░░░░ [臨界區工作]"]
  N9["阻塞等待（OS 掛起 Thread 2） 被喚醒，重新競爭"]
  N10["OS 核心層"]
  N11["futex 系統呼叫"]
  N12["Thread2 進入"]
  N13["等待佇列（睡眠）"]
  N14["Thread1 unlock() 後"]
  N15["OS 喚醒 Thread2"]
  N16["鎖的兩個路徑"]
  N17["快路徑（Fast Path）—— 無競爭"]
  N18["lock() CAS 操作成功 進入臨界區 （不需要 syscall，最快）"]
  N19["慢路徑（Slow Path）—— 有競爭"]
  N20["lock() CAS 失敗 futex_wait（陷入核心）"]
  N21["睡眠等待 被 unlock 方的 futex_wake 喚醒"]
  N22["重新嘗試 CAS 進入臨界區"]
  N23["⚠ 每次 syscall（陷入核心）大約耗時 1000~5000 ns"]
  N24["⚠ 高競爭下鎖的開銷可能超過臨界區本身的工作量"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N3 --&gt; N4
  N3 --&gt; N5
  N3 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N8 --&gt; N12
  N8 --&gt; N13
  N8 --&gt; N14
  N8 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N20 --&gt; N21
  N20 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
</code></pre>
<p>鎖把臨界區包起來，保證同時只有一個執行緒改共享資料。</p>
<h2 id="54-cas"><a class="header" href="#54-cas">5.4 CAS</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-18"><a class="header" href="#本小節示意圖-18">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["CAS（Compare-And-Swap）完整流程"]
  N2["呼叫: CAS(addr, expected=10, new=11)"]
  N3["① Load old value"]
  N4["old = *addr old = 10"]
  N5["② Compare"]
  N6["old == expected? 10 == 10 ?"]
  N7["YES（匹配） NO（不匹配）"]
  N8["③a Swap new value ③b 返回 FAIL"]
  N9["*addr = new = 11 呼叫方重試"]
  N10["返回 SUCCESS"]
  N11["整個步驟由 CPU 原子執行"]
  N12["其他 CPU 看不到中間狀態"]
  N13["CAS 自旋重試模式（無鎖計數器的典型用法）"]
  N14["loop {"]
  N15["old = atomic_load(counter) 讀取當前值"]
  N16["new = old + 1 計算期望新值"]
  N17["if CAS(counter, old, new) { 原子地「確認沒人改過再寫入」"]
  N18["break 成功，退出"]
  N19["// 失敗: 說明 counter 已被其他執行緒改變，重新讀取再試"]
  N20["ABA 問題（CAS 的已知陷阱）"]
  N21["時間 執行緒 T1 執行緒 T2"]
  N22["t1 load: old = A"]
  N23["t2 CAS(A B) 成功，值改為 B"]
  N24["t3 CAS(B A) 成功，值又改回 A"]
  N25["t4 CAS(A C) 成功！ T1 誤以為沒人動過，但其實發生了 A B A"]
  N26["解法: 使用帶版本號的 CAS（如 Java AtomicStampedReference）"]
  N27["CAS(addr, (expected_val, expected_stamp), (new_val, new_stamp + 1))"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N21 --&gt; N22
  N21 --&gt; N23
  N21 --&gt; N24
  N21 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
</code></pre>
<p>先比對舊值，符合才寫入新值，不符合就重試。</p>
<h2 id="示意圖-4"><a class="header" href="#示意圖-4">示意圖</a></h2>
<pre><code class="language-text">CAS 成功/失敗對比：

  初始：counter = 10

  情況 A（CAS 成功）：
  T1: load=10 → CAS(addr, expect=10, new=11) → 10==10 → swap → counter=11 ✓

  情況 B（CAS 失敗，觸發重試）：
  T1: load=10 → [T2 搶先改成 11] → CAS(addr, expect=10, new=11) → 10≠11 → FAIL
  T1: load=11 → CAS(addr, expect=11, new=12) → 11==11 → swap → counter=12 ✓
</code></pre>
<h2 id="跨語言完整範例-4"><a class="header" href="#跨語言完整範例-4">跨語言完整範例</a></h2>
<p>CAS 自旋計數器（多執行緒安全遞增，無鎖實作）。</p>
<h3 id="cgcc-atomic--cas-自旋"><a class="header" href="#cgcc-atomic--cas-自旋">C（GCC atomic + CAS 自旋）</a></h3>
<pre><code class="language-c">#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define ITER    100000

atomic_long counter = 0;

long cas_increment(atomic_long *c) {
    long old, new_val;
    do {
        old = atomic_load_explicit(c, memory_order_relaxed);
        new_val = old + 1;
    } while (!atomic_compare_exchange_weak_explicit(
                 c, &amp;old, new_val,
                 memory_order_release,
                 memory_order_relaxed));
    return new_val;
}

void *worker(void *arg) {
    for (int i = 0; i &lt; ITER; i++)
        cas_increment(&amp;counter);
    return NULL;
}

int main(void) {
    pthread_t tid[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("counter = %ld (expected %d)\n", counter, THREADS * ITER);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -std=c11 -O2 -o cas_counter cas_counter.c -lpthread &amp;&amp; ./cas_counter
</code></pre>
<h3 id="cstdatomic-compare_exchange_weak"><a class="header" href="#cstdatomic-compare_exchange_weak">C++（std::atomic compare_exchange_weak）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;vector&gt;

const int THREADS = 4, ITER = 100000;
std::atomic&lt;long&gt; counter{0};

void cas_increment(std::atomic&lt;long&gt; &amp;c) {
    long old_val = c.load(std::memory_order_relaxed);
    while (!c.compare_exchange_weak(
               old_val, old_val + 1,
               std::memory_order_release,
               std::memory_order_relaxed))
        ;   // old_val 自動被更新為最新值，繼續重試
}

void worker() {
    for (int i = 0; i &lt; ITER; i++)
        cas_increment(counter);
}

int main() {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) ts.emplace_back(worker);
    for (auto &amp;t : ts) t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * ITER &lt;&lt; ")\n";
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -O2 -o cas_counter cas_counter.cpp -lpthread &amp;&amp; ./cas_counter
</code></pre>
<h3 id="rustatomici64--compare_exchange"><a class="header" href="#rustatomici64--compare_exchange">Rust（AtomicI64 + compare_exchange）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicI64, Ordering};
use std::thread;

const THREADS: usize = 4;
const ITER: i64 = 100_000;

fn cas_increment(counter: &amp;AtomicI64) {
    loop {
        let old = counter.load(Ordering::Relaxed);
        match counter.compare_exchange_weak(
            old, old + 1,
            Ordering::Release,
            Ordering::Relaxed,
        ) {
            Ok(_) =&gt; break,
            Err(_) =&gt; continue,   // 失敗，重試（old 已自動更新）
        }
    }
}

fn main() {
    let counter = Arc::new(AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { cas_increment(&amp;c); }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})", counter.load(Ordering::SeqCst), THREADS as i64 * ITER);
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gosyncatomic-compareandswap"><a class="header" href="#gosyncatomic-compareandswap">Go（sync/atomic CompareAndSwap）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

const threads, iter = 4, 100_000

func casIncrement(counter *int64) {
    for {
        old := atomic.LoadInt64(counter)
        if atomic.CompareAndSwapInt64(counter, old, old+1) {
            break   // 成功
        }
        // 失敗：counter 已被其他 goroutine 改變，重試
    }
}

func main() {
    var counter int64
    var wg sync.WaitGroup
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                casIncrement(&amp;counter)
            }
        }()
    }
    wg.Wait()
    fmt.Printf("counter = %d (expected %d)\n", counter, threads*iter)
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="python模擬-casthreadinglock-實作"><a class="header" href="#python模擬-casthreadinglock-實作">Python（模擬 CAS，threading.Lock 實作）</a></h3>
<pre><code class="language-python">import threading

class AtomicInt:
    """模擬 CAS 語意的原子整數（Python 無原生 CAS，用鎖模擬語意）"""
    def __init__(self, value: int = 0):
        self._value = value
        self._lock = threading.Lock()

    def compare_and_swap(self, expected: int, new: int) -&gt; bool:
        with self._lock:
            if self._value == expected:
                self._value = new
                return True
            return False

    def load(self) -&gt; int:
        with self._lock:
            return self._value

def cas_increment(counter: AtomicInt):
    while True:
        old = counter.load()
        if counter.compare_and_swap(old, old + 1):
            break

THREADS, ITER = 4, 100_000
counter = AtomicInt(0)

def worker():
    for _ in range(ITER):
        cas_increment(counter)

if __name__ == "__main__":
    threads = [threading.Thread(target=worker) for _ in range(THREADS)]
    for t in threads: t.start()
    for t in threads: t.join()
    print(f"counter = {counter.load()} (expected {THREADS * ITER})")
</code></pre>
<pre><code class="language-bash">python3 cas_counter.py
</code></pre>
<h2 id="完整專案級範例python-4"><a class="header" href="#完整專案級範例python-4">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch05.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch05.py
</code></pre>
<pre><code class="language-python">"""Chapter 05: atomicity with CAS-like primitive.

展示：
1. CAS（Compare-And-Swap）的語意：比對舊值，符合才寫入新值
2. 多執行緒安全遞增（無鎖計數器模擬）
3. CAS 失敗時重試機制
"""
import threading


class AtomicInt:
    def __init__(self, value: int = 0):
        self._v = value
        self._m = threading.Lock()

    def compare_and_swap(self, expect: int, new: int) -&gt; bool:
        with self._m:
            if self._v == expect:
                self._v = new
                return True
            return False

    def get(self) -&gt; int:
        with self._m:
            return self._v


def cas_increment(a: AtomicInt):
    """CAS 自旋重試直到成功。"""
    while True:
        old = a.get()
        if a.compare_and_swap(old, old + 1):
            break


if __name__ == "__main__":
    a = AtomicInt(10)
    print("cas 10-&gt;11", a.compare_and_swap(10, 11), "now", a.get())
    print("cas 10-&gt;12", a.compare_and_swap(10, 12), "now", a.get())  # 失敗，值已是 11

    # 多執行緒 CAS 計數器
    counter = AtomicInt(0)
    THREADS, ITER = 4, 10000
    ts = [threading.Thread(target=lambda: [cas_increment(counter) for _ in range(ITER)])
          for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"final counter = {counter.get()} (expected {THREADS * ITER})")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第6章-可見性與有序性底層"><a class="header" href="#第6章-可見性與有序性底層">第6章 可見性與有序性底層</a></h1>
<h2 id="61-多級快取對應-611613"><a class="header" href="#61-多級快取對應-611613">6.1 多級快取（對應 6.1.1~6.1.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-19"><a class="header" href="#本小節示意圖-19">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["多核 CPU 多級快取延遲金字塔"]
  N2["CPU Die"]
  N3["Core 0 Core 1"]
  N4["L1 L1"]
  N5["32-64K 32-64K"]
  N6["~4 cy ~4 cy"]
  N7["L2 L2"]
  N8["256K 256K"]
  N9["~12 cy ~12 cy"]
  N10["L3 共享快取"]
  N11["8-32M"]
  N12["~40 cy"]
  N13["RAM 主記憶體"]
  N14["GB 級"]
  N15["~200 cy"]
  N16["磁碟 持久儲存"]
  N17["TB 級"]
  N18["~10M cy"]
  N19["存取延遲對比（越往下越慢）"]
  N20["快取層級 存取延遲 說明"]
  N21["L1 Cache ~4 cycles 每核私有，最快"]
  N22["L2 Cache ~12 cycles 每核私有，較大"]
  N23["L3 Cache ~40 cycles 多核共享"]
  N24["RAM ~200 cycles 通過記憶體匯流排存取"]
  N25["SSD ~100K cycles NVMe 介面"]
  N26["HDD/磁碟 ~10M cycles 機械旋轉延遲"]
  N27["⚠ 重點: Core0 修改的資料在 L1/L2 中，Core1 可能看到舊值"]
  N28["必須靠快取一致性協議保證多副本同步"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N12 --&gt; N13
  N12 --&gt; N14
  N12 --&gt; N15
  N12 --&gt; N16
  N12 --&gt; N17
  N12 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N27 --&gt; N28
</code></pre>
<p>L1/L2/L3 讓 CPU 讀寫更快，但也帶來多副本一致性問題。</p>
<h2 id="62-快取一致性對應-621625"><a class="header" href="#62-快取一致性對應-621625">6.2 快取一致性（對應 6.2.1~6.2.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-20"><a class="header" href="#本小節示意圖-20">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["MESI 協議四狀態轉換圖"]
  N2["狀態定義"]
  N3["M (Modified) 本核修改過，其他核無副本，與 RAM 不同"]
  N4["E (Exclusive) 本核獨有，與 RAM 相同，無其他副本"]
  N5["S (Shared) 多核共有，與 RAM 相同"]
  N6["I (Invalid) 快取行無效，需重新從其他核/RAM 取"]
  N7["狀態機轉換"]
  N8["本核讀命中 E (Exclusive) 本核寫命中"]
  N9["不需總線操作 M (Modified)"]
  N10["其他核讀（Bus Read）"]
  N11["降級共享"]
  N12["M (Modified) S (Shared)"]
  N13["本核寫: 不需 本核寫 多核可同時持有"]
  N14["總線操作 發送 只能讀，不能寫"]
  N15["Invalidate"]
  N16["給其他核"]
  N17["其他核讀時 所有核清除或被替換"]
  N18["回寫 RAM + 降為 S"]
  N19["I (Invalid)"]
  N20["快取行無效，需要重新載入"]
  N21["Core0 寫入流程（從 S M，令 Core1 失效）"]
  N22["時間"]
  N23["1. Core0 和 Core1 都持有 x=10（S 狀態）"]
  N24["Core0 L1: [x=10, S] Core1 L1: [x=10, S]"]
  N25["2. Core0 寫入 x=20"]
  N26["Core0 發送 BusUpgr（Invalidate）給 Core1"]
  N27["Core1 L1: [x=10, I] 標記無效"]
  N28["Core0 L1: [x=20, M] 獨占修改"]
  N29["3. Core1 之後讀 x"]
  N30["發現是 I（Invalid），發出 BusMiss"]
  N31["Core0 攔截，回寫 x=20 到 RAM"]
  N32["Core1 從 RAM 讀 x=20（S 狀態）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N7 --&gt; N8
  N7 --&gt; N9
  N9 --&gt; N10
  N10 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N15 --&gt; N16
  N15 --&gt; N17
  N15 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
  N0 --&gt; N30
  N0 --&gt; N31
  N0 --&gt; N32
</code></pre>
<p>MESI 等協議保證核心間最終一致。</p>
<h2 id="63-偽共享對應-631633"><a class="header" href="#63-偽共享對應-631633">6.3 偽共享（對應 6.3.1~6.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-21"><a class="header" href="#本小節示意圖-21">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["偽共享（False Sharing）問題示意"]
  N2["問題: x 和 y 落在同一個 64-byte 快取行"]
  N3["記憶體布局"]
  N4["64-byte Cache Line"]
  N5["x (8B) y (8B) padding... (48B)"]
  N6["addr 0 addr 8 addr 16~63"]
  N7["Core0 寫 x Core1 寫 y"]
  N8["結果（每次寫都會使對方快取行失效）"]
  N9["Core0 寫 x=1"]
  N10["整條 64B Cache Line 變 M 狀態"]
  N11["發 Invalidate 給 Core1"]
  N12["Core1 的 y 雖然沒動，快取行也失效！"]
  N13["Core1 要讀/寫 y"]
  N14["Cache Miss（因為被 Core0 的寫 x 連帶失效）"]
  N15["必須等 Core0 回寫，再從 RAM 重新載入"]
  N16["效能劇烈下降（可能慢 10~100 倍）"]
  N17["解法 1: 填充（Padding）讓 x 和 y 各占獨立快取行"]
  N18["Cache Line 0 (64B) Cache Line 1 (64B)"]
  N19["x padding 56B y padding 56B"]
  N20["Core0 操作 Core1 操作"]
  N21["Core0 修改 x 只影響 Cache Line 0，不影響 Core1"]
  N22["解法 2: 編譯器對齊屬性"]
  N23["C: __attribute__((aligned(64))) int x;"]
  N24["C++: alignas(64) int x;"]
  N25["Rust: #[repr(align(64))] struct PaddedCell { val: i64 }"]
  N26["Go: 使用 atomic + 手動補位元組到 64B"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N6 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
</code></pre>
<p>不同變數落在同一 cache line，互相拖慢。</p>
<h2 id="64-volatile-類語義對應-641643"><a class="header" href="#64-volatile-類語義對應-641643">6.4 volatile 類語義（對應 6.4.1~6.4.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-22"><a class="header" href="#本小節示意圖-22">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["volatile 可見性語義: 寫前 StoreStore + 讀後 LoadLoad"]
  N2["Thread 1 (Writer) Thread 2 (Reader)"]
  N3["write data = 42 read result = flag"]
  N4["StoreStore Fence LoadLoad Fence"]
  N5["確保 data 寫入先 確保 flag 讀出後"]
  N6["於 flag 寫入可見 才讀 data"]
  N7["write flag = true if flag == true"]
  N8["（volatile write） use data 保證看到 42"]
  N9["可見性保證（flush store buffer）"]
  N10["volatile 的保證與限制"]
  N11["✅ 保證: 每次讀都從主記憶體/快取一致視圖讀取"]
  N12["✅ 保證: 每次寫都立即刷新到主記憶體"]
  N13["✅ 保證: 寫操作對其他執行緒可見（happens-before）"]
  N14["❌ 不保證: 複合操作原子性"]
  N15["volatile int v = 0;"]
  N16["v++; // 等同 v = v + 1，read-modify-write"]
  N17["// 兩個執行緒各自讀 0，都寫 1 遺失更新"]
  N18["四種語言的 volatile 對應"]
  N19["語言 volatile / 可見性 API"]
  N20["C/C++ volatile（只阻止編譯器重排，非執行緒安全）"]
  N21["atomic_store/load（正確做法）"]
  N22["Rust AtomicXxx::store/load(Ordering)"]
  N23["Go sync/atomic.Store/Load"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N8 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
</code></pre>
<p>可見性強，但不保證複合操作原子性。</p>
<h2 id="65-指令重排與屏障對應-651654"><a class="header" href="#65-指令重排與屏障對應-651654">6.5 指令重排與屏障（對應 6.5.1~6.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-23"><a class="header" href="#本小節示意圖-23">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["四種記憶體屏障（Memory Fence）類型"]
  N2["屏障阻止跨越屏障的重排序（時間從上到下）"]
  N3["LoadLoad 確保屏障前的 Load 先於後面的 Load"]
  N4["load A 屏障上方"]
  N5["LL Fence"]
  N6["load B 屏障下方"]
  N7["保證 A 先於 B A 的結果對下方 Load 可見"]
  N8["LoadStore 確保屏障前的 Load 先於後面的Store"]
  N9["load A 通常用於避免載入後的寫被提前"]
  N10["LS Fence"]
  N11["store B"]
  N12["StoreStore 確保屏障前的 Store 先於後面Store"]
  N13["store A 屏障上方"]
  N14["SS Fence"]
  N15["store B 屏障下方"]
  N16["保證 A 先寫出 A 對其他核的可見先於 B"]
  N17["StoreLoad 最重的屏障，確保前面 Store 對所有"]
  N18["（全屏障） 核可見後，才執行後面的 Load"]
  N19["store A 必須刷新 Store Buffer + 清空"]
  N20["SL Fence Invalidate Queue"]
  N21["load B 代價最高，x86 用 MFENCE"]
  N22["Acquire / Release 語義包含的 Fence"]
  N23["Release（寫端）: Acquire（讀端）"]
  N24["普通寫操作 acquire load"]
  N25["普通寫操作"]
  N26["SS Fence LL + LS"]
  N27["LS Fence Fence"]
  N28["release store"]
  N29["普通讀操作"]
  N30["保證 release 前的寫"]
  N31["在 release store 之前可見 保證 acquire 後的讀"]
  N32["在 acquire load 之後"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
  N0 --&gt; N30
  N0 --&gt; N31
  N31 --&gt; N32
</code></pre>
<p>Memory Fence 阻止特定方向的重排。</p>
<h2 id="66-記憶體模型對應-661663"><a class="header" href="#66-記憶體模型對應-661663">6.6 記憶體模型（對應 6.6.1~6.6.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-24"><a class="header" href="#本小節示意圖-24">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["各語言記憶體模型與同步 API 對比"]
  N2["語言 記憶體模型 同步操作 API / 保證"]
  N3["C11/C17 C11 Memory Model atomic_store(relaxed/release/seq_cst)"]
  N4["弱序 + 顯式標注 atomic_load(relaxed/acquire/seq_cst)"]
  N5["atomic_thread_fence(memory_order_*)"]
  N6["C++11+ C++ Memory Model std::atomic&amp;lt;T&amp;gt;::store(memory_order)"]
  N7["與 C11 相近 std::atomic&amp;lt;T&amp;gt;::load(memory_order)"]
  N8["memory_order_{relaxed,acquire,"]
  N9["release,acq_rel,seq_cst}"]
  N10["Rust C++ 相容 AtomicI32::store(val, Ordering::*)"]
  N11["型別系統強制 AtomicI32::load(Ordering::*)"]
  N12["所有權排除競爭 Ordering::{Relaxed,Acquire,"]
  N13["Release,AcqRel,SeqCst}"]
  N14["Go Go Memory Model sync/atomic.Store/Load"]
  N15["較簡單，happens- sync.Mutex / sync.RWMutex"]
  N16["before 為主 channel send/recv（天然同步點）"]
  N17["無顯式 memory_order 選擇"]
  N18["強弱排序光譜"]
  N19["弱序（性能高，推理難） 強序（性能低，推理易）"]
  N20["Relaxed Acquire/Release SeqCst（全序）"]
  N21["（無同步） （happens-before） （全局一致順序）"]
  N22["僅原子性 producer-consumer 計數器、旗標"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
</code></pre>
<p>Java、C++、Rust、Go 都定義了跨執行緒可見性規則。</p>
<h2 id="67-happens-before對應-671679"><a class="header" href="#67-happens-before對應-671679">6.7 happens-before（對應 6.7.1~6.7.9）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-25"><a class="header" href="#本小節示意圖-25">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["happens-before（HB）傳遞鏈示意"]
  N2["執行緒 T1 執行緒 T2"]
  N3["data = 42 HB (HB 傳遞)"]
  N4["HB（程式順序）"]
  N5["unlock(L) HB lock(L)"]
  N6["HB（程式順序）"]
  N7["read data 42 ✅"]
  N8["HB 鏈推導"]
  N9["data = 42"]
  N10["HB（T1 程式順序: 先寫 data 再 unlock）"]
  N11["unlock(L)"]
  N12["HB（同步動作: unlock HB lock 同一把鎖）"]
  N13["lock(L) T2 獲取同一把鎖"]
  N14["HB（T2 程式順序: 先 lock 再讀 data）"]
  N15["read data 保證看到 42（HB 具傳遞性）"]
  N16["建立 happens-before 的常見同步事件"]
  N17["同步事件 HB 關係"]
  N18["unlock(L) HB lock(L)（同一鎖）"]
  N19["volatile write HB volatile read（後發生）"]
  N20["thread.start() HB 執行緒內第一個動作"]
  N21["執行緒最後動作 HB thread.join() 返回"]
  N22["channel send HB channel recv（Go）"]
  N23["release store HB acquire load（C++/Rust）"]
  N24["HB 具有傳遞性: 若 A HB B 且 B HB C，則 A HB C"]
  N25["HB HB"]
  N26["A B C 則 A HB C"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N3 --&gt; N4
  N0 --&gt; N5
  N5 --&gt; N6
  N5 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
</code></pre>
<p>能建立 happens-before 的同步事件，才可推導正確性。</p>
<pre><code class="language-text">unlock(L) happens-before lock(L)
write(x) in T1 before unlock -&gt; T2 lock 後可見
</code></pre>
<h2 id="示意圖-5"><a class="header" href="#示意圖-5">示意圖</a></h2>
<pre><code class="language-text">Core0 write -&gt; StoreBuffer -&gt; L1 -&gt; L2/L3 -&gt; Core1 read
需要一致性協議 + memory order 才能正確觀察
</code></pre>
<h2 id="跨語言完整範例-5"><a class="header" href="#跨語言完整範例-5">跨語言完整範例</a></h2>
<p>主題：release-acquire 語義傳遞數據（producer 設 data 後 release store flag，consumer acquire load flag 後讀 data）</p>
<h3 id="cc11-atomics"><a class="header" href="#cc11-atomics">C（C11 atomics）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch06_c ch06.c
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

static int data = 0;
static atomic_int flag = ATOMIC_VAR_INIT(0);

void *producer(void *arg) {
    data = 42;                                          // 普通寫
    atomic_store_explicit(&amp;flag, 1, memory_order_release); // release
    return NULL;
}

void *consumer(void *arg) {
    int f;
    while ((f = atomic_load_explicit(&amp;flag, memory_order_acquire)) == 0)
        ;                                               // spin acquire
    printf("consumer: data = %d (expected 42)\n", data);
    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, consumer, NULL);
    pthread_create(&amp;t2, NULL, producer, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
</code></pre>
<h3 id="cstdatomic-releaseacquire"><a class="header" href="#cstdatomic-releaseacquire">C++（std::atomic release/acquire）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch06_cpp ch06.cpp
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

static int data = 0;
static std::atomic&lt;int&gt; flag{0};

void producer() {
    data = 42;                                          // 普通寫
    flag.store(1, std::memory_order_release);           // release store
}

void consumer() {
    while (flag.load(std::memory_order_acquire) == 0)  // acquire load
        ;                                               // spin
    std::cout &lt;&lt; "consumer: data = " &lt;&lt; data
              &lt;&lt; " (expected 42)\n";
}

int main() {
    std::thread t1(consumer);
    std::thread t2(producer);
    t1.join();
    t2.join();
}
</code></pre>
<h3 id="rustatomic-releaseacquire"><a class="header" href="#rustatomic-releaseacquire">Rust（Atomic release/acquire）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch06.rs &amp;&amp; ./ch06
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(AtomicI32::new(0));
    let flag = Arc::new(AtomicI32::new(0));

    let (d2, f2) = (Arc::clone(&amp;data), Arc::clone(&amp;flag));
    let producer = thread::spawn(move || {
        d2.store(42, Ordering::Relaxed);               // 普通原子寫
        f2.store(1, Ordering::Release);                // release store
    });

    let (d1, f1) = (Arc::clone(&amp;data), Arc::clone(&amp;flag));
    let consumer = thread::spawn(move || {
        while f1.load(Ordering::Acquire) == 0 {}       // acquire load spin
        println!("consumer: data = {} (expected 42)",
                 d1.load(Ordering::Relaxed));
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<h3 id="gosyncatomic--channel-同步"><a class="header" href="#gosyncatomic--channel-同步">Go（sync/atomic + channel 同步）</a></h3>
<pre><code class="language-go">// 執行：go run ch06.go
package main

import (
	"fmt"
	"sync/atomic"
)

var data int64
var flag atomic.Int32

func main() {
	done := make(chan struct{})

	go func() { // consumer
		for flag.Load() == 0 { // acquire-like（Go atomic 隱含 seq_cst）
		}
		val := atomic.LoadInt64(&amp;data)
		fmt.Printf("consumer: data = %d (expected 42)\n", val)
		close(done)
	}()

	go func() { // producer
		atomic.StoreInt64(&amp;data, 42)
		flag.Store(1) // release-like
	}()

	&lt;-done
}
</code></pre>
<h3 id="pythonthreadingcondition-模擬-releaseacquire"><a class="header" href="#pythonthreadingcondition-模擬-releaseacquire">Python（threading.Condition 模擬 release/acquire）</a></h3>
<pre><code class="language-python"># 執行：python3 ch06.py
import threading

data = 0
flag = False
cv = threading.Condition()

def producer():
    global data, flag
    with cv:
        data = 42       # 設定 payload
        flag = True     # release：通知 consumer
        cv.notify_all()

def consumer():
    with cv:
        while not flag: # acquire：等待 flag
            cv.wait()
        print(f"consumer: data = {data} (expected 42)")

if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start()
    t1.join(); t2.join()
</code></pre>
<h2 id="完整專案級範例python-5"><a class="header" href="#完整專案級範例python-5">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch06.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch06.py
</code></pre>
<pre><code class="language-python">"""Chapter 06: ordering with condition variable."""
import threading

cv = threading.Condition()
ready = False
payload = 0


def producer():
    global ready, payload
    with cv:
        payload = 99
        ready = True
        cv.notify_all()


def consumer():
    with cv:
        while not ready:
            cv.wait()
        print("payload=", payload)


if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start(); t1.join(); t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第7章-synchronized-與-jvm-鎖實作"><a class="header" href="#第7章-synchronized-與-jvm-鎖實作">第7章 synchronized 與 JVM 鎖實作</a></h1>
<h2 id="71-語法層對應-711713"><a class="header" href="#71-語法層對應-711713">7.1 語法層（對應 7.1.1~7.1.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-26"><a class="header" href="#本小節示意圖-26">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["synchronized 三種語法形式與 bytecode 對應"]
  N2["形式 1: 實例方法（鎖 this）"]
  N3["Java 源碼"]
  N4["synchronized void increment() { count++; }"]
  N5["bytecode（ACC_SYNCHRONIZED flag）"]
  N6["方法描述符帶有 ACC_SYNCHRONIZED"]
  N7["JVM 執行前自動 monitorenter(this)"]
  N8["JVM 執行後自動 monitorexit(this)"]
  N9["鎖對象: this（呼叫此方法的實例）"]
  N10["形式 2: 靜態方法（鎖 Class 對象）"]
  N11["Java 源碼"]
  N12["static synchronized void reset() { count = 0; }"]
  N13["bytecode（ACC_STATIC + ACC_SYNCHRONIZED）"]
  N14["JVM 執行前 monitorenter(Counter.class)"]
  N15["JVM 執行後 monitorexit(Counter.class)"]
  N16["鎖對象: Counter.class（JVM 中 Class 對象）"]
  N17["⚠ 與實例鎖不同，互不衝突"]
  N18["形式 3: 程式區塊（鎖指定對象）"]
  N19["Java 源碼"]
  N20["synchronized (lockObj) {"]
  N21["// critical section"]
  N22["bytecode（顯式指令）"]
  N23["0: aload lockObj 將鎖對象壓棧"]
  N24["1: monitorenter 嘗試獲取 monitor"]
  N25["2: ... body ..."]
  N26["3: monitorexit 正常退出釋放"]
  N27["4: (exception path)"]
  N28["5: monitorexit 異常退出也釋放（finally）"]
  N29["鎖對象: lockObj（任意 Object）"]
  N30["三種形式對比"]
  N31["形式 鎖對象 適用場景"]
  N32["實例方法 this 保護實例狀態"]
  N33["靜態方法 ClassName.class 保護靜態狀態"]
  N34["synchronized 塊 指定 Object 精細控制臨界區"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
  N0 --&gt; N30
  N0 --&gt; N31
  N0 --&gt; N32
  N0 --&gt; N33
  N0 --&gt; N34
</code></pre>
<ul>
<li>實例方法鎖 <code>this</code></li>
<li>類方法鎖 <code>Class</code></li>
<li>程式區塊鎖指定對象</li>
</ul>
<h2 id="7273-物件頭與鎖標記對應-721733"><a class="header" href="#7273-物件頭與鎖標記對應-721733">7.2~7.3 物件頭與鎖標記（對應 7.2.1~7.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-27"><a class="header" href="#本小節示意圖-27">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["64-bit JVM 物件頭（Mark Word）布局"]
  N2["Mark Word（64 bit = 8 bytes）在不同鎖狀態下的含義"]
  N3["無鎖狀態（biasable）"]
  N4["hashcode (31b) / unused age 0 0 1"]
  N5["bit 63 7 4b 1b 1b 1b"]
  N6["lock bits = 01"]
  N7["偏向鎖（Biased Lock）"]
  N8["Thread ID (54b) epoch (2b) age 1 0 1"]
  N9["bit 63 10 4b 1b 1b 1b"]
  N10["lock bits = 01, biased=1"]
  N11["輕量鎖（Lightweight Lock，CAS 競爭）"]
  N12["Lock Record 指針（ptr to stack frame）(62b) 0 0"]
  N13["bit 63 2 1b 1b"]
  N14["lock bits = 00"]
  N15["重量鎖（Heavyweight Lock，OS mutex）"]
  N16["Monitor 物件指針（ptr to ObjectMonitor）(62b) 1 0"]
  N17["bit 63 2 1b 1b"]
  N18["lock bits = 10"]
  N19["GC 標記（Marked for GC）"]
  N20["forwarding pointer 1 1"]
  N21["lock bits = 11"]
  N22["lock bits 速查表"]
  N23["lock bits 含義"]
  N24["01 無鎖（biasable=0）或 偏向鎖（biased=1）"]
  N25["00 輕量鎖（CAS LockRecord 指針）"]
  N26["10 重量鎖（Monitor 物件指針）"]
  N27["11 GC 標記中"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N5 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N9 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N13 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N17 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N20 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
</code></pre>
<p>這是 JVM 實作細節：物件頭記錄鎖狀態。</p>
<h2 id="7475-monitor-與-bytecode對應-741754"><a class="header" href="#7475-monitor-與-bytecode對應-741754">7.4~7.5 Monitor 與 bytecode（對應 7.4.1~7.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-28"><a class="header" href="#本小節示意圖-28">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["ObjectMonitor 結構與 monitorenter/exit 流程"]
  N2["ObjectMonitor 內部結構"]
  N3["ObjectMonitor"]
  N4["owner: Thread* 當前持有鎖的執行緒"]
  N5["recursions: int 重入計數器"]
  N6["EntryList: LinkedList&amp;lt;Thread&amp;gt;"]
  N7["（等待獲取鎖的執行緒佇列）"]
  N8["T2 T3 T4"]
  N9["WaitSet: LinkedList&amp;lt;Thread&amp;gt;"]
  N10["（呼叫 wait() 後進入的執行緒集合）"]
  N11["T5 T6"]
  N12["monitorenter 流程"]
  N13["執行緒嘗試 monitorenter"]
  N14["owner == null ?"]
  N15["是 CAS 設定 owner = 自己 成功，進入"]
  N16["否 owner == 自己（重入）?"]
  N17["是 recursions++ 進入"]
  N18["否 加入 EntryList"]
  N19["park()（OS 睡眠）"]
  N20["等待 owner 釋放後被喚醒"]
  N21["monitorexit 流程"]
  N22["執行緒執行 monitorexit"]
  N23["recursions &amp;gt; 0 ?"]
  N24["是 recursions-- 繼續持有"]
  N25["否 owner = null"]
  N26["從 EntryList 選一個執行緒 unpark()"]
  N27["被喚醒的執行緒重新競爭 monitorenter"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
</code></pre>
<p>進入臨界區會走 <code>monitorenter</code>，離開走 <code>monitorexit</code>。</p>
<h2 id="76710-鎖升級與優化對應-76710"><a class="header" href="#76710-鎖升級與優化對應-76710">7.6~7.10 鎖升級與優化（對應 7.6~7.10）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-29"><a class="header" href="#本小節示意圖-29">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["JVM 鎖升級路徑（只能升級，不可降級）"]
  N2["無鎖 lock bits = 01（biased=0）"]
  N3["Unlocked 首次分配物件，等待首次鎖定"]
  N4["首次被某執行緒獲取（無競爭）"]
  N5["在 Mark Word 記錄 Thread ID"]
  N6["偏向鎖 lock bits = 01（biased=1）"]
  N7["Biased Lock CAS 寫入 Thread ID，後續進入免 CAS"]
  N8["優點: 單執行緒場景近乎無鎖效能"]
  N9["觸發條件: 另一個執行緒嘗試獲取"]
  N10["觸發 STW（Stop-The-World）撤銷偏向鎖"]
  N11["輕量鎖 lock bits = 00"]
  N12["Lightweight 在執行緒棧幀建立 Lock Record"]
  N13["Lock CAS 將 Mark Word 指向 Lock Record"]
  N14["優點: 避免 OS mutex，自旋等待"]
  N15["觸發條件: CAS 自旋超過閾值（預設 10 次）"]
  N16["或 等待執行緒數 &amp;gt; 1"]
  N17["重量鎖 lock bits = 10"]
  N18["Heavyweight Mark Word 指向 ObjectMonitor"]
  N19["Lock 使用 OS Mutex（pthread_mutex）"]
  N20["代價最高，但公平，支援 wait/notify"]
  N21["升級觸發條件總結"]
  N22["無鎖 偏向鎖 第一次被任意執行緒獲取"]
  N23["偏向鎖 輕量鎖 第二個執行緒競爭（撤銷偏向）"]
  N24["輕量鎖 重量鎖 自旋 CAS 失敗次數超過閾值"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
</code></pre>
<p>偏向鎖 -&gt; 輕量鎖 -&gt; 重量鎖，競爭越激烈成本越高。</p>
<pre><code class="language-text">低競爭: fast path
高競爭: 進入等待佇列 + 喚醒
</code></pre>
<p>跨語言對應：其他語言沒有 <code>synchronized</code> 關鍵字，但 runtime 也有類似 fast/slow path 優化。</p>
<h2 id="示意圖-6"><a class="header" href="#示意圖-6">示意圖</a></h2>
<pre><code class="language-text">monitor(owner=T1)
queue: T2 -&gt; T3
T1 exit monitor -&gt; wake T2
</code></pre>
<h2 id="跨語言完整範例-6"><a class="header" href="#跨語言完整範例-6">跨語言完整範例</a></h2>
<p>主題：mutex 保護共享計數器（4 個執行緒各加 10000 次，驗證最終結果正確）</p>
<h3 id="cpthread_mutex"><a class="header" href="#cpthread_mutex">C（pthread_mutex）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch07_c ch07.c
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define INCREMENTS 10000

static int counter = 0;
static pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;

void *worker(void *arg) {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        pthread_mutex_lock(&amp;mu);
        counter++;
        pthread_mutex_unlock(&amp;mu);
    }
    return NULL;
}

int main(void) {
    pthread_t threads[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;threads[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("counter = %d (expected %d)\n", counter, THREADS * INCREMENTS);
    pthread_mutex_destroy(&amp;mu);
    return 0;
}
</code></pre>
<h3 id="cstdmutex"><a class="header" href="#cstdmutex">C++（std::mutex）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch07_cpp ch07.cpp
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int THREADS = 4;
constexpr int INCREMENTS = 10000;

static int counter = 0;
static std::mutex mu;

void worker() {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        std::scoped_lock lock(mu);
        counter++;
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; THREADS; i++)
        threads.emplace_back(worker);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * INCREMENTS &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rustmutex"><a class="header" href="#rustmutex">Rust（Mutex<i32>）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch07.rs &amp;&amp; ./ch07
use std::sync::{Arc, Mutex};
use std::thread;

const THREADS: usize = 4;
const INCREMENTS: usize = 10_000;

fn main() {
    let counter = Arc::new(Mutex::new(0i32));
    let mut handles = Vec::new();

    for _ in 0..THREADS {
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..INCREMENTS {
                *counter.lock().unwrap() += 1;
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})",
             *counter.lock().unwrap(),
             THREADS * INCREMENTS);
}</code></pre></pre>
<h3 id="gosyncmutex"><a class="header" href="#gosyncmutex">Go（sync.Mutex）</a></h3>
<pre><code class="language-go">// 執行：go run ch07.go
package main

import (
	"fmt"
	"sync"
)

const (
	threads    = 4
	increments = 10000
)

func main() {
	var (
		counter int
		mu      sync.Mutex
		wg      sync.WaitGroup
	)
	for i := 0; i &lt; threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j &lt; increments; j++ {
				mu.Lock()
				counter++
				mu.Unlock()
			}
		}()
	}
	wg.Wait()
	fmt.Printf("counter = %d (expected %d)\n", counter, threads*increments)
}
</code></pre>
<h3 id="pythonthreadinglock"><a class="header" href="#pythonthreadinglock">Python（threading.Lock）</a></h3>
<pre><code class="language-python"># 執行：python3 ch07.py
import threading

THREADS = 4
INCREMENTS = 10000

counter = 0
lock = threading.Lock()

def worker():
    global counter
    for _ in range(INCREMENTS):
        with lock:
            counter += 1

if __name__ == "__main__":
    ts = [threading.Thread(target=worker) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"counter = {counter} (expected {THREADS * INCREMENTS})")
</code></pre>
<h2 id="完整專案級範例python-6"><a class="header" href="#完整專案級範例python-6">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch07.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch07.py
</code></pre>
<pre><code class="language-python">"""Chapter 07: synchronized equivalent in Python."""
import threading

lock = threading.Lock()
total = 0


def add():
    global total
    for _ in range(10000):
        with lock:
            total += 1


if __name__ == "__main__":
    ts = [threading.Thread(target=add) for _ in range(4)]
    for t in ts: t.start()
    for t in ts: t.join()
    print("total=", total)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第8章-aqs-佇列同步器"><a class="header" href="#第8章-aqs-佇列同步器">第8章 AQS 佇列同步器</a></h1>
<h2 id="81-aqs-核心對應-811812"><a class="header" href="#81-aqs-核心對應-811812">8.1 AQS 核心（對應 8.1.1~8.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-30"><a class="header" href="#本小節示意圖-30">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["AQS（AbstractQueuedSynchronizer）核心結構"]
  N2["AQS 由兩個核心元件組成"]
  N3["AQS 物件"]
  N4["state: int = 0 核心同步狀態（CAS 競爭）"]
  N5["head: Node*"]
  N6["tail: Node*"]
  N7["CLH 雙向等待佇列"]
  N8["head Node(T2) Node(T3)"]
  N9["(dummy) waitStatus waitStatus"]
  N10["Node = SIGNAL = SIGNAL"]
  N11["thread=T2 thread=T3"]
  N12["tail 最後入隊"]
  N13["獨占模式 acquire 流程（以 ReentrantLock.lock 為例）"]
  N14["Thread 呼叫 acquire(1)"]
  N15["tryAcquire() 成功（CAS state: 0 1） 持有鎖"]
  N16["失敗（state != 0，鎖被佔用）"]
  N17["addWaiter(EXCLUSIVE)"]
  N18["建立 Node(thread=自己)，CAS 加入佇列尾部"]
  N19["acquireQueued()"]
  N20["for(;;) {"]
  N21["若前驅是 head 再嘗試 tryAcquire()"]
  N22["若成功 自己成為新 head，退出迴圈"]
  N23["若失敗 前驅設為 SIGNAL"]
  N24["LockSupport.park()（掛起執行緒）"]
  N25["等待 unpark() 喚醒後繼續迴圈"]
  N26["release(1) 時"]
  N27["tryRelease() state 0 unpark(head.next.thread)"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N11 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
</code></pre>
<p>AQS = <code>state</code>（整數狀態）+ FIFO 等待佇列。</p>
<h2 id="82-獨占與共享對應-821824"><a class="header" href="#82-獨占與共享對應-821824">8.2 獨占與共享（對應 8.2.1~8.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-31"><a class="header" href="#本小節示意圖-31">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["獨占模式 vs 共享模式對比"]
  N2["獨占模式（Exclusive）— ReentrantLock"]
  N3["state: 0 1（被獲取） 0（釋放）"]
  N4["時間軸"]
  N5["T1 獲取 T1 釋放"]
  N6["T2 等待 ░░░░░░░░░░░░░░░░░░░░ T2 獲取"]
  N7["T3 等待 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ T3 獲取"]
  N8["state 只有 0 和 1，一次只有一個執行緒在臨界區"]
  N9["tryAcquire: CAS(state, 0, 1) 成功才獲取"]
  N10["tryRelease: state = 0，unpark 下一個等待者"]
  N11["共享模式（Shared）— Semaphore(permits=2)"]
  N12["state: 2（可用名額） 1 0（滿） 1 2"]
  N13["時間軸"]
  N14["T1 獲取(state:2 1) T1 釋放( 2)"]
  N15["T2 獲取(state:1 0) T2 釋放( 1)"]
  N16["T3 等待(state=0) ░░░░░░░░░░░░░░░░ T3 獲取(1 0)"]
  N17["T4 等待(state=0) ░░░░░░░░░░░░░░░░ T4 等待..."]
  N18["tryAcquireShared: state &amp;gt; 0 CAS(state, s, s-1)"]
  N19["tryReleaseShared: CAS(state, s, s+1)"]
  N20["setHeadAndPropagate: 獲取成功後"]
  N21["如果還有名額（state &amp;gt; 0），傳播喚醒後續等待者"]
  N22["T2 獲取成功後"]
  N23["state = 1 &amp;gt; 0 unpark(T3) 傳播"]
  N24["獨占 vs 共享 API 對比"]
  N25["獨占（Exclusive） 共享（Shared）"]
  N26["tryAcquire(arg) tryAcquireShared(arg)"]
  N27["tryRelease(arg) tryReleaseShared(arg)"]
  N28["acquire(arg) acquireShared(arg)"]
  N29["release(arg) releaseShared(arg)"]
  N30["ReentrantLock Semaphore, ReadLock"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
  N0 --&gt; N30
</code></pre>
<ul>
<li>獨占：一次一個（ReentrantLock）</li>
<li>共享：可多個（Semaphore/Read lock）</li>
</ul>
<pre><code class="language-text">state=0 -&gt; acquire 成功 -&gt; state=1
        -&gt; 失敗 -&gt; 入隊等待
</code></pre>
<p>白話例子：一個收銀櫃台（獨占） vs 多個自助結帳機（共享）。</p>
<h2 id="示意圖-7"><a class="header" href="#示意圖-7">示意圖</a></h2>
<pre><code class="language-text">state=1 (held)
wait queue: N1 -&gt; N2 -&gt; N3
release -&gt; unpark N1 -&gt; state 轉移
</code></pre>
<h2 id="跨語言完整範例-7"><a class="header" href="#跨語言完整範例-7">跨語言完整範例</a></h2>
<p>主題：Semaphore 限制最多 N 個並發任務（5 個任務，最多 2 個同時運行）</p>
<h3 id="cposix-sem_t"><a class="header" href="#cposix-sem_t">C（POSIX sem_t）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch08_c ch08.c
#include &lt;semaphore.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define MAX_CONCURRENT 2
#define TASK_COUNT 5

static sem_t sem;

void *task(void *arg) {
    int id = *(int *)arg;
    sem_wait(&amp;sem);                      // acquire（P 操作）
    printf("task %d: running\n", id);
    usleep(50000);                       // 模擬工作 50ms
    printf("task %d: done\n", id);
    sem_post(&amp;sem);                      // release（V 操作）
    return NULL;
}

int main(void) {
    sem_init(&amp;sem, 0, MAX_CONCURRENT);  // 最多 2 個並發
    pthread_t threads[TASK_COUNT];
    int ids[TASK_COUNT];
    for (int i = 0; i &lt; TASK_COUNT; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, task, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASK_COUNT; i++)
        pthread_join(threads[i], NULL);
    sem_destroy(&amp;sem);
    return 0;
}
</code></pre>
<h3 id="cstdcounting_semaphorec20"><a class="header" href="#cstdcounting_semaphorec20">C++（std::counting_semaphore，C++20）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++20 -pthread -o ch08_cpp ch08.cpp
#include &lt;semaphore&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int MAX_CONCURRENT = 2;
constexpr int TASK_COUNT = 5;

static std::counting_semaphore&lt;MAX_CONCURRENT&gt; sem(MAX_CONCURRENT);

void task(int id) {
    sem.acquire();                       // 獲取名額
    std::cout &lt;&lt; "task " &lt;&lt; id &lt;&lt; ": running\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    std::cout &lt;&lt; "task " &lt;&lt; id &lt;&lt; ": done\n";
    sem.release();                       // 釋放名額
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; TASK_COUNT; i++)
        threads.emplace_back(task, i);
    for (auto &amp;t : threads) t.join();
}
</code></pre>
<h3 id="rustsemaphore-via-arcmutex"><a class="header" href="#rustsemaphore-via-arcmutex">Rust（Semaphore via Arc&lt;Mutex<i32>&gt;）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch08.rs &amp;&amp; ./ch08
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use std::time::Duration;

const MAX_CONCURRENT: i32 = 2;
const TASK_COUNT: usize = 5;

fn main() {
    // 用 Mutex&lt;i32&gt; + Condvar 模擬 Semaphore
    let pair = Arc::new((Mutex::new(MAX_CONCURRENT), Condvar::new()));
    let mut handles = Vec::new();

    for id in 0..TASK_COUNT {
        let pair = Arc::clone(&amp;pair);
        handles.push(thread::spawn(move || {
            let (lock, cvar) = &amp;*pair;
            // acquire
            let mut count = lock.lock().unwrap();
            while *count == 0 {
                count = cvar.wait(count).unwrap();
            }
            *count -= 1;
            drop(count);

            println!("task {}: running", id);
            thread::sleep(Duration::from_millis(50));
            println!("task {}: done", id);

            // release
            *lock.lock().unwrap() += 1;
            cvar.notify_one();
        }));
    }
    for h in handles { h.join().unwrap(); }
}</code></pre></pre>
<h3 id="gochannel-作為-semaphore"><a class="header" href="#gochannel-作為-semaphore">Go（channel 作為 Semaphore）</a></h3>
<pre><code class="language-go">// 執行：go run ch08.go
package main

import (
	"fmt"
	"sync"
	"time"
)

const (
	maxConcurrent = 2
	taskCount     = 5
)

func main() {
	sem := make(chan struct{}, maxConcurrent) // 緩衝 channel 作 Semaphore
	var wg sync.WaitGroup

	for i := 0; i &lt; taskCount; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			sem &lt;- struct{}{}              // acquire（放入代表佔用名額）
			fmt.Printf("task %d: running\n", id)
			time.Sleep(50 * time.Millisecond)
			fmt.Printf("task %d: done\n", id)
			&lt;-sem                          // release（取出代表釋放名額）
		}(i)
	}
	wg.Wait()
}
</code></pre>
<h3 id="pythonthreadingsemaphore"><a class="header" href="#pythonthreadingsemaphore">Python（threading.Semaphore）</a></h3>
<pre><code class="language-python"># 執行：python3 ch08.py
import threading
import time

MAX_CONCURRENT = 2
TASK_COUNT = 5

sem = threading.Semaphore(MAX_CONCURRENT)

def task(task_id):
    with sem:                            # acquire / release 自動管理
        print(f"task {task_id}: running")
        time.sleep(0.05)
        print(f"task {task_id}: done")

if __name__ == "__main__":
    ts = [threading.Thread(target=task, args=(i,)) for i in range(TASK_COUNT)]
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<h2 id="完整專案級範例python-7"><a class="header" href="#完整專案級範例python-7">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch08.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch08.py
</code></pre>
<pre><code class="language-python">"""Chapter 08: queue synchronizer flavor via semaphore."""
import threading
import time

sem = threading.Semaphore(2)


def task(i: int):
    with sem:
        print(f"task {i} enter")
        time.sleep(0.05)
        print(f"task {i} leave")


if __name__ == "__main__":
    ts = [threading.Thread(target=task, args=(i,)) for i in range(5)]
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第9章-lock-家族"><a class="header" href="#第9章-lock-家族">第9章 Lock 家族</a></h1>
<h2 id="91-顯式鎖"><a class="header" href="#91-顯式鎖">9.1 顯式鎖</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-32"><a class="header" href="#本小節示意圖-32">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["顯式鎖三種獲取路徑對比"]
  N2["lock(): 無限等待，不可中斷"]
  N3["thread.lock()"]
  N4["嘗試獲取鎖 成功 進入臨界區"]
  N5["失敗（鎖被佔用）"]
  N6["park()（永久等待）"]
  N7["⚠ 即使收到 interrupt()，仍然繼續等待"]
  N8["只有鎖被釋放後才被 unpark 喚醒"]
  N9["優點: 簡單 缺點: 可能永久阻塞"]
  N10["tryLock(timeout): 超時等待"]
  N11["lock = thread.tryLock(1, TimeUnit.SECONDS)"]
  N12["嘗試獲取鎖 成功 進入臨界區"]
  N13["失敗，記錄 deadline"]
  N14["park(timeout)"]
  N15["等待期間"]
  N16["被喚醒（鎖釋放） 重試 tryLock"]
  N17["超時 返回 false，不進臨界區"]
  N18["interrupt 拋 InterruptedException"]
  N19["優點: 避免永久阻塞 缺點: 需處理返回值"]
  N20["lockInterruptibly(): 可中斷等待"]
  N21["thread.lockInterruptibly()"]
  N22["嘗試獲取鎖 成功 進入臨界區"]
  N23["失敗，進入佇列等待"]
  N24["parkInterruptibly()"]
  N25["等待期間"]
  N26["被喚醒（鎖釋放） 重試獲取"]
  N27["interrupt 立即拋 InterruptedException"]
  N28["從等待佇列移除，不再等待"]
  N29["優點: 可取消 缺點: 呼叫者必須處理異常"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
</code></pre>
<p>比 <code>synchronized</code> 更可控：可中斷、可超時、可嘗試。</p>
<h2 id="92-公平與非公平對應-921926"><a class="header" href="#92-公平與非公平對應-921926">9.2 公平與非公平（對應 9.2.1~9.2.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-33"><a class="header" href="#本小節示意圖-33">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["公平鎖 vs 非公平鎖競爭示意"]
  N2["公平鎖（Fair Lock）— 嚴格 FIFO 順序"]
  N3["等待佇列: T2 T3 T4（依入隊順序）"]
  N4["T1 釋放鎖"]
  N5["只喚醒佇列頭部"]
  N6["T2 獲取鎖（FIFO 頭部）"]
  N7["此時 T5 剛好到達"]
  N8["T5 發現佇列不空 直接入隊尾部（不搶）"]
  N9["等待佇列: T3 T4 T5"]
  N10["✅ 優點: 無飢餓，等待時間可預期"]
  N11["❌ 缺點: 每次都要喚醒掛起執行緒（吞吐較低）"]
  N12["非公平鎖（Non-Fair Lock）— 先搶再排"]
  N13["等待佇列: T2 T3 T4（已在等待）"]
  N14["T1 釋放鎖"]
  N15["喚醒佇列頭部 T2，同時..."]
  N16["此時 T5 剛好到達"]
  N17["T5 先嘗試 CAS(state, 0, 1)"]
  N18["若 CAS 成功 T5 直接獲取！（T2 繼續等）"]
  N19["若 CAS 失敗 T5 才入隊尾部"]
  N20["✅ 優點: 減少上下文切換（T5 不必 park/unpark）"]
  N21["❌ 缺點: 佇列中的執行緒可能被後來者插隊（飢餓）"]
  N22["效能對比"]
  N23["非公平鎖吞吐量通常比公平鎖高 2~10 倍（視競爭程度）"]
  N24["ReentrantLock 預設是非公平鎖"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
</code></pre>
<p>公平降低飢餓但吞吐可能較低；非公平吞吐高但可能插隊。</p>
<h2 id="93-悲觀與樂觀對應-931934"><a class="header" href="#93-悲觀與樂觀對應-931934">9.3 悲觀與樂觀（對應 9.3.1~9.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-34"><a class="header" href="#本小節示意圖-34">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["悲觀鎖 vs 樂觀鎖（CAS）流程對比"]
  N2["悲觀鎖（Pessimistic Lock）— 假設衝突必然發生"]
  N3["lock() 先鎖定資源（阻塞其他執行緒）"]
  N4["read data 讀取資料（安全，因為已鎖定）"]
  N5["write data 修改資料"]
  N6["unlock() 釋放鎖"]
  N7["適用: 衝突頻率高、臨界區長、寫操作多"]
  N8["樂觀鎖（Optimistic Lock）— 假設衝突很少，先做再驗"]
  N9["read data + version 讀值 + 記版本號（無鎖）"]
  N10["compute new val 計算新值（無鎖執行）"]
  N11["CAS(addr, old_val, new_val)"]
  N12["且"]
  N13["version 比較（version == old_version）"]
  N14["CAS 成功 CAS 失敗（有衝突）"]
  N15["version++ 重新 read + retry"]
  N16["操作完成 ↑"]
  N17["適用: 衝突頻率低、臨界區短、讀操作多"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
</code></pre>
<p>衝突高用悲觀鎖，衝突低可走 CAS/版本號。</p>
<h2 id="94-可中斷對應-941944"><a class="header" href="#94-可中斷對應-941944">9.4 可中斷（對應 9.4.1~9.4.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-35"><a class="header" href="#本小節示意圖-35">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["可中斷等待 vs 不可中斷等待對比"]
  N2["lock(): 不可中斷（忽略 interrupt）"]
  N3["Thread T_wait Thread T_other"]
  N4["lock()（鎖被佔用）"]
  N5["park()...（掛起等待）"]
  N6["T_wait.interrupt()"]
  N7["中斷標記設為 true"]
  N8["但 lock() 繼續等待！"]
  N9["⚠ 不拋異常，繼續 park"]
  N10["直到鎖釋放才 unpark"]
  N11["獲取鎖後才能檢查中斷標記"]
  N12["lockInterruptibly(): 可中斷"]
  N13["Thread T_wait Thread T_other"]
  N14["lockInterruptibly()"]
  N15["（鎖被佔用）進入等待佇列"]
  N16["parkInterruptibly()..."]
  N17["T_wait.interrupt()"]
  N18["↓ 被喚醒（因 interrupt）"]
  N19["拋出 InterruptedException"]
  N20["從等待佇列移除"]
  N21["執行緒可以執行取消/清理邏輯"]
  N22["使用場景: 可取消的任務、避免死鎖、實作超時"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
</code></pre>
<p>等待鎖時可取消，避免永久卡死。</p>
<h2 id="95-獨占共享對應-951954"><a class="header" href="#95-獨占共享對應-951954">9.5 獨占/共享（對應 9.5.1~9.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-36"><a class="header" href="#本小節示意圖-36">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["獨占鎖 vs 共享鎖 相容矩陣"]
  N2["持有讀鎖中 持有寫鎖中"]
  N3["新執行緒申請讀鎖 ✅ 允許（共享） ❌ 阻塞"]
  N4["新執行緒申請寫鎖 ❌ 阻塞 ❌ 阻塞"]
  N5["說明"]
  N6["讀鎖（共享）"]
  N7["• 多個執行緒可同時持有讀鎖"]
  N8["• 適合唯讀操作，不修改資料"]
  N9["• 相容性: 讀-讀 允許 / 讀-寫 不允許"]
  N10["寫鎖（獨占）"]
  N11["• 只有一個執行緒可持有寫鎖"]
  N12["• 持有期間排斥所有讀鎖和寫鎖"]
  N13["• 相容性: 寫-讀 不允許 / 寫-寫 不允許"]
  N14["AQS state 編碼（ReadWriteLock）"]
  N15["32-bit state"]
  N16["高 16 位: 讀鎖計數（讀者數量）"]
  N17["低 16 位: 寫鎖計數（重入次數）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
</code></pre>
<p>不同資源特性選不同模型。</p>
<h2 id="96-可重入對應-961962"><a class="header" href="#96-可重入對應-961962">9.6 可重入（對應 9.6.1~9.6.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-37"><a class="header" href="#本小節示意圖-37">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["可重入鎖（Reentrant Lock）計數器機制"]
  N2["場景: T1 持有鎖後呼叫遞迴方法，需要再次獲取同一把鎖"]
  N3["Thread T1 state 計數器"]
  N4["1. lock() state = 0"]
  N5["CAS(state, 0, 1) 成功 state = 1"]
  N6["owner = T1"]
  N7["2. 呼叫 methodA()"]
  N8["3. lock()（重入） state = 1"]
  N9["owner == T1（自己） 直接重入 state = 2"]
  N10["recursions++"]
  N11["4. 呼叫 methodB()（繼續重入）"]
  N12["lock() state = 2"]
  N13["owner == T1 直接重入 state = 3"]
  N14["5. methodB 完成"]
  N15["unlock() state = 3"]
  N16["recursions-- state = 2"]
  N17["6. methodA 完成"]
  N18["unlock() state = 2"]
  N19["recursions-- state = 1"]
  N20["7. 最外層完成"]
  N21["unlock() state = 1"]
  N22["state = 0，owner = null state = 0 ✅"]
  N23["喚醒等待的執行緒"]
  N24["⚠ 若不可重入: 步驟 3 會死鎖（等自己釋放鎖）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
</code></pre>
<p>同執行緒可重複拿同一把鎖，靠計數器解決遞迴鎖死。</p>
<h2 id="97-讀寫鎖對應-971976"><a class="header" href="#97-讀寫鎖對應-971976">9.7 讀寫鎖（對應 9.7.1~9.7.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-38"><a class="header" href="#本小節示意圖-38">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["讀寫鎖時間軸示意"]
  N2["時間軸（從左到右）"]
  N3["R1: 讀者1"]
  N4["R2: 讀者2（與R1並發）"]
  N5["R3: 讀者3（與R1/R2並發）"]
  N6["W1: ░░░░░░ 寫者1（等待R1/R2/R3結束）"]
  N7["等待 ↑ 進入臨界區"]
  N8["R4: （W1 等待期間到來） ░░░░░░░░ 可能被 W1 擋住（防寫者飢餓）"]
  N9["R5: ░░░ W1 完成後 R4/R5 可進入"]
  N10["規則"]
  N11["✅ 多個讀者同時進入（無寫者時）"]
  N12["✅ 寫者獨占（進入時排除所有讀者和其他寫者）"]
  N13["⚠ 寫者等待所有現有讀者完成才能進入"]
  N14["⚠ 有等待寫者時，新讀者可能被阻止（防飢餓策略）"]
  N15["狀態轉換"]
  N16["當前狀態 申請讀鎖 申請寫鎖"]
  N17["無鎖 立即獲取 立即獲取"]
  N18["讀鎖（1+個） 立即獲取 阻塞等待所有讀者退出"]
  N19["寫鎖（1個） 阻塞等待 阻塞（除非重入）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N6 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
</code></pre>
<p>讀多寫少場景常見，讀可併發、寫需獨占。</p>
<h2 id="98-parkunpark對應-981982"><a class="header" href="#98-parkunpark對應-981982">9.8 park/unpark（對應 9.8.1~9.8.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-39"><a class="header" href="#本小節示意圖-39">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["LockSupport.park / unpark 原語"]
  N2["執行緒狀態轉換"]
  N3["Thread T"]
  N4["RUNNABLE"]
  N5["LockSupport.park()"]
  N6["WAITING 執行緒掛起，不消耗 CPU"]
  N7["（操作系統層面: futex/pthread_cond_wait）"]
  N8["LockSupport.unpark(T) 任意執行緒可呼叫"]
  N9["RUNNABLE 繼續執行 park() 之後的程式碼"]
  N10["park / unpark 特殊語義（permit 模型）"]
  N11["每個執行緒有一個「permit」（0 或 1）"]
  N12["unpark(T)"]
  N13["• 若 T 在等待 立即喚醒 T，permit 保持 0"]
  N14["• 若 T 未等待 permit 設為 1（預存）"]
  N15["park()"]
  N16["• 若 permit = 1 立即返回（消耗 permit 設為 0）"]
  N17["• 若 permit = 0 掛起等待"]
  N18["結果: unpark 可以在 park 之前呼叫，不會丟失喚醒信號"]
  N19["與 wait/notify 對比"]
  N20["特性 wait/notify park/unpark"]
  N21["需要鎖 是（必須在 否（任何地方"]
  N22["synchronized 中） 都可呼叫）"]
  N23["喚醒特定執行緒 否（notify 隨機） 是（指定 T）"]
  N24["先喚醒後等待 信號丟失 permit 保存"]
  N25["虛假喚醒 需要 while 迴圈 也需要檢查"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N4 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N7 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
</code></pre>
<p>底層掛起/喚醒原語。</p>
<h2 id="示意圖-8"><a class="header" href="#示意圖-8">示意圖</a></h2>
<pre><code class="language-text">讀寫鎖:
Readers: R1 R2 R3 可同時進
Writer : W 需要獨占，等所有 Reader 離開
</code></pre>
<h2 id="跨語言完整範例-8"><a class="header" href="#跨語言完整範例-8">跨語言完整範例</a></h2>
<p>主題：讀寫鎖保護 map（3 個 reader 並發讀，1 個 writer 定期寫）</p>
<h3 id="cpthread_rwlock"><a class="header" href="#cpthread_rwlock">C（pthread_rwlock）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch09_c ch09.c
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define READERS 3

static int shared_data = 0;
static pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

void *reader(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i &lt; 3; i++) {
        pthread_rwlock_rdlock(&amp;rwlock);       // 讀鎖（多讀者可並發）
        printf("reader %d: data = %d\n", id, shared_data);
        usleep(20000);
        pthread_rwlock_unlock(&amp;rwlock);
        usleep(10000);
    }
    return NULL;
}

void *writer(void *arg) {
    for (int i = 1; i &lt;= 3; i++) {
        usleep(30000);
        pthread_rwlock_wrlock(&amp;rwlock);       // 寫鎖（獨占）
        shared_data = i * 10;
        printf("writer: data set to %d\n", shared_data);
        pthread_rwlock_unlock(&amp;rwlock);
    }
    return NULL;
}

int main(void) {
    pthread_t readers[READERS], wr;
    int ids[READERS];
    for (int i = 0; i &lt; READERS; i++) {
        ids[i] = i;
        pthread_create(&amp;readers[i], NULL, reader, &amp;ids[i]);
    }
    pthread_create(&amp;wr, NULL, writer, NULL);
    for (int i = 0; i &lt; READERS; i++) pthread_join(readers[i], NULL);
    pthread_join(wr, NULL);
    pthread_rwlock_destroy(&amp;rwlock);
    return 0;
}
</code></pre>
<h3 id="cstdshared_mutex"><a class="header" href="#cstdshared_mutex">C++（std::shared_mutex）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch09_cpp ch09.cpp
#include &lt;shared_mutex&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

static int shared_data = 0;
static std::shared_mutex rw;

void reader(int id) {
    for (int i = 0; i &lt; 3; i++) {
        std::shared_lock lock(rw);            // 共享讀鎖
        std::cout &lt;&lt; "reader " &lt;&lt; id &lt;&lt; ": data = " &lt;&lt; shared_data &lt;&lt; "\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }
}

void writer() {
    for (int i = 1; i &lt;= 3; i++) {
        std::this_thread::sleep_for(std::chrono::milliseconds(30));
        std::unique_lock lock(rw);            // 獨占寫鎖
        shared_data = i * 10;
        std::cout &lt;&lt; "writer: data set to " &lt;&lt; shared_data &lt;&lt; "\n";
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 3; i++)
        threads.emplace_back(reader, i);
    threads.emplace_back(writer);
    for (auto &amp;t : threads) t.join();
}
</code></pre>
<h3 id="rustrwlock"><a class="header" href="#rustrwlock">Rust（RwLock<i32>）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch09.rs &amp;&amp; ./ch09
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

fn main() {
    let data = Arc::new(RwLock::new(0i32));
    let mut handles = Vec::new();

    // 3 個讀者
    for id in 0..3 {
        let data = Arc::clone(&amp;data);
        handles.push(thread::spawn(move || {
            for _ in 0..3 {
                let val = data.read().unwrap();  // 共享讀鎖
                println!("reader {}: data = {}", id, *val);
                drop(val);
                thread::sleep(Duration::from_millis(10));
            }
        }));
    }

    // 1 個寫者
    let data = Arc::clone(&amp;data);
    handles.push(thread::spawn(move || {
        for i in 1..=3 {
            thread::sleep(Duration::from_millis(30));
            *data.write().unwrap() = i * 10;    // 獨占寫鎖
            println!("writer: data set to {}", i * 10);
        }
    }));

    for h in handles { h.join().unwrap(); }
}</code></pre></pre>
<h3 id="gosyncrwmutex"><a class="header" href="#gosyncrwmutex">Go（sync.RWMutex）</a></h3>
<pre><code class="language-go">// 執行：go run ch09.go
package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	sharedData int
	rw         sync.RWMutex
)

func reader(id int, wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 0; i &lt; 3; i++ {
		rw.RLock()                              // 共享讀鎖
		fmt.Printf("reader %d: data = %d\n", id, sharedData)
		time.Sleep(20 * time.Millisecond)
		rw.RUnlock()
		time.Sleep(10 * time.Millisecond)
	}
}

func writer(wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 1; i &lt;= 3; i++ {
		time.Sleep(30 * time.Millisecond)
		rw.Lock()                               // 獨占寫鎖
		sharedData = i * 10
		fmt.Printf("writer: data set to %d\n", sharedData)
		rw.Unlock()
	}
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i &lt; 3; i++ {
		wg.Add(1)
		go reader(i, &amp;wg)
	}
	wg.Add(1)
	go writer(&amp;wg)
	wg.Wait()
}
</code></pre>
<h3 id="pythonthreadingrlock--手動讀寫鎖"><a class="header" href="#pythonthreadingrlock--手動讀寫鎖">Python（threading.RLock + 手動讀寫鎖）</a></h3>
<pre><code class="language-python"># 執行：python3 ch09.py
import threading
import time

shared_data = 0
rw = threading.Lock()          # 寫者用
read_count = 0
read_count_lock = threading.Lock()

def reader(reader_id):
    global read_count
    for _ in range(3):
        with read_count_lock:
            read_count += 1
            if read_count == 1:
                rw.acquire()   # 第一個讀者鎖定寫者
        print(f"reader {reader_id}: data = {shared_data}")
        time.sleep(0.02)
        with read_count_lock:
            read_count -= 1
            if read_count == 0:
                rw.release()   # 最後一個讀者釋放寫者鎖

def writer():
    global shared_data
    for i in range(1, 4):
        time.sleep(0.03)
        with rw:               # 獨占寫鎖
            shared_data = i * 10
            print(f"writer: data set to {shared_data}")

if __name__ == "__main__":
    ts = [threading.Thread(target=reader, args=(i,)) for i in range(3)]
    ts.append(threading.Thread(target=writer))
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<h2 id="完整專案級範例python-8"><a class="header" href="#完整專案級範例python-8">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch09.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch09.py
</code></pre>
<pre><code class="language-python">"""Chapter 09: lock family (Lock/RLock/Condition)."""
import threading

rlock = threading.RLock()
cond = threading.Condition(rlock)
ready = False


def producer():
    global ready
    with rlock:
        ready = True
        cond.notify_all()


def consumer():
    with rlock:
        while not ready:
            cond.wait()
        print("consumer got signal")


if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start(); t1.join(); t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第10章-cas"><a class="header" href="#第10章-cas">第10章 CAS</a></h1>
<h2 id="101-cas-基本模型"><a class="header" href="#101-cas-基本模型">10.1 CAS 基本模型</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-40"><a class="header" href="#本小節示意圖-40">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["CAS（Compare-And-Swap）基本模型"]
  N2["函數語義"]
  N3["bool CAS(addr, expected, new_val) {"]
  N4["if (*addr == expected) {"]
  N5["*addr = new_val;"]
  N6["return true; // 交換成功"]
  N7["} else {"]
  N8["return false; // 交換失敗（值已被改）"]
  N9["⚠ 上面的 if-then 是原子執行，不可被打斷"]
  N10["執行流程示意"]
  N11["記憶體位址 addr"]
  N12["*addr = 10（當前值）"]
  N13["CAS(addr, expected=10, new_val=20)"]
  N14["原子比較: *addr(10) == expected(10) ?"]
  N15["是（成功路徑）"]
  N16["*addr = 20"]
  N17["return true ✅"]
  N18["*addr = 20"]
  N19["否（失敗路徑，*addr 已被其他執行緒改為 15）"]
  N20["return false ❌"]
  N21["呼叫者需要重新讀取並重試"]
  N22["硬體層: CMPXCHG 指令（x86）"]
  N23["LOCK CMPXCHG [mem], reg"]
  N24["LOCK 前綴: 鎖定快取行/記憶體匯流排"]
  N25["比較 EAX 與 [mem]"]
  N26["相等 [mem] = reg（ZF=1）"]
  N27["不等 EAX = [mem]（ZF=0，讓呼叫者重試）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
</code></pre>
<p>Compare-And-Swap：比較並交換。</p>
<h2 id="102-底層支持對應-10211022"><a class="header" href="#102-底層支持對應-10211022">10.2 底層支持（對應 10.2.1~10.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-41"><a class="header" href="#本小節示意圖-41">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Intel x86 LOCK CMPXCHG vs ARM LL/SC"]
  N2["Intel x86 — LOCK CMPXCHG（單條原子指令）"]
  N3["CPU 執行 LOCK CMPXCHG"]
  N4["Step 1: LOCK 前綴"]
  N5["鎖定對應快取行（Cache Line Lock）"]
  N6["或在多 CPU 系統鎖定記憶體匯流排"]
  N7["Step 2: 原子比較"]
  N8["compare EAX（expected）with [mem]"]
  N9["相等 exchange [mem] = new_reg"]
  N10["ZF = 1（表示成功）"]
  N11["不等 EAX = [mem]（取回現值）"]
  N12["ZF = 0（表示失敗）"]
  N13["Step 3: UNLOCK"]
  N14["釋放快取行/匯流排鎖"]
  N15["整個過程不可中斷，其他 CPU 必須等待"]
  N16["ARM — LL/SC（Load-Link / Store-Conditional，可能重試）"]
  N17["retry"]
  N18["LDREX r0, [addr] Load-Link"]
  N19["記錄 addr 的「獨占監視器」標記"]
  N20["r0 = *addr（讀取當前值）"]
  N21["計算新值"]
  N22["r1 = r0 + 1"]
  N23["STREX result, r1, [addr] Store-Conditional"]
  N24["若獨占監視器標記仍有效（無其他寫入）"]
  N25["寫入成功: *addr = r1，result = 0"]
  N26["寫入失敗: result = 1（有其他 CPU 寫入）"]
  N27["result == 0 result == 1"]
  N28["成功，完成 失敗，回到 retry"]
  N29["LL/SC 通過重試避免總線鎖，對多核效能更友好"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
</code></pre>
<p>依賴 CPU 原子指令；Java <code>Unsafe/VarHandle</code>、C++ <code>atomic</code>、Rust <code>Atomic*</code>、Go <code>sync/atomic</code>。</p>
<h2 id="103-cas-實作計數器對應-10311033"><a class="header" href="#103-cas-實作計數器對應-10311033">10.3 CAS 實作計數器（對應 10.3.1~10.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-42"><a class="header" href="#本小節示意圖-42">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["CAS 自旋計數器流程"]
  N2["單次遞增流程（樂觀自旋）"]
  N3["Step 1: load old = *counter"]
  N4["讀取當前值（此時 counter = 5）"]
  N5["old = 5"]
  N6["Step 2: new = old + 1 = 6"]
  N7["計算新值（純粹計算，無競爭）"]
  N8["Step 3: CAS(*counter, old=5, new=6)"]
  N9["*counter 仍為 5 交換成功，counter=6"]
  N10["✅ done"]
  N11["*counter 已改（別的執行緒改為 6）"]
  N12["❌ 失敗 回到 Step 1 重試"]
  N13["高競爭下的問題"]
  N14["T1 讀 old=5"]
  N15["T2 讀 old=5 CAS 成功(5 6)"]
  N16["T3 讀 old=5 CAS 失敗，重試"]
  N17["T4 讀 old=5 CAS 失敗，重試"]
  N18["T1 CAS 失敗，重試"]
  N19["...N 個執行緒競爭，每輪只有 1 個成功"]
  N20["自旋 CPU 浪費 ∝ 執行緒數量"]
  N21["解法: LongAdder（分段計數，減少競爭）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
</code></pre>
<pre><code class="language-text">do {
  old = load(x)
  new = old + 1
} while (!CAS(x, old, new))
</code></pre>
<h2 id="104-aba-問題對應-10411043"><a class="header" href="#104-aba-問題對應-10411043">10.4 ABA 問題（對應 10.4.1~10.4.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-43"><a class="header" href="#本小節示意圖-43">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["ABA 問題時間軸與帶版本號解法"]
  N2["問題: CAS 只比較值，不感知中間的變化"]
  N3["Thread T1 Thread T2"]
  N4["read: *addr = A （暫停）"]
  N5["（準備 CAS A B）"]
  N6["read: *addr = A"]
  N7["CAS(*addr, A, B) 成功"]
  N8["*addr = B"]
  N9["read: *addr = B"]
  N10["CAS(*addr, B, A) 成功"]
  N11["*addr = A 改回 A"]
  N12["CAS(*addr, A, B) （T1 繼續執行）"]
  N13["*addr 仍為 A，CAS 成功！"]
  N14["但 A 其實已經歷了 A B A 的變化"]
  N15["⚠ T1 誤以為「什麼都沒發生」，中間的 B 被忽略"]
  N16["ABA 問題的後果"]
  N17["無鎖棧場景（stack pop + push）"]
  N18["T1 準備 pop A（讀到 head=A, next=B）"]
  N19["T2 pop A, pop B, push A（棧頂還是A，但B丟失）"]
  N20["T1 CAS(head, A, B) 成功，但 B 已經不在棧裡！"]
  N21["棧結構損壞"]
  N22["解法: 帶版本號的 CAS（Double-CAS / Stamped Reference）"]
  N23["時間軸（帶版本號）"]
  N24["初始: (value=A, version=v1)"]
  N25["Thread T1 Thread T2"]
  N26["read: (A, v1) read: (A, v1)"]
  N27["（準備 CAS）"]
  N28["CAS((A,v1),(B,v2)) 成功"]
  N29["state: (B, v2)"]
  N30["CAS((B,v2),(A,v3)) 成功"]
  N31["state: (A, v3) 版本不同"]
  N32["CAS((A,v1),(B,v2))"]
  N33["當前: (A, v3) ≠ expected: (A, v1)"]
  N34["CAS 失敗！❌"]
  N35["T1 重新讀取，感知到 ABA 變化"]
  N36["版本號每次修改單調遞增，即使值迴圈也能區分"]
  N37["(A,v1) (B,v2) (A,v3) v3 ≠ v1"]
  N38["各語言帶版本號的實現"]
  N39["Java: AtomicStampedReference&amp;lt;V&amp;gt;"]
  N40["compareAndSet(expect, update, stamp, newStamp)"]
  N41["C++: std::atomic&amp;lt;std::pair&amp;lt;T,int&amp;gt;&amp;gt;（128-bit CAS）"]
  N42["或自訂 tagged pointer"]
  N43["Rust: AtomicU64（將 value 和 version 打包）"]
  N44["Go: sync/atomic.CompareAndSwapUint64（打包）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N5 --&gt; N6
  N5 --&gt; N7
  N5 --&gt; N8
  N5 --&gt; N9
  N5 --&gt; N10
  N5 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
  N0 --&gt; N26
  N0 --&gt; N27
  N0 --&gt; N28
  N0 --&gt; N29
  N0 --&gt; N30
  N0 --&gt; N31
  N0 --&gt; N32
  N0 --&gt; N33
  N0 --&gt; N34
  N0 --&gt; N35
  N0 --&gt; N36
  N0 --&gt; N37
  N0 --&gt; N38
  N0 --&gt; N39
  N0 --&gt; N40
  N0 --&gt; N41
  N0 --&gt; N42
  N0 --&gt; N43
  N0 --&gt; N44
</code></pre>
<p>A-&gt;B-&gt;A 會讓 CAS 誤判「沒變過」。</p>
<p>解法：加版本號（stamp/tagged pointer）。</p>
<h2 id="示意圖-9"><a class="header" href="#示意圖-9">示意圖</a></h2>
<pre><code class="language-text">loop:
  old = load
  new = f(old)
  if CAS(old,new) 成功 -&gt; done
  else -&gt; retry
</code></pre>
<h2 id="跨語言完整範例-9"><a class="header" href="#跨語言完整範例-9">跨語言完整範例</a></h2>
<p>主題：CAS 計數器（多執行緒自旋遞增，對比 mutex 版本）</p>
<h3 id="cc11-atomiccas-自旋"><a class="header" href="#cc11-atomiccas-自旋">C（C11 atomic，CAS 自旋）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch10_c ch10.c
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define INCREMENTS 10000

static atomic_int counter = ATOMIC_VAR_INIT(0);

void *cas_worker(void *arg) {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        int old, new_val;
        do {
            old = atomic_load_explicit(&amp;counter, memory_order_relaxed);
            new_val = old + 1;
        } while (!atomic_compare_exchange_weak_explicit(
                     &amp;counter, &amp;old, new_val,
                     memory_order_relaxed, memory_order_relaxed));
    }
    return NULL;
}

int main(void) {
    pthread_t threads[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;threads[i], NULL, cas_worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("counter = %d (expected %d)\n",
           atomic_load(&amp;counter), THREADS * INCREMENTS);
    return 0;
}
</code></pre>
<h3 id="cstdatomic-compare_exchange_weak-1"><a class="header" href="#cstdatomic-compare_exchange_weak-1">C++（std::atomic compare_exchange_weak）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch10_cpp ch10.cpp
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int THREADS = 4;
constexpr int INCREMENTS = 10000;

static std::atomic&lt;int&gt; counter{0};

void cas_worker() {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        int old = counter.load(std::memory_order_relaxed);
        while (!counter.compare_exchange_weak(
                   old, old + 1,
                   std::memory_order_relaxed)) {
            // old 自動被 compare_exchange_weak 更新為當前值
        }
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; THREADS; i++)
        threads.emplace_back(cas_worker);
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * INCREMENTS &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rustatomici32-fetch_add-vs-compare_exchange"><a class="header" href="#rustatomici32-fetch_add-vs-compare_exchange">Rust（AtomicI32 fetch_add vs compare_exchange）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch10.rs &amp;&amp; ./ch10
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;

const THREADS: usize = 4;
const INCREMENTS: usize = 10_000;

fn main() {
    let counter = Arc::new(AtomicI32::new(0));
    let mut handles = Vec::new();

    for _ in 0..THREADS {
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..INCREMENTS {
                // CAS 自旋遞增
                let mut old = counter.load(Ordering::Relaxed);
                loop {
                    match counter.compare_exchange_weak(
                        old, old + 1,
                        Ordering::Relaxed, Ordering::Relaxed)
                    {
                        Ok(_) =&gt; break,
                        Err(cur) =&gt; old = cur, // 更新 old 後重試
                    }
                }
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})",
             counter.load(Ordering::SeqCst),
             THREADS * INCREMENTS);
}</code></pre></pre>
<h3 id="gosyncatomic-compareandswap-1"><a class="header" href="#gosyncatomic-compareandswap-1">Go（sync/atomic CompareAndSwap）</a></h3>
<pre><code class="language-go">// 執行：go run ch10.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

const (
	threads    = 4
	increments = 10000
)

func main() {
	var counter int64
	var wg sync.WaitGroup

	for i := 0; i &lt; threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j &lt; increments; j++ {
				// CAS 自旋遞增
				for {
					old := atomic.LoadInt64(&amp;counter)
					if atomic.CompareAndSwapInt64(&amp;counter, old, old+1) {
						break // CAS 成功退出
					}
					// 失敗則重試（old 在下次 Load 時更新）
				}
			}
		}()
	}
	wg.Wait()
	fmt.Printf("counter = %d (expected %d)\n", counter, threads*increments)
}
</code></pre>
<h3 id="python模擬-caslock-保護原子性"><a class="header" href="#python模擬-caslock-保護原子性">Python（模擬 CAS，Lock 保護原子性）</a></h3>
<pre><code class="language-python"># 執行：python3 ch10.py
import threading

THREADS = 4
INCREMENTS = 10000

class AtomicInt:
    def __init__(self, initial=0):
        self._val = initial
        self._lock = threading.Lock()

    def load(self):
        return self._val

    def compare_and_swap(self, expected, new_val):
        with self._lock:
            if self._val == expected:
                self._val = new_val
                return True
            return False

counter = AtomicInt(0)

def cas_worker():
    for _ in range(INCREMENTS):
        while True:
            old = counter.load()
            if counter.compare_and_swap(old, old + 1):
                break  # CAS 成功

if __name__ == "__main__":
    ts = [threading.Thread(target=cas_worker) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"counter = {counter.load()} (expected {THREADS * INCREMENTS})")
</code></pre>
<h2 id="完整專案級範例python-9"><a class="header" href="#完整專案級範例python-9">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch10.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch10.py
</code></pre>
<pre><code class="language-python">"""Chapter 10: CAS increment loop."""
import threading


class AtomicInt:
    def __init__(self):
        self.v = 0
        self.m = threading.Lock()

    def cas(self, expect: int, new: int) -&gt; bool:
        with self.m:
            if self.v == expect:
                self.v = new
                return True
            return False


if __name__ == "__main__":
    a = AtomicInt()
    for _ in range(5):
        while True:
            old = a.v
            if a.cas(old, old + 1):
                break
    print("value=", a.v)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第11章-死鎖"><a class="header" href="#第11章-死鎖">第11章 死鎖</a></h1>
<h2 id="111-死鎖定義"><a class="header" href="#111-死鎖定義">11.1 死鎖定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-44"><a class="header" href="#本小節示意圖-44">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["資源分配圖: 循環等待形成死鎖"]
  N2["Thread T1 Thread T2"]
  N3["持有(hold) 持有(hold)"]
  N4["Resource A Resource B"]
  N5["等待(wait) 等待(wait)"]
  N6["Thread T2 Thread T1"]
  N7["T1 持有 A，等待 B"]
  N8["T2 持有 B，等待 A"]
  N9["形成有向循環 ⇒ 永遠無法推進 ⇒ 死鎖"]
  N0 --&gt; N1
  N0 --&gt; N2
  N2 --&gt; N3
  N0 --&gt; N4
  N4 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
</code></pre>
<p>兩個或以上執行緒互相等待對方釋放資源，永遠走不下去。</p>
<p>死鎖（Deadlock）是指一組執行緒陷入永久等待的狀態：每個執行緒都在等待另一個執行緒持有的資源，而那個執行緒也在等待更多資源，形成一個閉合的等待環。作業系統無法自動解除這種僵局，程式將永久掛起。</p>
<h2 id="112-演化過程對應-11211123"><a class="header" href="#112-演化過程對應-11211123">11.2 演化過程（對應 11.2.1~11.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-45"><a class="header" href="#本小節示意圖-45">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["時間軸: 安全狀態 不安全狀態 死鎖"]
  N2["時間點 Thread T1 Thread T2 系統狀態"]
  N3["t0 (就緒) (就緒) ✅ 安全"]
  N4["t1 lock(A) ✓ lock(B) ✓ ⚠️ 危險"]
  N5["[持有 A] [持有 B]"]
  N6["t2 try lock(B) 阻塞 try lock(A) 阻塞 🔴 不安全"]
  N7["[持有 A，等 B] [持有 B，等 A]"]
  N8["║ WAITING ║ ║ WAITING ║"]
  N9["t3 💀 死鎖"]
  N10["(永遠等待) (永遠等待)"]
  N11["CPU 佔用 0%，但無法繼續"]
  N12["關鍵轉折: t1 t2 時，兩個執行緒都已「持有資源並等待」"]
  N13["一旦形成循環，無外部干預則永不解除"]
  N0 --&gt; N1
  N0 --&gt; N2
  N2 --&gt; N3
  N2 --&gt; N4
  N4 --&gt; N5
  N2 --&gt; N6
  N6 --&gt; N7
  N6 --&gt; N8
  N2 --&gt; N9
  N9 --&gt; N10
  N9 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
</code></pre>
<p>不安全排程 + 資源競用，逐步滑向死鎖。</p>
<p>死鎖的形成通常是逐步的：系統從安全狀態出發，隨著執行緒依序取得部分資源，進入不安全狀態，最終當所有執行緒都在等待對方持有的資源時，死鎖完成。</p>
<h2 id="113-四必要條件"><a class="header" href="#113-四必要條件">11.3 四必要條件</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-46"><a class="header" href="#本小節示意圖-46">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["死鎖四必要條件（缺一不可）"]
  N2["條件一: 互斥（Mutual Exclusion）"]
  N3["只能一人使用"]
  N4["T1佔用 廁所 T2 被擋在外"]
  N5["（互斥資源）"]
  N6["白話: 廁所同時只能一個人用，資源不能共享"]
  N7["條件二: 持有且等待（Hold and Wait）"]
  N8["T1 手握 Lock A"]
  N9["還要申請 Lock B 不先放 A，直接等 B"]
  N10["白話: 手拿叉子，還要等筷子，但不肯放叉子"]
  N11["條件三: 不可剝奪（No Preemption）"]
  N12["OS/排程器 ✗ 強制搶走 T1 的 Lock A"]
  N13["只有 T1 自己 release() 才能釋放，外力無法強取"]
  N14["白話: 手裡的漢堡不能被別人硬搶走"]
  N15["條件四: 循環等待（Circular Wait）"]
  N16["T1 等待 Lock B (被 T2 持有)"]
  N17["Lock A 等待 T2"]
  N18["(被 T1 持有)"]
  N19["白話: A 等 B，B 等 A，繞成一個圈"]
  N20["⚡ 破壞任一條件即可預防死鎖！"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
</code></pre>
<p>死鎖的四個必要條件：</p>
<ul>
<li><strong>互斥</strong>：資源在某時刻只能被一個執行緒佔用</li>
<li><strong>持有且等待</strong>：執行緒持有至少一個資源，同時等待獲取其他執行緒持有的資源</li>
<li><strong>不可剝奪</strong>：已分配的資源不能被強制奪走，只能由持有者主動釋放</li>
<li><strong>循環等待</strong>：存在一個執行緒等待鏈，形成閉合迴路</li>
</ul>
<p>四個條件缺一不可，破壞其中任何一個即可預防死鎖。</p>
<h2 id="114-預防與處理"><a class="header" href="#114-預防與處理">11.4 預防與處理</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-47"><a class="header" href="#本小節示意圖-47">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["三種策略對比"]
  N2["策略 做法 代價 / 適用場景"]
  N3["固定加鎖順序 所有執行緒按相同順序加鎖 代價: 需全局規劃順序"]
  N4["適用: 鎖數量固定、"]
  N5["T1: lock(A B) 關係清晰"]
  N6["T2: lock(A B) A B"]
  N7["(不再交叉) ✅ 最可靠"]
  N8["tryLock + 逾時 嘗試加鎖，超過期限就放棄 代價: 需處理失敗重試"]
  N9["適用: 鎖等待時間可"]
  N10["if tryLock(B, 預期、業務允"]
  N11["100ms): 嘗試 100ms 後 許重試"]
  N12["use B 放棄，釋放 A"]
  N13["else: ⚠️ 可能活鎖"]
  N14["release A"]
  N15["縮小持鎖範圍 盡量縮短持鎖時間 代價: 需重新設計邏輯"]
  N16["適用: 業務邏輯可拆"]
  N17["只在讀寫共享 分、IO操作多"]
  N18["資料時持鎖， lock op unlock"]
  N19["IO 等慢操作移出 ✅ 提升整體吞吐量"]
  N20["臨界區外 短 短 短"]
  N21["死鎖偵測與恢復（補救手段）"]
  N22["偵測: 定期掃描資源分配圖，尋找循環"]
  N23["恢復: 選擇犧牲者（victim） 強制回滾或終止，釋放其資源"]
  N24["適用: 資料庫系統（如 MySQL 死鎖偵測）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
</code></pre>
<p>三種主流預防策略：</p>
<ul>
<li><strong>固定鎖順序</strong>：所有執行緒按相同的全局排序依序加鎖，確保不存在循環等待</li>
<li><strong><code>tryLock</code> + timeout</strong>：嘗試加鎖，超時後放棄並釋放已持有的鎖，待稍後重試</li>
<li><strong>減少持鎖時間</strong>：將不需要持鎖的操作（如 I/O、計算）移到臨界區外，降低衝突視窗</li>
</ul>
<pre><code class="language-text">T1: lock(A) -&gt; wait(B)
T2: lock(B) -&gt; wait(A)
=&gt; deadlock

修正後（固定順序）:
T1: lock(A) -&gt; lock(B) -&gt; unlock(B) -&gt; unlock(A)
T2: lock(A) -&gt; lock(B) -&gt; unlock(B) -&gt; unlock(A)
=&gt; 不再有循環，死鎖不可能發生
</code></pre>
<h2 id="跨語言完整範例-10"><a class="header" href="#跨語言完整範例-10">跨語言完整範例</a></h2>
<p>固定加鎖順序避免死鎖：兩把鎖按 id 排序後加鎖，無論執行緒以何種順序呼叫，都不會形成循環等待。</p>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch11_c ch11.c &amp;&amp; ./ch11_c */
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

typedef struct { int id; pthread_mutex_t mu; } Lock;

/* 按 id 排序後加鎖，破壞循環等待條件 */
void lock_ordered(Lock *a, Lock *b) {
    if (a-&gt;id &lt; b-&gt;id) {
        pthread_mutex_lock(&amp;a-&gt;mu);
        pthread_mutex_lock(&amp;b-&gt;mu);
    } else {
        pthread_mutex_lock(&amp;b-&gt;mu);
        pthread_mutex_lock(&amp;a-&gt;mu);
    }
}

void unlock_ordered(Lock *a, Lock *b) {
    pthread_mutex_unlock(&amp;a-&gt;mu);
    pthread_mutex_unlock(&amp;b-&gt;mu);
}

Lock res_a = {0, PTHREAD_MUTEX_INITIALIZER};
Lock res_b = {1, PTHREAD_MUTEX_INITIALIZER};
int shared = 0;

void *thread_fn(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i &lt; 5; i++) {
        lock_ordered(&amp;res_a, &amp;res_b);
        shared++;
        printf("Thread %d: shared = %d\n", id, shared);
        unlock_ordered(&amp;res_a, &amp;res_b);
        usleep(1000);
    }
    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    int id1 = 1, id2 = 2;
    pthread_create(&amp;t1, NULL, thread_fn, &amp;id1);
    pthread_create(&amp;t2, NULL, thread_fn, &amp;id2);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Final shared = %d\n", shared);
    return 0;
}
</code></pre>
<h3 id="c-1"><a class="header" href="#c-1">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch11_cpp ch11.cpp &amp;&amp; ./ch11_cpp
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

struct OrderedLock {
    int id;
    std::mutex mu;
};

// std::scoped_lock 內部用 std::lock() 實作死鎖安全加鎖
void transfer(OrderedLock &amp;from, OrderedLock &amp;to, int &amp;counter) {
    std::scoped_lock lk(from.mu, to.mu);   // 同時安全地鎖兩把
    counter++;
    std::cout &lt;&lt; "transferred, counter=" &lt;&lt; counter &lt;&lt; "\n";
}

int main() {
    OrderedLock account_a{0, {}};
    OrderedLock account_b{1, {}};
    int counter = 0;
    std::mutex cout_mu;

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++) {
        // 奇偶執行緒使用不同方向，但 scoped_lock 保證不死鎖
        if (i % 2 == 0)
            threads.emplace_back(transfer, std::ref(account_a),
                                 std::ref(account_b), std::ref(counter));
        else
            threads.emplace_back(transfer, std::ref(account_b),
                                 std::ref(account_a), std::ref(counter));
    }
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "Final counter=" &lt;&lt; counter &lt;&lt; "\n";
    return 0;
}
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch11.rs &amp;&amp; ./ch11
use std::sync::{Arc, Mutex};
use std::thread;

struct Resource {
    id: u32,
    data: Mutex&lt;i32&gt;,
}

// 按 id 排序後取鎖，確保全局順序
fn locked_update(a: &amp;Resource, b: &amp;Resource) {
    let (first, second) = if a.id &lt; b.id { (a, b) } else { (b, a) };
    let mut g1 = first.data.lock().unwrap();
    let mut g2 = second.data.lock().unwrap();
    *g1 += 1;
    *g2 += 1;
    println!("updated: res[{}]={}, res[{}]={}", first.id, *g1, second.id, *g2);
}

fn main() {
    let res_a = Arc::new(Resource { id: 0, data: Mutex::new(0) });
    let res_b = Arc::new(Resource { id: 1, data: Mutex::new(0) });

    let handles: Vec&lt;_&gt; = (0..4).map(|i| {
        let (a, b) = (Arc::clone(&amp;res_a), Arc::clone(&amp;res_b));
        thread::spawn(move || {
            // 一半執行緒傳 (a,b)，另一半傳 (b,a)，但排序保證安全
            if i % 2 == 0 { locked_update(&amp;a, &amp;b); }
            else           { locked_update(&amp;b, &amp;a); }
        })
    }).collect();

    for h in handles { h.join().unwrap(); }
    println!("Done, no deadlock.");
}</code></pre></pre>
<h3 id="go"><a class="header" href="#go">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch11.go
package main

import (
	"fmt"
	"sync"
)

type Resource struct {
	id int
	mu sync.Mutex
}

// 按 id 排序加鎖，破壞循環等待
func lockedTransfer(a, b *Resource, counter *int, mu *sync.Mutex) {
	first, second := a, b
	if a.id &gt; b.id {
		first, second = b, a
	}
	first.mu.Lock()
	second.mu.Lock()
	defer first.mu.Unlock()
	defer second.mu.Unlock()

	mu.Lock()
	*counter++
	fmt.Printf("transfer done, counter=%d\n", *counter)
	mu.Unlock()
}

func main() {
	resA := &amp;Resource{id: 0}
	resB := &amp;Resource{id: 1}
	counter := 0
	var printMu sync.Mutex
	var wg sync.WaitGroup

	for i := 0; i &lt; 8; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			if i%2 == 0 {
				lockedTransfer(resA, resB, &amp;counter, &amp;printMu)
			} else {
				lockedTransfer(resB, resA, &amp;counter, &amp;printMu)
			}
		}(i)
	}
	wg.Wait()
	fmt.Printf("Final counter=%d, no deadlock!\n", counter)
}
</code></pre>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch11.py
import threading
import time


class OrderedLock:
    def __init__(self, lock_id: int):
        self.id = lock_id
        self.mu = threading.Lock()


def locked_transfer(a: OrderedLock, b: OrderedLock, counter: list):
    """按 id 排序後加鎖，確保不形成循環等待。"""
    first, second = (a, b) if a.id &lt; b.id else (b, a)
    with first.mu:
        time.sleep(0.001)          # 模擬工作，增加競爭機會
        with second.mu:
            counter[0] += 1
            print(f"Thread {threading.current_thread().name}: "
                  f"counter={counter[0]}")


if __name__ == "__main__":
    res_a = OrderedLock(0)
    res_b = OrderedLock(1)
    counter = [0]

    threads = []
    for i in range(8):
        # 奇偶執行緒傳入順序相反，但 ordered lock 保證安全
        if i % 2 == 0:
            t = threading.Thread(target=locked_transfer,
                                 args=(res_a, res_b, counter), name=f"T{i}")
        else:
            t = threading.Thread(target=locked_transfer,
                                 args=(res_b, res_a, counter), name=f"T{i}")
        threads.append(t)
        t.start()

    for t in threads:
        t.join()
    print(f"Final counter={counter[0]}, no deadlock!")
</code></pre>
<h2 id="完整專案級範例python-10"><a class="header" href="#完整專案級範例python-10">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch11.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch11.py
</code></pre>
<pre><code class="language-python">"""Chapter 11: deadlock avoidance via timeout and ordered locking."""
import threading
import time

A = threading.Lock()
B = threading.Lock()


def worker1():
    """持有 A 後嘗試取 B，超時則主動放棄避免死鎖。"""
    with A:
        time.sleep(0.05)
        if B.acquire(timeout=0.1):
            print("w1 got B")
            B.release()
        else:
            print("w1 timeout on B — 避免死鎖，稍後重試")


def worker2():
    """持有 B 後嘗試取 A，超時則主動放棄避免死鎖。"""
    with B:
        time.sleep(0.05)
        if A.acquire(timeout=0.1):
            print("w2 got A")
            A.release()
        else:
            print("w2 timeout on A — 避免死鎖，稍後重試")


if __name__ == "__main__":
    t1 = threading.Thread(target=worker1)
    t2 = threading.Thread(target=worker2)
    t1.start(); t2.start(); t1.join(); t2.join()
    print("程式正常結束，無死鎖")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第12章-鎖優化"><a class="header" href="#第12章-鎖優化">第12章 鎖優化</a></h1>
<h2 id="121123-縮小鎖粒度"><a class="header" href="#121123-縮小鎖粒度">12.1~12.3 縮小鎖粒度</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-48"><a class="header" href="#本小節示意圖-48">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["縮小鎖粒度: 粗鎖 vs 細鎖"]
  N2["║ BEFORE: 一把大鎖保護整個 Map ║"]
  N3["Thread A (讀 k1)"]
  N4["Thread B (寫 k7) 爭搶同一把 GlobalLock Map"]
  N5["Thread C (讀 k3)"]
  N6["Thread D (寫 k9)"]
  N7["衝突概率 = P(任意兩個操作重疊) ≈ 很高"]
  N8["同一時刻只有 1 個執行緒能進入 Map"]
  N9["║ AFTER: 每個 bucket 一把鎖 ║"]
  N10["Thread A (讀 k1) Lock[bucket_0] bucket[0]: {k1,k2,...}"]
  N11["Thread B (寫 k7) Lock[bucket_1] bucket[1]: {k7,k8,...}"]
  N12["Thread C (讀 k3) Lock[bucket_0] bucket[0]: {k3,...}"]
  N13["Thread D (寫 k9) Lock[bucket_2] bucket[2]: {k9,...}"]
  N14["A 和 C 競爭 bucket_0（才衝突）"]
  N15["B 和 D 各用不同 bucket（完全並行）"]
  N16["衝突概率 = P(兩操作落在同一 bucket) ≈ 1/N（N 為 bucket 數）"]
  N17["並發度從 1 提升到接近 bucket 數量"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
</code></pre>
<p>粗鎖改細鎖，減少不必要互斥。</p>
<p>鎖粒度（Lock Granularity）指的是一把鎖所保護的資料範圍。粗粒度鎖（如保護整個 Map）易於實作但並發度低；細粒度鎖（如每個 bucket 一把鎖）提升並發，但設計複雜度也上升。核心原則：<strong>只鎖真正需要保護的最小資料範圍</strong>。</p>
<h2 id="124126-分段與分離"><a class="header" href="#124126-分段與分離">12.4~12.6 分段與分離</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-49"><a class="header" href="#本小節示意圖-49">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["分段鎖（Sharded Lock）: key hash % 16 shard[i]"]
  N2["Sharded Map（16 個分片）"]
  N3["key hash(key) % 16 選擇分片"]
  N4["Shard[0] Lock[0] Thread A"]
  N5["{k0,...}"]
  N6["Shard[1] Lock[1] Thread B (同時並行)"]
  N7["{k1,...}"]
  N8["Shard[2] Lock[2] Thread C (同時並行)"]
  N9["{k2,...}"]
  N10["Shard[15] Lock[15] Thread P (同時並行)"]
  N11["{k15,..}"]
  N12["並發度: 最多 16 個執行緒同時操作不同分片（互不阻塞）"]
  N13["衝突只發生在: 兩個 key 的 hash%16 值相同時"]
  N14["對比單一全域鎖: 並發度提升 ≈ 16 倍（理論上限）"]
  N15["白話例子"]
  N16["超商單一結帳櫃台 16 個自助結帳機"]
  N17["顧客分散到不同機台，排隊時間大幅縮短"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
</code></pre>
<p>把一把全域鎖拆成多段（striped/sharded lock）。</p>
<p>分段鎖是縮小鎖粒度的極致應用：將資料結構按某種規則（通常是 key 的 hash 值）切分為多個 shard，每個 shard 有獨立的鎖。操作時只鎖對應的 shard，其他 shard 的操作完全不受影響，理論並發度為 shard 數量。</p>
<h2 id="127129-其他策略"><a class="header" href="#127129-其他策略">12.7~12.9 其他策略</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-50"><a class="header" href="#本小節示意圖-50">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["鎖策略決策樹"]
  N2["開始評估並發策略"]
  N3["讀操作遠多於寫操作？"]
  N4["是 使用讀寫鎖（RWLock / shared_mutex）"]
  N5["多個讀者同時進入，只有寫者互斥"]
  N6["適用: 配置讀取、快取查詢"]
  N7["否 操作是否無衝突（CAS 能完成）？"]
  N8["是 樂觀鎖 / 原子 CAS（lock-free）"]
  N9["適用: 計數器、狀態機、無競爭更新"]
  N10["否 高吞吐量場景？"]
  N11["是 分段鎖（Sharded Lock）"]
  N12["適用: 並發 Map、並發計數器"]
  N13["否 需要公平性（FIFO 順序）？"]
  N14["是 公平鎖（Fair Lock）"]
  N15["避免飢餓，代價: 吞吐略低"]
  N16["否 執行緒本地資料夠用？"]
  N17["是 ThreadLocal"]
  N18["完全消除鎖競爭"]
  N19["否 普通互斥鎖"]
  N20["+ 縮小持鎖範圍"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N7 --&gt; N8
  N7 --&gt; N9
  N7 --&gt; N10
  N10 --&gt; N11
  N10 --&gt; N12
  N10 --&gt; N13
  N13 --&gt; N14
  N13 --&gt; N15
  N13 --&gt; N16
  N16 --&gt; N17
  N16 --&gt; N18
  N16 --&gt; N19
  N19 --&gt; N20
</code></pre>
<p>其他常見鎖優化策略：</p>
<ul>
<li><strong>降低持鎖時間</strong>：將 I/O、複雜計算移到臨界區外，只在真正需要保護的最小程式碼段持鎖</li>
<li><strong>熱點隔離</strong>：高頻訪問的共享計數器可用 per-CPU 計數器或 LongAdder 模式，最後再匯總</li>
<li><strong>讀寫分離</strong>：讀多寫少場景用 <code>RWMutex</code>，允許多個讀者並行，只有寫者獨佔</li>
<li><strong>優先無鎖結構</strong>：原子操作（CAS）、無鎖佇列在低競爭場景下比鎖更快</li>
</ul>
<p>白話例子：超商單一結帳櫃台改 16 個櫃台，隊伍自然變短。</p>
<h2 id="跨語言完整範例-11"><a class="header" href="#跨語言完整範例-11">跨語言完整範例</a></h2>
<p>分段鎖 Map：SHARDS=8，按 key hash 選鎖，多執行緒並發寫入，對比全域鎖展示吞吐量差異。</p>
<h3 id="c-2"><a class="header" href="#c-2">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch12_c ch12.c &amp;&amp; ./ch12_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define SHARDS   8
#define ITERS    100000
#define THREADS  4

typedef struct { long count; pthread_mutex_t mu; } Shard;

Shard shards[SHARDS];

static unsigned int hash_key(int key) {
    return (unsigned int)key * 2654435761u;
}

void shard_inc(int key) {
    int idx = hash_key(key) % SHARDS;
    pthread_mutex_lock(&amp;shards[idx].mu);
    shards[idx].count++;
    pthread_mutex_unlock(&amp;shards[idx].mu);
}

void *worker(void *arg) {
    int base = *(int *)arg;
    for (int i = 0; i &lt; ITERS; i++)
        shard_inc(base * ITERS + i);
    return NULL;
}

int main(void) {
    for (int i = 0; i &lt; SHARDS; i++)
        pthread_mutex_init(&amp;shards[i].mu, NULL);

    pthread_t ts[THREADS];
    int ids[THREADS];
    struct timespec t0, t1;
    clock_gettime(CLOCK_MONOTONIC, &amp;t0);

    for (int i = 0; i &lt; THREADS; i++) {
        ids[i] = i;
        pthread_create(&amp;ts[i], NULL, worker, &amp;ids[i]);
    }
    for (int i = 0; i &lt; THREADS; i++) pthread_join(ts[i], NULL);

    clock_gettime(CLOCK_MONOTONIC, &amp;t1);
    long total = 0;
    for (int i = 0; i &lt; SHARDS; i++) total += shards[i].count;

    long ms = (t1.tv_sec - t0.tv_sec) * 1000 +
              (t1.tv_nsec - t0.tv_nsec) / 1000000;
    printf("total=%ld (expected %d), elapsed=%ldms\n",
           total, THREADS * ITERS, ms);
    return 0;
}
</code></pre>
<h3 id="c-3"><a class="header" href="#c-3">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch12_cpp ch12.cpp &amp;&amp; ./ch12_cpp
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

constexpr int SHARDS  = 8;
constexpr int ITERS   = 100000;
constexpr int THREADS = 4;

struct Shard {
    long count = 0;
    std::mutex mu;
};

Shard shards[SHARDS];

void shard_inc(int key) {
    int idx = std::hash&lt;int&gt;{}(key) % SHARDS;
    std::lock_guard lk(shards[idx].mu);
    shards[idx].count++;
}

int main() {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) {
        ts.emplace_back([i] {
            for (int j = 0; j &lt; ITERS; j++)
                shard_inc(i * ITERS + j);
        });
    }
    for (auto &amp;t : ts) t.join();

    long total = 0;
    for (auto &amp;s : shards) total += s.count;
    std::cout &lt;&lt; "total=" &lt;&lt; total
              &lt;&lt; " (expected=" &lt;&lt; THREADS * ITERS &lt;&lt; ")\n";
    return 0;
}
</code></pre>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch12.rs -o ch12 &amp;&amp; ./ch12
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

const SHARDS: usize = 8;
const ITERS: usize = 25000;
const THREADS: usize = 4;

fn hash_shard(key: i32) -&gt; usize {
    let mut h = DefaultHasher::new();
    key.hash(&amp;mut h);
    (h.finish() as usize) % SHARDS
}

fn main() {
    // Arc&lt;Vec&lt;Mutex&lt;i64&gt;&gt;&gt;：共享的分段計數器
    let shards: Arc&lt;Vec&lt;Mutex&lt;i64&gt;&gt;&gt; =
        Arc::new((0..SHARDS).map(|_| Mutex::new(0)).collect());

    let handles: Vec&lt;_&gt; = (0..THREADS).map(|i| {
        let shards = Arc::clone(&amp;shards);
        thread::spawn(move || {
            for j in 0..ITERS {
                let key = (i * ITERS + j) as i32;
                let idx = hash_shard(key);
                *shards[idx].lock().unwrap() += 1;
            }
        })
    }).collect();

    for h in handles { h.join().unwrap(); }

    let total: i64 = shards.iter().map(|s| *s.lock().unwrap()).sum();
    println!("total={} (expected={})", total, THREADS * ITERS);
}</code></pre></pre>
<h3 id="go-1"><a class="header" href="#go-1">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch12.go
package main

import (
	"fmt"
	"hash/fnv"
	"sync"
	"sync/atomic"
)

const shards = 8
const iters = 25000
const workers = 4

type Shard struct {
	mu    sync.Mutex
	count int64
}

var shardMap [shards]Shard

func hashShard(key int) int {
	h := fnv.New32a()
	b := [4]byte{byte(key), byte(key &gt;&gt; 8), byte(key &gt;&gt; 16), byte(key &gt;&gt; 24)}
	h.Write(b[:])
	return int(h.Sum32()) % shards
}

func shardInc(key int) {
	idx := hashShard(key)
	shardMap[idx].mu.Lock()
	shardMap[idx].count++
	shardMap[idx].mu.Unlock()
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i &lt; workers; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			for j := 0; j &lt; iters; j++ {
				shardInc(i*iters + j)
			}
		}(i)
	}
	wg.Wait()

	var total int64
	for i := range shardMap {
		total += atomic.LoadInt64(&amp;shardMap[i].count)
	}
	fmt.Printf("total=%d (expected=%d)\n", total, workers*iters)
}
</code></pre>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch12.py
import threading
import hashlib

SHARDS  = 8
ITERS   = 10000
WORKERS = 4


class ShardedCounter:
    def __init__(self, n_shards: int):
        self.counts = [0] * n_shards
        self.locks  = [threading.Lock() for _ in range(n_shards)]
        self.n      = n_shards

    def increment(self, key: int):
        idx = key % self.n          # 簡單取模作為 hash 函數
        with self.locks[idx]:
            self.counts[idx] += 1

    def total(self) -&gt; int:
        return sum(self.counts)


counter = ShardedCounter(SHARDS)


def worker(worker_id: int):
    for j in range(ITERS):
        counter.increment(worker_id * ITERS + j)


if __name__ == "__main__":
    threads = [threading.Thread(target=worker, args=(i,)) for i in range(WORKERS)]
    for t in threads: t.start()
    for t in threads: t.join()
    print(f"total={counter.total()} (expected={WORKERS * ITERS})")
    print(f"分片分佈: {counter.counts}")
</code></pre>
<h2 id="完整專案級範例python-11"><a class="header" href="#完整專案級範例python-11">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch12.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch12.py
</code></pre>
<pre><code class="language-python">"""Chapter 12: lock sharding — 分段鎖實作與對比。"""
import threading
import time

SHARDS = 8
locks = [threading.Lock() for _ in range(SHARDS)]
data = [0] * SHARDS


def update(key: int):
    """按 key % SHARDS 選擇對應分片的鎖，只鎖該分片。"""
    idx = key % SHARDS
    with locks[idx]:
        data[idx] += 1


if __name__ == "__main__":
    start = time.time()
    ts = [threading.Thread(target=update, args=(i,)) for i in range(10_000)]
    for t in ts: t.start()
    for t in ts: t.join()
    elapsed = time.time() - start
    print(f"sum={sum(data)}, elapsed={elapsed:.3f}s")
    print(f"分片分佈: {data}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第13章-線程池"><a class="header" href="#第13章-線程池">第13章 線程池</a></h1>
<h2 id="131-狀態與生命週期對應-13111312"><a class="header" href="#131-狀態與生命週期對應-13111312">13.1 狀態與生命週期（對應 13.1.1~13.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-51"><a class="header" href="#本小節示意圖-51">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["線程池狀態機"]
  N2["RUNNING 正常接受任務並處理"]
  N3["shutdown() shutdownNow()"]
  N4["SHUTDOWN STOP"]
  N5["（不收新任務) （立即中斷）"]
  N6["繼續排隊中 返回未執行"]
  N7["的舊任務 任務列表"]
  N8["佇列清空 workers 停止"]
  N9["workers 歸零"]
  N10["TIDYING 所有任務已完成"]
  N11["worker=0 呼叫 terminated() hook"]
  N12["terminated() 完成"]
  N13["TERMINATED 最終狀態，資源全部釋放"]
  N14["注意: 狀態只能單向推進，不可逆轉"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N7 --&gt; N8
  N7 --&gt; N9
  N9 --&gt; N10
  N9 --&gt; N11
  N11 --&gt; N12
  N9 --&gt; N13
  N0 --&gt; N14
</code></pre>
<p>管理執行緒建立、運作、關閉，避免每次任務都開新執行緒。</p>
<p>線程池維護一組預先建立的執行緒，持續從任務佇列取出任務執行。這樣避免了頻繁建立/銷毀執行緒的開銷（每次建立約耗費數十微秒），並提供統一的資源上限，防止系統因過多執行緒而耗盡記憶體。</p>
<h2 id="132-建立方式對應-13211324"><a class="header" href="#132-建立方式對應-13211324">13.2 建立方式（對應 13.2.1~13.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-52"><a class="header" href="#本小節示意圖-52">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["四種線程池類型對比"]
  N2["類型 執行緒數量 任務佇列 適用場景"]
  N3["Fixed 固定 N 個 無界佇列 CPU 密集計算"]
  N4["Thread Pool 永遠存在 LinkedBlocking 任務量穩定"]
  N5["Queue Web 後端服務"]
  N6["[T][T][T][T] [Q Q Q Q …]"]
  N7["Cached 彈性 0~MAX SynchronousQueue 短暫突發流量"]
  N8["Thread Pool 閒置 60s 後回收 (容量=0，直接 任務量不可預測"]
  N9["handoff) 但單個任務快"]
  N10["[T]?[T]?[T]? [直接交付]"]
  N11["Scheduled 固定核心 N 個 DelayedQueue 定時任務排程"]
  N12["Thread Pool 支援延遲/週期 (按時間排序) Cron 類工作"]
  N13["心跳、清理任務"]
  N14["[T][T] (定時) [t=10s][t=30s]"]
  N15["ForkJoin N ≈ CPU 核數 每執行緒私有 分治演算法"]
  N16["Pool 工作竊取（steal) Deque 遞迴並行處理"]
  N17["(可從別人尾部 Stream parallel"]
  N18["[T] steal [T] 偷任務)"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
</code></pre>
<p>固定池、快取池、排程池、分治池各有適用場景。選錯類型可能導致記憶體耗盡（Cached pool 在爆發流量下無限建執行緒）或效能低下（Fixed pool 在 I/O 密集時執行緒閒置）。</p>
<h2 id="133-提交流程與拒絕策略對應-13311332"><a class="header" href="#133-提交流程與拒絕策略對應-13311332">13.3 提交流程與拒絕策略（對應 13.3.1~13.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-53"><a class="header" href="#本小節示意圖-53">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["submit(task) 完整決策流程"]
  N2["submit(task)"]
  N3["核心執行緒數 &amp;lt; corePoolSize?"]
  N4["是 否"]
  N5["新建 Worker 任務佇列 queue 未滿？"]
  N6["執行此任務"]
  N7["是 否"]
  N8["入佇列等待 執行緒數 &amp;lt; maxPoolSize?"]
  N9["是 否"]
  N10["新建非核心 拒絕策略"]
  N11["Worker 執行"]
  N12["AbortPolicy:拋例外"]
  N13["CallerRunsPolicy"]
  N14["呼叫者自己跑"]
  N15["DiscardPolicy:靜默"]
  N16["DiscardOldest:丟最"]
  N17["舊的任務"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N3 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N7 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N8 --&gt; N12
  N12 --&gt; N13
  N12 --&gt; N14
  N12 --&gt; N15
  N12 --&gt; N16
  N12 --&gt; N17
</code></pre>
<p>核心是「任務佇列 + 工作執行緒 + 飽和策略」。</p>
<p>任務提交時，線程池按優先級嘗試：先用核心執行緒，再入佇列，再擴展到最大執行緒數，最後觸發拒絕策略。理解這個流程對調參（corePoolSize、maxPoolSize、queueCapacity）至關重要。</p>
<h2 id="134-關閉對應-13411342"><a class="header" href="#134-關閉對應-13411342">13.4 關閉（對應 13.4.1~13.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-54"><a class="header" href="#本小節示意圖-54">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["兩種關閉方式對比"]
  N2["shutdown(): 優雅關閉"]
  N3["1. 標記狀態為 SHUTDOWN"]
  N4["2. 不再接受新的 submit() 呼叫"]
  N5["3. 已在佇列中的任務 ✅ 繼續執行完畢"]
  N6["4. 所有 worker 完成後進入 TERMINATED"]
  N7["Timeline"]
  N8["結束"]
  N9["shutdown()"]
  N10["不接受新任務 排空佇列"]
  N11["[Q任務1][Q任務2] 執行完畢"]
  N12["shutdownNow(): 立即關閉"]
  N13["1. 標記狀態為 STOP"]
  N14["2. 對所有 worker 送出 interrupt() 訊號"]
  N15["3. 佇列中 ❌ 未執行的任務以 List 形式返回給呼叫者"]
  N16["4. 正在執行的任務若響應中斷則提前結束"]
  N17["Timeline"]
  N18["結束"]
  N19["shutdownNow()"]
  N20["中斷 workers 返回未執行任務列表"]
  N21["[Q任務1][Q任務2] 取出並返回，不執行"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
</code></pre>
<ul>
<li>優雅關閉（<code>shutdown</code>）：不收新任務，處理完已接收的任務後關閉。</li>
<li>立即關閉（<code>shutdownNow</code>）：嘗試中斷執行中的任務，返回未執行的任務列表。</li>
</ul>
<p>實務上應搭配 <code>awaitTermination(timeout)</code> 等待關閉完成，避免主程式提前退出導致任務被截斷。</p>
<h2 id="135-參數調優對應-13511352"><a class="header" href="#135-參數調優對應-13511352">13.5 參數調優（對應 13.5.1~13.5.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-55"><a class="header" href="#本小節示意圖-55">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["線程數調優公式"]
  N2["符號定義"]
  N3["N = CPU 核心數（Runtime.getRuntime().availableProcessors）"]
  N4["WT = 平均等待時間（Wait Time，例如 I/O 等待 900ms）"]
  N5["ST = 平均服務時間（Service Time，例如 CPU 計算 100ms）"]
  N6["CPU 密集型任務（幾乎不等待 I/O）"]
  N7["最佳執行緒數 = N + 1"]
  N8["+1 的原因: 當某執行緒因缺頁中斷等短暫暫停時，"]
  N9["額外一個執行緒可立即接手 CPU，避免浪費"]
  N10["範例: N=8 核 推薦 9 個執行緒"]
  N11["I/O 密集型任務（大量等待磁碟/網路）"]
  N12["最佳執行緒數 = N × (1 + WT/ST)"]
  N13["直覺: 執行緒等待 I/O 時 CPU 是閒置的，"]
  N14["可讓更多執行緒同時在 CPU 上運行"]
  N15["範例: N=8，WT=900ms，ST=100ms"]
  N16["= 8 × (1 + 900/100)"]
  N17["= 8 × 10 = 80 個執行緒"]
  N18["⚠️ 上限受記憶體限制，每個 Java 執行緒預設 256KB~1MB 棧"]
  N19["實務建議: 先用公式估算，再透過壓測（吞吐量、延遲）調整"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
</code></pre>
<p>CPU 密集：執行緒數接近核心數（N+1）。
I/O 密集：可高於核心數，按 N×(1+WT/ST) 估算。</p>
<pre><code class="language-text">Producer -&gt; Queue -&gt; Worker x N -&gt; Result
</code></pre>
<h2 id="跨語言完整範例-12"><a class="header" href="#跨語言完整範例-12">跨語言完整範例</a></h2>
<p>執行緒池處理批次任務：固定 4 個 worker，處理 20 個任務，顯示並發執行效果。</p>
<h3 id="c-4"><a class="header" href="#c-4">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch13_c ch13.c &amp;&amp; ./ch13_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

#define WORKERS 4
#define TASKS   20
#define QUEUE_CAP 64

typedef void (*task_fn)(int);

typedef struct {
    task_fn  fn;
    int      arg;
} Task;

typedef struct {
    Task      queue[QUEUE_CAP];
    int       head, tail, size;
    pthread_mutex_t mu;
    pthread_cond_t  not_empty;
    int       done;           /* 1 = shutdown */
} Pool;

Pool pool = {.head=0, .tail=0, .size=0, .done=0,
             .mu=PTHREAD_MUTEX_INITIALIZER,
             .not_empty=PTHREAD_COND_INITIALIZER};

void pool_submit(task_fn fn, int arg) {
    pthread_mutex_lock(&amp;pool.mu);
    pool.queue[pool.tail] = (Task){fn, arg};
    pool.tail = (pool.tail + 1) % QUEUE_CAP;
    pool.size++;
    pthread_cond_signal(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);
}

void *worker_loop(void *arg) {
    int id = *(int *)arg;
    for (;;) {
        pthread_mutex_lock(&amp;pool.mu);
        while (pool.size == 0 &amp;&amp; !pool.done)
            pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
        if (pool.size == 0 &amp;&amp; pool.done) {
            pthread_mutex_unlock(&amp;pool.mu);
            break;
        }
        Task t = pool.queue[pool.head];
        pool.head = (pool.head + 1) % QUEUE_CAP;
        pool.size--;
        pthread_mutex_unlock(&amp;pool.mu);
        t.fn(t.arg);
    }
    printf("Worker %d exiting\n", id);
    return NULL;
}

void process_task(int task_id) {
    printf("Task %2d running on thread %lu\n",
           task_id, pthread_self() % 10000);
    usleep(50000);  /* 模擬 50ms 工作 */
}

int main(void) {
    pthread_t threads[WORKERS];
    int ids[WORKERS];
    for (int i = 0; i &lt; WORKERS; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker_loop, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASKS; i++)
        pool_submit(process_task, i);

    /* 等佇列排空後關閉 */
    pthread_mutex_lock(&amp;pool.mu);
    while (pool.size &gt; 0)
        pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
    pool.done = 1;
    pthread_cond_broadcast(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);

    for (int i = 0; i &lt; WORKERS; i++) pthread_join(threads[i], NULL);
    printf("All %d tasks completed.\n", TASKS);
    return 0;
}
</code></pre>
<h3 id="c-5"><a class="header" href="#c-5">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch13_cpp ch13.cpp &amp;&amp; ./ch13_cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;queue&gt;
#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;vector&gt;

class ThreadPool {
    std::vector&lt;std::thread&gt; workers;
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::mutex mu;
    std::condition_variable cv;
    bool stop = false;
public:
    explicit ThreadPool(int n) {
        for (int i = 0; i &lt; n; i++)
            workers.emplace_back([this] {
                for (;;) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock lk(mu);
                        cv.wait(lk, [this]{ return stop || !tasks.empty(); });
                        if (stop &amp;&amp; tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
    }
    void submit(std::function&lt;void()&gt; f) {
        { std::lock_guard lk(mu); tasks.push(std::move(f)); }
        cv.notify_one();
    }
    ~ThreadPool() {
        { std::lock_guard lk(mu); stop = true; }
        cv.notify_all();
        for (auto &amp;t : workers) t.join();
    }
};

int main() {
    ThreadPool pool(4);
    std::mutex print_mu;
    for (int i = 0; i &lt; 20; i++) {
        pool.submit([i, &amp;print_mu] {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            std::lock_guard lk(print_mu);
            std::cout &lt;&lt; "Task " &lt;&lt; i &lt;&lt; " done by thread "
                      &lt;&lt; std::this_thread::get_id() &lt;&lt; "\n";
        });
    }
    /* ThreadPool 解構時自動等待所有任務完成 */
    std::cout &lt;&lt; "All tasks submitted, waiting...\n";
    return 0;
}
</code></pre>
<h3 id="rust-2"><a class="header" href="#rust-2">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch13.rs -o ch13 &amp;&amp; ./ch13
use std::sync::{Arc, Mutex};
use std::sync::mpsc;
use std::thread;

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

struct ThreadPool {
    _workers: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
    sender: mpsc::Sender&lt;Option&lt;Job&gt;&gt;,
}

impl ThreadPool {
    fn new(size: usize) -&gt; Self {
        let (sender, receiver) = mpsc::channel::&lt;Option&lt;Job&gt;&gt;();
        let receiver = Arc::new(Mutex::new(receiver));
        let workers = (0..size).map(|_| {
            let rx = Arc::clone(&amp;receiver);
            thread::spawn(move || loop {
                let msg = rx.lock().unwrap().recv().unwrap();
                match msg {
                    Some(job) =&gt; job(),
                    None =&gt; break,
                }
            })
        }).collect();
        ThreadPool { _workers: workers, sender }
    }

    fn submit&lt;F: FnOnce() + Send + 'static&gt;(&amp;self, f: F) {
        self.sender.send(Some(Box::new(f))).unwrap();
    }

    fn shutdown(self) {
        for _ in &amp;self._workers {
            self.sender.send(None).unwrap();
        }
        for w in self._workers { w.join().unwrap(); }
    }
}

fn main() {
    let pool = ThreadPool::new(4);
    let counter = Arc::new(Mutex::new(0));

    for i in 0..20 {
        let c = Arc::clone(&amp;counter);
        pool.submit(move || {
            thread::sleep(std::time::Duration::from_millis(50));
            let mut n = c.lock().unwrap();
            *n += 1;
            println!("Task {:2} done, completed so far: {}", i, *n);
        });
    }
    pool.shutdown();
    println!("All tasks completed.");
}</code></pre></pre>
<h3 id="go-2"><a class="header" href="#go-2">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch13.go
package main

import (
	"fmt"
	"sync"
	"time"
)

func newWorkerPool(workers int, queueSize int) chan&lt;- func() {
	jobs := make(chan func(), queueSize)
	for i := 0; i &lt; workers; i++ {
		workerID := i
		go func() {
			for job := range jobs {
				fmt.Printf("  Worker %d picked up job\n", workerID)
				job()
			}
		}()
	}
	return jobs
}

func main() {
	const numWorkers = 4
	const numTasks   = 20

	pool := newWorkerPool(numWorkers, 64)
	var wg sync.WaitGroup

	for i := 0; i &lt; numTasks; i++ {
		taskID := i
		wg.Add(1)
		pool &lt;- func() {
			defer wg.Done()
			time.Sleep(50 * time.Millisecond)
			fmt.Printf("Task %2d completed\n", taskID)
		}
	}

	wg.Wait()
	close(pool)
	fmt.Printf("All %d tasks completed.\n", numTasks)
}
</code></pre>
<h3 id="python-2"><a class="header" href="#python-2">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch13.py
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed


def process_task(task_id: int) -&gt; str:
    """模擬一個需要 50ms 的工作任務。"""
    time.sleep(0.05)
    thread_name = threading.current_thread().name
    return f"Task {task_id:2d} done by {thread_name}"


if __name__ == "__main__":
    num_tasks   = 20
    num_workers = 4

    start = time.time()
    with ThreadPoolExecutor(max_workers=num_workers,
                            thread_name_prefix="Worker") as pool:
        futures = [pool.submit(process_task, i) for i in range(num_tasks)]
        for future in as_completed(futures):
            print(future.result())

    elapsed = time.time() - start
    # 序列需 20×0.05=1.0s，4 個 worker 並行約 0.25s
    print(f"\n完成 {num_tasks} 個任務，耗時 {elapsed:.2f}s "
          f"（序列估計 {num_tasks * 0.05:.2f}s）")
</code></pre>
<h2 id="完整專案級範例python-12"><a class="header" href="#完整專案級範例python-12">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch13.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch13.py
</code></pre>
<pre><code class="language-python">"""Chapter 13: thread pool — 使用 ThreadPoolExecutor 並行處理批次任務。"""
import time
from concurrent.futures import ThreadPoolExecutor


def square(x: int) -&gt; int:
    """模擬 CPU 計算：計算平方值。"""
    time.sleep(0.01)  # 模擬少量計算時間
    return x * x


if __name__ == "__main__":
    inputs = list(range(16))
    start = time.time()

    with ThreadPoolExecutor(max_workers=4) as ex:
        results = list(ex.map(square, inputs))

    elapsed = time.time() - start
    print(f"結果: {results}")
    print(f"耗時: {elapsed:.2f}s（4 個 worker 並行）")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第14章-threadlocal"><a class="header" href="#第14章-threadlocal">第14章 ThreadLocal</a></h1>
<h2 id="141143-存取機制對應-1411434"><a class="header" href="#141143-存取機制對應-1411434">14.1~14.3 存取機制（對應 14.1~14.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-56"><a class="header" href="#本小節示意圖-56">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["ThreadLocal 存取機制: Thread 內部結構圖"]
  N2["Thread A"]
  N3["threadLocals: ThreadLocalMap"]
  N4["Entry[]（開放定址雜湊表）"]
  N5["key = WeakRef(TL1) value = \"user_42\""]
  N6["key = WeakRef(TL2) value = conn_obj_A"]
  N7["(空槽)"]
  N8["查找路徑"]
  N9["threadLocal.get()"]
  N10["Thread.currentThread() 取得當前執行緒"]
  N11["thread.threadLocals 取得 ThreadLocalMap"]
  N12["map.get(this) this = ThreadLocal 實例，作為 key"]
  N13["entry.value 返回使用者儲存的值"]
  N14["⚠️ 記憶體洩漏風險"]
  N15["ThreadLocal 實例被 GC（key 變 null）"]
  N16["Entry 的 key = null，但 value 仍被強引用"]
  N17["value 無法被 GC 回收 洩漏！"]
  N18["防範: 使用完畢後務必呼叫 threadLocal.remove()"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
</code></pre>
<p>每個執行緒持有自己的本地變數副本，互不干擾。</p>
<p>ThreadLocal 的核心不是「一個全局變數有多份副本」，而是「每個 Thread 物件內部有一個 <code>ThreadLocalMap</code>」。<code>get()/set()</code> 實際上是在當前執行緒的 Map 中查找/寫入，以 ThreadLocal 實例本身作為 key。</p>
<p>關鍵細節：Map 中的 key 是弱引用（WeakReference），若 ThreadLocal 實例沒有外部強引用而被 GC 回收，key 就會變成 null，但 value 仍被 Entry 強引用，造成洩漏。執行緒池中的執行緒長期存活，此問題尤為危險。</p>
<h2 id="144-不繼承性"><a class="header" href="#144-不繼承性">14.4 不繼承性</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-57"><a class="header" href="#本小節示意圖-57">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["父執行緒 vs 子執行緒的 ThreadLocal 隔離"]
  N2["父執行緒（Parent Thread）"]
  N3["threadLocals: { TL_user_id 42, TL_request \"req-001\" }"]
  N4["new Thread(...) 或 pool.submit(...)"]
  N5["建立子執行緒"]
  N6["子執行緒（Child Thread）"]
  N7["threadLocals: { } 空 Map！"]
  N8["child.get(TL_user_id) null（或 initialValue()）"]
  N9["child.get(TL_request) null（或 initialValue()）"]
  N10["⚠️ 常見問題"]
  N11["父執行緒設定了 user_id=42（用於追蹤請求）"]
  N12["提交任務到執行緒池後，子執行緒讀到 null"]
  N13["日誌無法關聯到正確的請求 ID"]
  N14["解決方案: 改用 InheritableThreadLocal（見 14.5）"]
  N15["或手動在 submit 時捕獲並傳遞值"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N3 --&gt; N4
  N3 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N14 --&gt; N15
</code></pre>
<p>子執行緒預設看不到父執行緒 ThreadLocal。</p>
<p>這個設計是有意的：ThreadLocal 的語義是「執行緒私有」，若自動繼承反而破壞隔離性。但在請求追蹤（Trace ID）等場景確實需要傳遞上下文，此時應使用 InheritableThreadLocal 或顯式傳遞。</p>
<h2 id="145146-可繼承變體"><a class="header" href="#145146-可繼承變體">14.5~14.6 可繼承變體</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-58"><a class="header" href="#本小節示意圖-58">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["InheritableThreadLocal: 建立子執行緒時複製快照"]
  N2["父執行緒"]
  N3["inheritableThreadLocals: { ITL_user 42, ITL_locale \"zh\" }"]
  N4["new Thread() 時，JVM 自動複製快照"]
  N5["子執行緒（建立時複製）"]
  N6["inheritableThreadLocals: { ITL_user 42, ITL_locale \"zh\" }"]
  N7["↑ 獨立副本，修改互不影響"]
  N8["child.set(ITL_user, 99) 只影響子執行緒，父執行緒仍是 42"]
  N9["⚠️ 執行緒池問題"]
  N10["Pool 中的執行緒在建立時已複製，之後複用時不會再複製"]
  N11["父執行緒後續修改的值，Pool Worker 看不到"]
  N12["設計哲學對比: Java vs Go"]
  N13["Java: 隱式攜帶（InheritableThreadLocal）"]
  N14["上下文隱藏在執行緒內部"]
  N15["優點: 呼叫方不需要傳參"]
  N16["缺點: 隱式依賴，難以追蹤"]
  N17["Go: 顯式傳遞（context.Context）"]
  N18["func process(ctx context.Context) {"]
  N19["userID := ctx.Value(\"user_id\")"]
  N20["child(ctx) 顯式傳遞"]
  N21["優點: 資料流向清晰，易於測試"]
  N22["缺點: 所有函式都需要加 ctx 參數"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N3 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
</code></pre>
<p>InheritableThreadLocal 可在建立子執行緒時複製上下文。</p>
<p>跨語言對比：</p>
<ul>
<li>C/C++: <code>thread_local</code> — 關鍵字宣告，編譯器自動為每個執行緒分配獨立儲存</li>
<li>Rust: <code>thread_local!</code> — 宏定義，支援懶初始化</li>
<li>Go: 常用 <code>context.Context</code> 顯式傳遞，不鼓勵隱式 thread local；這反映了 Go 「明確優於隱式」的設計哲學</li>
</ul>
<pre><code class="language-text">Thread A: user_id=42
Thread B: user_id=? (預設拿不到 A 的值)
</code></pre>
<h2 id="跨語言完整範例-13"><a class="header" href="#跨語言完整範例-13">跨語言完整範例</a></h2>
<p>執行緒本地儲存：每個執行緒有自己的 user_id，互不干擾，演示隔離性。</p>
<h3 id="c-6"><a class="header" href="#c-6">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch14_c ch14.c &amp;&amp; ./ch14_c */
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

/* thread_local 在 C11 中為 _Thread_local，gcc 支援 __thread */
static __thread int user_id = 0;

typedef struct { int set_id; const char *name; } Args;

void *thread_fn(void *arg) {
    Args *a = (Args *)arg;
    user_id = a-&gt;set_id;                  /* 只影響當前執行緒 */
    usleep(10000);                         /* 讓其他執行緒也設定自己的值 */
    printf("%-10s user_id=%d\n", a-&gt;name, user_id);
    return NULL;
}

int main(void) {
    Args args[] = {{42, "Thread-A"}, {7, "Thread-B"}, {100, "Thread-C"}};
    pthread_t threads[3];

    for (int i = 0; i &lt; 3; i++)
        pthread_create(&amp;threads[i], NULL, thread_fn, &amp;args[i]);
    for (int i = 0; i &lt; 3; i++)
        pthread_join(threads[i], NULL);

    printf("Main thread user_id=%d (never set, remains 0)\n", user_id);
    return 0;
}
</code></pre>
<h3 id="c-7"><a class="header" href="#c-7">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch14_cpp ch14.cpp &amp;&amp; ./ch14_cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;

thread_local int user_id = 0;          // 每個執行緒各自的 user_id
thread_local std::string request_id;   // 每個執行緒各自的 request_id

void handle_request(int uid, const std::string &amp;rid) {
    user_id    = uid;
    request_id = rid;
    std::this_thread::sleep_for(std::chrono::milliseconds(10));

    // 讀回自己的值，不受其他執行緒影響
    std::cout &lt;&lt; "Thread " &lt;&lt; std::this_thread::get_id()
              &lt;&lt; " user_id=" &lt;&lt; user_id
              &lt;&lt; " request_id=" &lt;&lt; request_id &lt;&lt; "\n";
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    threads.emplace_back(handle_request, 42,  "req-001");
    threads.emplace_back(handle_request, 7,   "req-002");
    threads.emplace_back(handle_request, 100, "req-003");
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "main thread: user_id=" &lt;&lt; user_id
              &lt;&lt; " (0，從未設定)\n";
    return 0;
}
</code></pre>
<h3 id="rust-3"><a class="header" href="#rust-3">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch14.rs -o ch14 &amp;&amp; ./ch14
use std::cell::RefCell;
use std::thread;

thread_local! {
    static USER_ID:    RefCell&lt;i32&gt;     = RefCell::new(0);
    static REQUEST_ID: RefCell&lt;String&gt;  = RefCell::new(String::new());
}

fn handle_request(uid: i32, rid: &amp;'static str) {
    USER_ID.with(|u| *u.borrow_mut() = uid);
    REQUEST_ID.with(|r| *r.borrow_mut() = rid.to_string());

    thread::sleep(std::time::Duration::from_millis(10));

    USER_ID.with(|u| {
        REQUEST_ID.with(|r| {
            println!("thread {:?}: user_id={}, request_id={}",
                     thread::current().id(), u.borrow(), r.borrow());
        });
    });
}

fn main() {
    let handles: Vec&lt;_&gt; = vec![
        (42,  "req-001"),
        (7,   "req-002"),
        (100, "req-003"),
    ].into_iter().map(|(uid, rid)| {
        thread::spawn(move || handle_request(uid, rid))
    }).collect();

    for h in handles { h.join().unwrap(); }
    USER_ID.with(|u| println!("main: user_id={} (0，從未設定)", u.borrow()));
}</code></pre></pre>
<h3 id="go-3"><a class="header" href="#go-3">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch14.go
// Go 不推薦隱式 thread-local，改用 context.Context 顯式傳遞
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

type contextKey string

const keyUserID    contextKey = "user_id"
const keyRequestID contextKey = "request_id"

// handleRequest 接收 context，從中讀取執行緒「本地」資料
// 這是 Go 的慣用做法：顯式傳遞，不依賴隱式 goroutine-local
func handleRequest(ctx context.Context, wg *sync.WaitGroup) {
	defer wg.Done()
	time.Sleep(10 * time.Millisecond)

	uid := ctx.Value(keyUserID)
	rid := ctx.Value(keyRequestID)
	fmt.Printf("goroutine: user_id=%v, request_id=%v\n", uid, rid)
}

func main() {
	var wg sync.WaitGroup
	requests := []struct {
		userID    int
		requestID string
	}{
		{42, "req-001"},
		{7, "req-002"},
		{100, "req-003"},
	}

	for _, req := range requests {
		ctx := context.WithValue(context.Background(), keyUserID, req.userID)
		ctx = context.WithValue(ctx, keyRequestID, req.requestID)
		wg.Add(1)
		go handleRequest(ctx, &amp;wg)
	}
	wg.Wait()
	fmt.Println("Done — Go 使用 context 顯式傳遞，語意清晰")
}
</code></pre>
<h3 id="python-3"><a class="header" href="#python-3">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch14.py
import threading
import time


# threading.local() 為每個執行緒提供獨立的命名空間
local_storage = threading.local()


def handle_request(user_id: int, request_id: str):
    """每個執行緒設定自己的 local 變數，互不干擾。"""
    local_storage.user_id    = user_id
    local_storage.request_id = request_id
    time.sleep(0.01)   # 讓其他執行緒也在設定自己的值

    # 讀回自己設定的值
    print(f"{threading.current_thread().name}: "
          f"user_id={local_storage.user_id}, "
          f"request_id={local_storage.request_id}")


if __name__ == "__main__":
    requests = [(42, "req-001"), (7, "req-002"), (100, "req-003")]
    threads = [
        threading.Thread(target=handle_request, args=(uid, rid),
                         name=f"Thread-{i}")
        for i, (uid, rid) in enumerate(requests)
    ]
    for t in threads: t.start()
    for t in threads: t.join()

    # 主執行緒從未設定，讀取會拋出 AttributeError
    try:
        print(f"main: user_id={local_storage.user_id}")
    except AttributeError:
        print("main: user_id 未設定（符合預期，各執行緒隔離）")
</code></pre>
<h2 id="完整專案級範例python-13"><a class="header" href="#完整專案級範例python-13">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch14.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch14.py
</code></pre>
<pre><code class="language-python">"""Chapter 14: thread local — 執行緒本地儲存，每個執行緒持有獨立副本。"""
import threading

local = threading.local()


def run(name: str, uid: int):
    """設定執行緒本地的 user_id，讀回時只看到自己設定的值。"""
    local.user_id = uid
    # 即使其他執行緒同時修改各自的 user_id，這裡讀到的仍是自己的值
    print(f"{name} user_id={local.user_id}")


if __name__ == "__main__":
    t1 = threading.Thread(target=run, args=("T1", 42))
    t2 = threading.Thread(target=run, args=("T2", 7))
    t1.start(); t2.start(); t1.join(); t2.join()
    # 主執行緒從未設定，驗證隔離性
    try:
        print(f"main user_id={local.user_id}")
    except AttributeError:
        print("main: user_id 不存在（各執行緒完全隔離）")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第15章-手寫線程池實戰"><a class="header" href="#第15章-手寫線程池實戰">第15章 手寫線程池實戰</a></h1>
<h2 id="151-結構設計"><a class="header" href="#151-結構設計">15.1 結構設計</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-59"><a class="header" href="#本小節示意圖-59">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["ThreadPool 核心組件圖"]
  N2["ThreadPool"]
  N3["state: AtomicInteger"]
  N4["RUNNING SHUTDOWN STOP TERMINATED"]
  N5["控制"]
  N6["task_queue workers"]
  N7["BlockingQueue Set&amp;lt;Thread&amp;gt;"]
  N8["協作"]
  N9["[Task][Task] poll() [W1][W2][W3][W4]"]
  N10["[Task][Task] ↑執行任務↑"]
  N11["submit()"]
  N12["飽和時觸發"]
  N13["外部呼叫方 reject_policy"]
  N14["(Producer) RejectedExecutionHandler"]
  N15["Abort / CallerRuns / Discard"]
  N16["組件職責"]
  N17["• task_queue: 緩衝待執行任務，解耦生產者與消費者"]
  N18["• workers: 實際執行任務的執行緒集合，數量在 [core, max] 間調整"]
  N19["• state: 協調關閉流程，防止競態"]
  N20["• reject_policy: 佇列+執行緒都滿時的降級策略"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
</code></pre>
<p>需要的核心欄位：</p>
<ul>
<li><strong>任務佇列（task_queue）</strong>：BlockingQueue，生產者 submit 入佇，worker 出佇執行</li>
<li><strong>worker 集合（workers）</strong>：追蹤所有活躍執行緒，用於關閉時中斷</li>
<li><strong>運行狀態（state）</strong>：AtomicInteger，防止在關閉中繼續接受任務</li>
<li><strong>拒絕策略（reject_policy）</strong>：飽和時的處理方式，預設拋出例外</li>
</ul>
<h2 id="152-worker-邏輯"><a class="header" href="#152-worker-邏輯">15.2 Worker 邏輯</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-60"><a class="header" href="#本小節示意圖-60">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Worker 主循環流程圖"]
  N2["Worker 執行緒啟動"]
  N3["loop（主循環）"]
  N4["task = queue.poll(keepAliveTime)"]
  N5["（等待最多 keepAliveTime 超時）"]
  N6["task != null?"]
  N7["是 否（等待超時）"]
  N8["是否為核心執行緒？"]
  N9["execute()"]
  N10["task 是 否（非核心）"]
  N11["繼續等待， workers.size &amp;gt; core?"]
  N12["不退出"]
  N13["是 否"]
  N14["繼續等待"]
  N15["退出 loop 不退出"]
  N16["workers."]
  N17["remove(this)"]
  N18["shutdown?"]
  N19["pool.state == SHUTDOWN"]
  N20["且 queue 已空 退出"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N5 --&gt; N6
  N5 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N10 --&gt; N11
  N10 --&gt; N12
  N10 --&gt; N13
  N10 --&gt; N14
  N10 --&gt; N15
  N10 --&gt; N16
  N10 --&gt; N17
  N10 --&gt; N18
  N18 --&gt; N19
  N18 --&gt; N20
</code></pre>
<p>worker 持續從佇列取任務執行，遇到關閉訊號退出。</p>
<p>Worker 的關鍵設計點：</p>
<ol>
<li><strong>keepAlive 超時</strong>：非核心執行緒等待超過 keepAliveTime 後縮容退出，避免資源浪費</li>
<li><strong>中斷響應</strong>：<code>shutdownNow()</code> 時送出中斷，worker 的 <code>poll()</code> 會拋出 <code>InterruptedException</code> 並退出</li>
<li><strong>退出清理</strong>：worker 退出前從 <code>workers</code> 集合中移除自己，並在必要時判斷是否需要觸發 <code>TERMINATED</code> 狀態</li>
</ol>
<h2 id="153-提交與關閉對應-15311536"><a class="header" href="#153-提交與關閉對應-15311536">15.3 提交與關閉（對應 15.3.1~15.3.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-61"><a class="header" href="#本小節示意圖-61">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["submit(task) 流程圖"]
  N2["submit(task)"]
  N3["state == RUNNING ?"]
  N4["是 否（SHUTDOWN/STOP）"]
  N5["queue.offer reject(task)"]
  N6["(task) 成功? RejectedExecution"]
  N7["是 否（佇列滿）"]
  N8["返回 workers.size &amp;lt; maxPoolSize?"]
  N9["是 否"]
  N10["新建 Worker reject(task)"]
  N11["執行此任務 （飽和拒絕）"]
  N12["shutdown() 流程圖"]
  N13["shutdown()"]
  N14["1. 原子設定 state = SHUTDOWN"]
  N15["2. 中斷所有閒置 workers（喚醒正在 poll() 等待的執行緒）"]
  N16["3. 不再接受新的 submit()"]
  N17["4. 等待佇列排空 + workers 歸零 轉入 TERMINATED"]
  N18["（可用 awaitTermination() 阻塞等待）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N3 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N6 --&gt; N7
  N0 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N13 --&gt; N14
  N13 --&gt; N15
  N13 --&gt; N16
  N13 --&gt; N17
  N17 --&gt; N18
</code></pre>
<ul>
<li><strong>submit</strong>：放入佇列或觸發拒絕</li>
<li><strong>shutdown</strong>：停止收新任務，排空後結束</li>
</ul>
<p>關閉的正確姿勢是先呼叫 <code>shutdown()</code>，再以迴圈呼叫 <code>awaitTermination()</code> 直到返回 <code>true</code> 或超時強制中斷（<code>shutdownNow()</code>）。</p>
<h2 id="154-測試"><a class="header" href="#154-測試">15.4 測試</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-62"><a class="header" href="#本小節示意圖-62">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["測試場景清單與期望行為"]
  N2["場景 1: 正常提交"]
  N3["操作: 提交 N 個任務（N ≤ queue capacity）"]
  N4["期望: 所有任務按完成，無例外，result 集合 size == N"]
  N5["場景 2: 飽和拒絕"]
  N6["操作: workers 全忙 + 佇列滿時繼續提交"]
  N7["期望: 觸發 RejectedExecutionException（或自定義策略動作）"]
  N8["驗證: 已進入佇列的任務仍能正常完成"]
  N9["場景 3: 優雅關閉（shutdown）"]
  N10["操作: 提交 N 個任務後立即 shutdown()"]
  N11["期望: 所有已提交任務執行完畢，awaitTermination 返回 true"]
  N12["禁止: shutdown 後再 submit 拋出 RejectedExecutionException"]
  N13["場景 4: 強制中斷（shutdownNow）"]
  N14["操作: 任務執行中呼叫 shutdownNow()"]
  N15["期望: 返回未執行任務列表，正在執行的任務收到中斷訊號"]
  N16["驗證: list.size == 未執行任務數量"]
  N17["場景 5: keepAlive 縮容"]
  N18["操作: 高峰期超過 coreSize，低峰期閒置超過 keepAliveTime"]
  N19["期望: 非核心執行緒自動退出，workers.size 降回 coreSize"]
  N20["驗證: 等待 keepAliveTime + buffer 後檢查 activeCount"]
  N21["壓測指標"]
  N22["吞吐量 tasks/second，對比序列執行的加速比"]
  N23["延遲 P99 第 99 百分位任務完成時間，反映長尾效能"]
  N24["拒絕比例 rejected / total，評估參數設定是否合理"]
  N25["佇列水位 queue.size() 峰值，評估是否需要擴容"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N0 --&gt; N15
  N0 --&gt; N16
  N0 --&gt; N17
  N0 --&gt; N18
  N0 --&gt; N19
  N0 --&gt; N20
  N0 --&gt; N21
  N0 --&gt; N22
  N0 --&gt; N23
  N0 --&gt; N24
  N0 --&gt; N25
</code></pre>
<p>壓測觀察吞吐、延遲、拒絕比例。</p>
<p>測試線程池時需涵蓋正常路徑和各種邊界情況。特別注意關閉時的競態：<code>shutdown()</code> 和最後一個任務完成之間存在時間視窗，測試需等待 <code>awaitTermination()</code> 返回 <code>true</code> 才能斷言結果。</p>
<pre><code class="language-text">while (running) {
  task = queue.pop()
  run(task)
}
</code></pre>
<h2 id="跨語言完整範例-14"><a class="header" href="#跨語言完整範例-14">跨語言完整範例</a></h2>
<p>最簡執行緒池：channel 做佇列，N 個 goroutine/thread 做 worker，展示核心機制。</p>
<h3 id="c-8"><a class="header" href="#c-8">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch15_c ch15.c &amp;&amp; ./ch15_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdatomic.h&gt;

#define WORKERS   4
#define TASKS     20
#define QCAP      64

typedef struct { int id; } Task;

/* 環形緩衝佇列 */
typedef struct {
    Task        buf[QCAP];
    int         head, tail, size;
    pthread_mutex_t mu;
    pthread_cond_t  not_empty;
    atomic_int  shutdown;
    atomic_int  completed;
} Pool;

static Pool pool;

static void pool_init(void) {
    pool.head = pool.tail = pool.size = 0;
    atomic_store(&amp;pool.shutdown, 0);
    atomic_store(&amp;pool.completed, 0);
    pthread_mutex_init(&amp;pool.mu, NULL);
    pthread_cond_init(&amp;pool.not_empty, NULL);
}

static void pool_submit(int task_id) {
    pthread_mutex_lock(&amp;pool.mu);
    pool.buf[pool.tail] = (Task){task_id};
    pool.tail = (pool.tail + 1) % QCAP;
    pool.size++;
    pthread_cond_signal(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);
}

static void *worker_loop(void *arg) {
    int wid = *(int *)arg;
    for (;;) {
        pthread_mutex_lock(&amp;pool.mu);
        while (pool.size == 0 &amp;&amp; !atomic_load(&amp;pool.shutdown))
            pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
        if (pool.size == 0) {           /* shutdown + 空佇列 */
            pthread_mutex_unlock(&amp;pool.mu);
            break;
        }
        Task t = pool.buf[pool.head];
        pool.head = (pool.head + 1) % QCAP;
        pool.size--;
        pthread_mutex_unlock(&amp;pool.mu);

        usleep(20000);                  /* 模擬 20ms 工作 */
        int done = atomic_fetch_add(&amp;pool.completed, 1) + 1;
        printf("Worker%d finished task %2d (total done: %d)\n",
               wid, t.id, done);
    }
    return NULL;
}

int main(void) {
    pool_init();
    pthread_t threads[WORKERS];
    int ids[WORKERS];
    for (int i = 0; i &lt; WORKERS; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker_loop, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASKS; i++) {
        pool_submit(i);
    }
    /* 等佇列排空後再 shutdown */
    pthread_mutex_lock(&amp;pool.mu);
    while (pool.size &gt; 0)
        pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
    atomic_store(&amp;pool.shutdown, 1);
    pthread_cond_broadcast(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);

    for (int i = 0; i &lt; WORKERS; i++) pthread_join(threads[i], NULL);
    printf("All %d tasks done.\n", atomic_load(&amp;pool.completed));
    return 0;
}
</code></pre>
<h3 id="c-9"><a class="header" href="#c-9">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch15_cpp ch15.cpp &amp;&amp; ./ch15_cpp
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;atomic&gt;

class SimpleThreadPool {
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::vector&lt;std::thread&gt; workers;
    std::mutex mu;
    std::condition_variable cv;
    bool stopped = false;
    std::atomic&lt;int&gt; completed{0};

public:
    explicit SimpleThreadPool(int n) {
        for (int i = 0; i &lt; n; i++) {
            workers.emplace_back([this, i] {
                for (;;) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock lk(mu);
                        cv.wait(lk, [this]{ return stopped || !tasks.empty(); });
                        if (stopped &amp;&amp; tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                    completed++;
                }
            });
        }
    }

    void submit(std::function&lt;void()&gt; f) {
        { std::lock_guard lk(mu); tasks.push(std::move(f)); }
        cv.notify_one();
    }

    int done_count() const { return completed.load(); }

    void shutdown() {
        { std::lock_guard lk(mu); stopped = true; }
        cv.notify_all();
        for (auto &amp;t : workers) t.join();
    }
};

int main() {
    SimpleThreadPool pool(4);
    std::mutex print_mu;

    for (int i = 0; i &lt; 20; i++) {
        pool.submit([i, &amp;print_mu, &amp;pool] {
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
            std::lock_guard lk(print_mu);
            std::cout &lt;&lt; "Task " &lt;&lt; std::setw(2) &lt;&lt; i
                      &lt;&lt; " done, total=" &lt;&lt; pool.done_count() + 1 &lt;&lt; "\n";
        });
    }
    pool.shutdown();
    std::cout &lt;&lt; "All tasks completed, total=" &lt;&lt; pool.done_count() &lt;&lt; "\n";
    return 0;
}
</code></pre>
<h3 id="rust-4"><a class="header" href="#rust-4">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch15.rs -o ch15 &amp;&amp; ./ch15
use std::sync::{Arc, Mutex, Condvar};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;
use std::collections::VecDeque;

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

struct SimplePool {
    queue:     Mutex&lt;VecDeque&lt;Option&lt;Job&gt;&gt;&gt;,
    cv:        Condvar,
    completed: AtomicUsize,
}

impl SimplePool {
    fn new() -&gt; Arc&lt;Self&gt; {
        Arc::new(SimplePool {
            queue:     Mutex::new(VecDeque::new()),
            cv:        Condvar::new(),
            completed: AtomicUsize::new(0),
        })
    }

    fn submit(self: &amp;Arc&lt;Self&gt;, f: impl FnOnce() + Send + 'static) {
        self.queue.lock().unwrap().push_back(Some(Box::new(f)));
        self.cv.notify_one();
    }

    fn spawn_workers(self: &amp;Arc&lt;Self&gt;, n: usize) -&gt; Vec&lt;thread::JoinHandle&lt;()&gt;&gt; {
        (0..n).map(|_| {
            let pool = Arc::clone(self);
            thread::spawn(move || loop {
                let job = {
                    let mut q = pool.cv
                        .wait_while(pool.queue.lock().unwrap(), |q| q.is_empty())
                        .unwrap();
                    q.pop_front().unwrap()
                };
                match job {
                    Some(f) =&gt; { f(); pool.completed.fetch_add(1, Ordering::Relaxed); }
                    None    =&gt; break,
                }
            })
        }).collect()
    }

    fn shutdown(self: &amp;Arc&lt;Self&gt;, handles: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;, n: usize) {
        for _ in 0..n {
            self.queue.lock().unwrap().push_back(None);
            self.cv.notify_one();
        }
        for h in handles { h.join().unwrap(); }
    }
}

fn main() {
    const WORKERS: usize = 4;
    const TASKS:   usize = 20;

    let pool = SimplePool::new();
    let handles = pool.spawn_workers(WORKERS);

    for i in 0..TASKS {
        let p = Arc::clone(&amp;pool);
        pool.submit(move || {
            thread::sleep(std::time::Duration::from_millis(20));
            let done = p.completed.load(Ordering::Relaxed) + 1;
            println!("Task {:2} done, completed so far: {}", i, done);
        });
    }
    pool.shutdown(handles, WORKERS);
    println!("Total completed: {}", pool.completed.load(Ordering::Relaxed));
}</code></pre></pre>
<h3 id="go-4"><a class="header" href="#go-4">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch15.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

// SimplePool：channel 作為任務佇列，goroutine 作為 worker
type SimplePool struct {
	jobs      chan func()
	wg        sync.WaitGroup
	completed int64
}

func NewPool(workers, queueSize int) *SimplePool {
	p := &amp;SimplePool{jobs: make(chan func(), queueSize)}
	for i := 0; i &lt; workers; i++ {
		workerID := i
		go func() {
			for job := range p.jobs {
				job()
				atomic.AddInt64(&amp;p.completed, 1)
				fmt.Printf("  Worker%d: task done (total=%d)\n",
					workerID, atomic.LoadInt64(&amp;p.completed))
			}
		}()
	}
	return p
}

func (p *SimplePool) Submit(f func()) {
	p.wg.Add(1)
	p.jobs &lt;- func() {
		defer p.wg.Done()
		f()
	}
}

func (p *SimplePool) Shutdown() {
	p.wg.Wait()
	close(p.jobs)
}

func main() {
	const numWorkers = 4
	const numTasks   = 20

	pool := NewPool(numWorkers, 64)
	for i := 0; i &lt; numTasks; i++ {
		taskID := i
		pool.Submit(func() {
			time.Sleep(20 * time.Millisecond)
			_ = taskID
		})
	}
	pool.Shutdown()
	fmt.Printf("All done, completed=%d\n", atomic.LoadInt64(&amp;pool.completed))
}
</code></pre>
<h3 id="python-4"><a class="header" href="#python-4">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch15.py
import queue
import threading
import time
from typing import Callable


class SimpleThreadPool:
    """最簡執行緒池：queue 做佇列，Thread 做 worker。"""

    def __init__(self, num_workers: int, queue_size: int = 64):
        self._queue = queue.Queue(maxsize=queue_size)
        self._completed = 0
        self._lock = threading.Lock()
        self._workers = [
            threading.Thread(target=self._worker_loop, name=f"Worker-{i}",
                             daemon=True)
            for i in range(num_workers)
        ]
        for w in self._workers:
            w.start()

    def _worker_loop(self):
        """Worker 主循環：不斷從佇列取任務並執行。"""
        while True:
            task = self._queue.get()
            if task is None:        # None 作為關閉訊號
                self._queue.task_done()
                break
            try:
                task()
                with self._lock:
                    self._completed += 1
                    print(f"{threading.current_thread().name}: "
                          f"task done (total={self._completed})")
            finally:
                self._queue.task_done()

    def submit(self, fn: Callable):
        self._queue.put(fn)

    def shutdown(self):
        """等待所有任務完成後關閉。"""
        self._queue.join()          # 等佇列排空
        for _ in self._workers:
            self._queue.put(None)   # 每個 worker 一個停止訊號
        for w in self._workers:
            w.join()
        return self._completed


if __name__ == "__main__":
    pool = SimpleThreadPool(num_workers=4, queue_size=64)

    for i in range(20):
        def make_task(task_id):
            def task():
                time.sleep(0.02)
                _ = task_id     # 實際工作
            return task
        pool.submit(make_task(i))

    total = pool.shutdown()
    print(f"All tasks completed, total={total}")
</code></pre>
<h2 id="完整專案級範例python-14"><a class="header" href="#完整專案級範例python-14">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch15.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch15.py
</code></pre>
<pre><code class="language-python">"""Chapter 15: custom thread pool — 手動實作執行緒池的核心機制。"""
import queue
import threading

q = queue.Queue()
stop = object()              # 哨兵值，用來通知 worker 退出


def worker():
    """Worker 主循環：取任務執行，遇到 stop 哨兵則退出。"""
    while True:
        task = q.get()
        if task is stop:
            q.task_done()
            return
        try:
            task()
        finally:
            q.task_done()


if __name__ == "__main__":
    num_workers = 3
    workers = [threading.Thread(target=worker, daemon=True)
               for _ in range(num_workers)]
    for w in workers: w.start()

    # 提交 5 個任務
    for i in range(5):
        task_id = i
        q.put(lambda tid=task_id: print(f"task {tid} on {threading.current_thread().name}"))

    # 等所有任務完成，再送停止訊號
    q.join()
    for _ in workers: q.put(stop)
    for w in workers: w.join()
    print("pool shutdown complete")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第16章-cas-自旋鎖實戰"><a class="header" href="#第16章-cas-自旋鎖實戰">第16章 CAS 自旋鎖實戰</a></h1>
<h2 id="161-目標"><a class="header" href="#161-目標">16.1 目標</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-63"><a class="header" href="#本小節示意圖-63">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["三種鎖模式對比"]
  N2["鎖模式適用場景比較"]
  N3["Lock-free Spin Lock OS Mutex"]
  N4["CAS"]
  N5["無阻塞 短臨界區 長臨界區"]
  N6["全自旋 適合高頻鎖 適合 I/O、DB 等耗時操作"]
  N7["CPU 一直轉 等待期間 等待時讓出 CPU"]
  N8["不切換執行緒 CPU 仍在燃燒 有上下文切換開銷"]
  N9["臨界區極短 臨界區 &amp;lt; 幾 臨界區 &amp;gt; 幾微秒"]
  N10["衝突極低 微秒，低衝突 衝突較高"]
  N11["適合計數器 適合 cache 適合資料庫操作"]
  N12["CPU 效率 CPU 效率 CPU 效率"]
  N13["(高衝突時差) (中度場景佳) (等待時釋放CPU)"]
  N14["適用場景判斷流程"]
  N15["臨界區有多長？"]
  N16["&amp;lt; 1 微秒 CAS / Lock-free（無鎖化）"]
  N17["1~10 微秒 Spin Lock（自旋）"]
  N18["&amp;gt; 10 微秒 OS Mutex（阻塞等待）"]
  N0 --&gt; N1
  N0 --&gt; N2
  N0 --&gt; N3
  N0 --&gt; N4
  N0 --&gt; N5
  N0 --&gt; N6
  N0 --&gt; N7
  N0 --&gt; N8
  N0 --&gt; N9
  N0 --&gt; N10
  N0 --&gt; N11
  N0 --&gt; N12
  N0 --&gt; N13
  N0 --&gt; N14
  N14 --&gt; N15
  N15 --&gt; N16
  N15 --&gt; N17
  N15 --&gt; N18
</code></pre>
<p>用最少原語實作可用鎖，理解 lock-free 與 spin 的邊界。</p>
<h2 id="162-核心做法"><a class="header" href="#162-核心做法">16.2 核心做法</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-64"><a class="header" href="#本小節示意圖-64">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["自旋鎖 CAS 流程圖"]
  N2["flag = 0（free） flag = 1（held）"]
  N3["atomic_flag / AtomicBool"]
  N4["初始值 = 0（free）"]
  N5["lock() 流程"]
  N6["CAS(0 1)"]
  N7["Thread 成功 進入"]
  N8["嘗試鎖 臨界區"]
  N9["CAS(0 1) 失敗"]
  N10["自旋等待迴圈"]
  N11["memory_order_"]
  N12["while (flag != 0) { acquire"]
  N13["[pause / yield] CPU 提示 確保後續讀到"]
  N14["} 最新資料"]
  N15["再試 CAS(0 1)"]
  N16["unlock() 流程"]
  N17["store(0)"]
  N18["Thread flag = 0（free）"]
  N19["持有者 memory_order_ 其他執行緒可競爭"]
  N20["release"]
  N21["確保前面寫入"]
  N22["對其他執行緒可見"]
  N23["memory_order 位置"]
  N24["lock() acquire 防止後方讀寫被提前到 lock 前"]
  N25["unlock() release 防止前方寫入被延遲到 unlock 後"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
</code></pre>
<p>用 <code>atomic_flag</code> 或 CAS 標記鎖是否被占用。</p>
<h2 id="163-自旋成本"><a class="header" href="#163-自旋成本">16.3 自旋成本</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-65"><a class="header" href="#本小節示意圖-65">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["低衝突 vs 高衝突時間軸"]
  N2["低衝突場景（臨界區極短）"]
  N3["時間"]
  N4["T+0 T+1us T+2us T+3us T+4us"]
  N5["T1 [鎖][工作][解鎖]"]
  N6["T2 [鎖][工作][解鎖]"]
  N7["T3 [鎖][工作][解鎖]"]
  N8["T4 [鎖][工作]..."]
  N9["CPU ░░░░░ ░░░░░ ░░░░░"]
  N10["有效 空閒 有效 空閒"]
  N11["效率高，自旋時間幾乎為零"]
  N12["高衝突場景（多核競爭同一鎖）"]
  N13["時間"]
  N14["T+0 T+10us T+20us T+30us T+40us"]
  N15["T1 [鎖 工作 ][解鎖]"]
  N16["T2 [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥][鎖 工作 ][解]"]
  N17["T3 [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥][鎖 ]"]
  N18["T4 [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥]"]
  N19["Core 使用率"]
  N20["Core1 100%（T1 真正工作）"]
  N21["Core2 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T2 白燒自旋）"]
  N22["Core3 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T3 白燒自旋）"]
  N23["Core4 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T4 白燒自旋）"]
  N24["CPU 使用率 100% 但 75% 是無效功！"]
  N25["高衝突下 Spin Lock 的問題"]
  N26["・多個 Core 同時在旋轉 浪費電力與 CPU 時間"]
  N27["・Cache coherence 流量激增 總線飽和"]
  N28["・其他任務無法使用被佔用的 Core"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N3 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N9 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N13 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N23 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
</code></pre>
<p>低衝突很快；高衝突會燒 CPU。</p>
<h2 id="164-工程補強"><a class="header" href="#164-工程補強">16.4 工程補強</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-66"><a class="header" href="#本小節示意圖-66">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["自旋退避策略演進圖"]
  N2["自旋失敗次數"]
  N3["0 1 2 4 8 16 閾值"]
  N4["Plain 立即重試 CAS"]
  N5["Spin 延遲 = 0"]
  N6["失敗"]
  N7["yield() 讓出 CPU 時間片，讓持鎖者跑"]
  N8["延遲 ≈ 1 排程週期（~100us）"]
  N9["仍失敗"]
  N10["Exponential Backoff"]
  N11["delay = min(1ms × 2^n,"]
  N12["max_delay)"]
  N13["retry 1: sleep 1ms"]
  N14["retry 2: sleep 2ms"]
  N15["retry 3: sleep 4ms"]
  N16["retry 4: sleep 8ms 抖動 (jitter) 避免"]
  N17["retry 5: sleep 16ms 所有執行緒同時重試"]
  N18["超過閾值（例如 64ms）"]
  N19["park() / futex_wait()"]
  N20["執行緒進入睡眠"]
  N21["OS 排程器管理"]
  N22["鎖釋放時 unpark() 喚醒"]
  N23["CPU 完全釋放 零燒耗"]
  N24["自旋次數 vs 退避延遲關係"]
  N25["延遲"]
  N26["(ms)"]
  N27["64 park 阻塞"]
  N28["32"]
  N29["16"]
  N30["8"]
  N31["4"]
  N32["2"]
  N33["1"]
  N34["0 yield"]
  N35["自旋次數"]
  N36["0 2 4 8 16 32 閾值"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N5 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N8 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N17 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
  N1 --&gt; N29
  N29 --&gt; N30
  N29 --&gt; N31
  N29 --&gt; N32
  N29 --&gt; N33
  N29 --&gt; N34
  N34 --&gt; N35
  N35 --&gt; N36
</code></pre>
<ul>
<li>指數退避（backoff）</li>
<li>達到閾值後改阻塞</li>
</ul>
<pre><code class="language-text">try CAS(lock, 0, 1)
fail -&gt; pause -&gt; retry
</code></pre>
<h2 id="示意圖-10"><a class="header" href="#示意圖-10">示意圖</a></h2>
<pre><code class="language-text">lock flag=0
T1 CAS(0-&gt;1) success 進入
T2 CAS(0-&gt;1) fail 自旋等待
</code></pre>
<h2 id="跨語言完整範例-15"><a class="header" href="#跨語言完整範例-15">跨語言完整範例</a></h2>
<h3 id="c--atomic_flag-自旋鎖4-執行緒並發測試"><a class="header" href="#c--atomic_flag-自旋鎖4-執行緒並發測試">C — atomic_flag 自旋鎖，4 執行緒並發測試</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;

#define THREADS 4
#define ITERS   50000

atomic_flag spin_lock = ATOMIC_FLAG_INIT;
long counter = 0;

void lock(void) {
    while (atomic_flag_test_and_set_explicit(&amp;spin_lock, memory_order_acquire))
        ;  /* spin */
}

void unlock(void) {
    atomic_flag_clear_explicit(&amp;spin_lock, memory_order_release);
}

void *worker(void *arg) {
    (void)arg;
    for (int i = 0; i &lt; ITERS; i++) {
        lock();
        counter++;
        unlock();
    }
    return NULL;
}

int main(void) {
    pthread_t tids[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tids[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tids[i], NULL);
    printf("counter = %ld (expected %d)\n", counter, THREADS * ITERS);
    return 0;
}
</code></pre>
<h3 id="c--stdatomic_flag-自旋鎖封裝"><a class="header" href="#c--stdatomic_flag-自旋鎖封裝">C++ — std::atomic_flag 自旋鎖封裝</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

class SpinLock {
    std::atomic_flag flag_ = ATOMIC_FLAG_INIT;
public:
    void lock() {
        while (flag_.test_and_set(std::memory_order_acquire))
            ;  /* spin */
    }
    void unlock() {
        flag_.clear(std::memory_order_release);
    }
};

int main() {
    SpinLock spin;
    long counter = 0;
    const int iters = 50000;
    auto task = [&amp;]() {
        for (int i = 0; i &lt; iters; i++) {
            spin.lock();
            counter++;
            spin.unlock();
        }
    };
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++)
        threads.emplace_back(task);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; 4 * iters &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rust--atomicbool-cas-自旋鎖"><a class="header" href="#rust--atomicbool-cas-自旋鎖">Rust — AtomicBool CAS 自旋鎖</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;

struct SpinLock(AtomicBool);

impl SpinLock {
    fn new() -&gt; Self { SpinLock(AtomicBool::new(false)) }
    fn lock(&amp;self) {
        while self.0
            .compare_exchange_weak(false, true, Ordering::Acquire, Ordering::Relaxed)
            .is_err()
        {
            std::hint::spin_loop();
        }
    }
    fn unlock(&amp;self) {
        self.0.store(false, Ordering::Release);
    }
}

fn main() {
    let spin = Arc::new(SpinLock::new());
    let counter = Arc::new(std::sync::atomic::AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..4 {
        let spin = Arc::clone(&amp;spin);
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..50_000 {
                spin.lock();
                counter.fetch_add(1, Ordering::Relaxed);
                spin.unlock();
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected 200000)", counter.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--atomicbool-cas-自旋鎖"><a class="header" href="#go--atomicbool-cas-自旋鎖">Go — atomic.Bool CAS 自旋鎖</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

type SpinLock struct{ held atomic.Bool }

func (s *SpinLock) Lock() {
    for !s.held.CompareAndSwap(false, true) {
        // spin
    }
}

func (s *SpinLock) Unlock() {
    s.held.Store(false)
}

func main() {
    var spin SpinLock
    var counter int64
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j &lt; 50_000; j++ {
                spin.Lock()
                counter++
                spin.Unlock()
            }
        }()
    }
    wg.Wait()
    fmt.Printf("counter = %d (expected 200000)\n", counter)
}
</code></pre>
<h3 id="python--ctypes-atomic-模擬-cas-自旋鎖"><a class="header" href="#python--ctypes-atomic-模擬-cas-自旋鎖">Python — ctypes atomic 模擬 CAS 自旋鎖</a></h3>
<pre><code class="language-python">"""Chapter 16: CAS spin lock — 4 threads, atomic counter verification."""
import threading
import time


class SpinLock:
    """用 threading.Lock 模擬 CAS atomic_flag 語意。"""

    def __init__(self):
        self._held = False
        self._internal = threading.Lock()

    def lock(self):
        while True:
            with self._internal:
                if not self._held:
                    self._held = True
                    return
            time.sleep(0)  # yield

    def unlock(self):
        with self._internal:
            self._held = False


def main():
    spin = SpinLock()
    counter = [0]
    iters = 50_000

    def worker():
        for _ in range(iters):
            spin.lock()
            counter[0] += 1
            spin.unlock()

    threads = [threading.Thread(target=worker) for _ in range(4)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    expected = 4 * iters
    print(f"counter = {counter[0]} (expected {expected})")
    assert counter[0] == expected, "競態條件！CAS 保護失效"
    print("通過：自旋鎖保護臨界區正確")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-15"><a class="header" href="#完整專案級範例python-15">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch16.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch16.py
</code></pre>
<pre><code class="language-python">"""Chapter 16: spin lock with exponential backoff."""
import threading
import time


class SpinLockWithBackoff:
    """帶指數退避的自旋鎖，高衝突時自動降低 CPU 浪費。"""

    MAX_BACKOFF_MS = 64

    def __init__(self):
        self._flag = False
        self._guard = threading.Lock()

    def lock(self):
        delay_ms = 1
        while True:
            with self._guard:
                if not self._flag:
                    self._flag = True
                    return
            # 指數退避：避免所有執行緒同時重試
            time.sleep(delay_ms / 1000)
            delay_ms = min(delay_ms * 2, self.MAX_BACKOFF_MS)

    def unlock(self):
        with self._guard:
            self._flag = False


if __name__ == "__main__":
    lk = SpinLockWithBackoff()
    state = {"x": 0}

    def work():
        for _ in range(5000):
            lk.lock()
            state["x"] += 1
            lk.unlock()

    ts = [threading.Thread(target=work) for _ in range(4)]
    for t in ts:
        t.start()
    for t in ts:
        t.join()
    print("x=", state["x"])
    assert state["x"] == 20000
    print("通過：指數退避自旋鎖保護正確")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第17章-讀寫鎖快取實戰"><a class="header" href="#第17章-讀寫鎖快取實戰">第17章 讀寫鎖快取實戰</a></h1>
<h2 id="171-場景"><a class="header" href="#171-場景">17.1 場景</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-67"><a class="header" href="#本小節示意圖-67">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["讀寫比例與並發度對比"]
  N2["典型快取存取分布"]
  N3["操作比例"]
  N4["Read ░ 95%"]
  N5["Write ░ 5%"]
  N6["使用 Mutex（排他鎖）"]
  N7["時間"]
  N8["R1 [讀 ]"]
  N9["R2 [等][讀 ]"]
  N10["R3 [等 ][讀 ]"]
  N11["R4 [等 ][讀 ]"]
  N12["↑每次只有一個讀操作，其餘全部等待，嚴重浪費"]
  N13["並發度: 1 個同時（無論讀寫）"]
  N14["使用 RWMutex（讀寫鎖）"]
  N15["時間"]
  N16["R1 [讀 ]"]
  N17["R2 [讀 ] 多個讀可以同時進行"]
  N18["R3 [讀 ]"]
  N19["R4 [讀 ]"]
  N20["W1 [等 ][寫 ][寫完，讀者可再進]"]
  N21["並發度: 讀者無限並發，寫者獨占"]
  N22["RWMutex 帶來的效益（95% 讀場景）"]
  N23["・讀吞吐量提升 ~20x（從串行讀 並發讀）"]
  N24["・寫操作仍然安全（獨占）"]
  N25["・適合: 設定快取、查詢快取、計算結果快取等"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N11 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
</code></pre>
<p>讀多寫少的快取查詢。</p>
<h2 id="172-基本模式"><a class="header" href="#172-基本模式">17.2 基本模式</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-68"><a class="header" href="#本小節示意圖-68">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Cache 查找完整流程（含雙重檢查）"]
  N2["客戶端請求 key"]
  N3["read_lock() 允許多個讀者同時進入"]
  N4["命中"]
  N5["cache[key] return value"]
  N6["存在？"]
  N7["未命中（miss）"]
  N8["read_unlock() 必須先釋放讀鎖，否則無法升級為寫鎖"]
  N9["write_lock() 等待所有讀者退出，獲得排他鎖"]
  N10["Double-Check: cache[key] 存在？ 二次確認！"]
  N11["防止並發 miss 重複載入"]
  N12["已有（其他執行緒 仍無"]
  N13["搶先載入了）"]
  N14["return value"]
  N15["load from"]
  N16["DB / Source"]
  N17["cache[key]"]
  N18["= value"]
  N19["write_unlock()"]
  N20["return value"]
  N21["為何需要雙重檢查（Double-Check）？"]
  N22["T1: miss 釋放讀鎖 拿寫鎖 load"]
  N23["T2: miss 釋放讀鎖 等待寫鎖 拿寫鎖 ???"]
  N24["若無二次檢查: T1 load 後 T2 又 load 重複查 DB！"]
  N25["加上二次檢查: T2 拿到鎖後發現已有 直接返回 ✓"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N6 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N11 --&gt; N12
  N11 --&gt; N13
  N11 --&gt; N14
  N14 --&gt; N15
  N14 --&gt; N16
  N14 --&gt; N17
  N14 --&gt; N18
  N14 --&gt; N19
  N19 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
</code></pre>
<ul>
<li>讀：拿讀鎖</li>
<li>未命中：升級流程（通常先釋放讀鎖，再拿寫鎖）</li>
<li>寫：更新後釋放寫鎖</li>
</ul>
<h2 id="173-結構設計對應-17311732"><a class="header" href="#173-結構設計對應-17311732">17.3 結構設計（對應 17.3.1~17.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-69"><a class="header" href="#本小節示意圖-69">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Cache 結構設計與 RWMutex 保護範圍"]
  N2["Cache 結構體"]
  N3["data: HashMap RWMutex"]
  N4["\"user:1\" 42 RLock() / RUnlock()"]
  N5["\"user:2\" 18 ↑ 保護 data 的讀操作"]
  N6["\"user:3\" 99"]
  N7["... Lock() / Unlock()"]
  N8["↑ 保護 data 的寫操作"]
  N9["loader: fn(key) value"]
  N10["↑ 當 cache miss 時，呼叫此函式載入資料"]
  N11["操作與鎖的對應關係"]
  N12["操作 使用的鎖 說明"]
  N13["Get (hit) RLock/RUnlock 多讀者並發安全"]
  N14["Get (miss) 先 RUnlock 釋放讀鎖後"]
  N15["再 Lock/Unlock 以寫鎖載入"]
  N16["Set / Evict Lock/Unlock 寫者獨占"]
  N17["Len / Keys RLock/RUnlock 只讀統計資訊"]
  N18["多讀者並發示意"]
  N19["Reader1 [RLock] [讀 data] [RUnlock]"]
  N20["Reader2 [RLock] [讀 data] [RUnlock] 同時執行"]
  N21["Reader3 [RLock] [讀 data] [RUnlock]"]
  N22["Writer [Lock] [寫 data] [Unlock]"]
  N23["等所有 Reader 退出後才能進入"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N22 --&gt; N23
</code></pre>
<p>快取容器 + 讀寫鎖 + 載入函式。</p>
<h2 id="174-常見坑"><a class="header" href="#174-常見坑">17.4 常見坑</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-70"><a class="header" href="#本小節示意圖-70">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["坑一: 鎖升級死鎖"]
  N2["死鎖場景"]
  N3["Thread A RWMutex"]
  N4["RLock() 讀鎖已獲得（readers=1）"]
  N5["... 處理中 ..."]
  N6["Lock() 等待！因為讀鎖還在"]
  N7["等所有讀者退出"]
  N8["A 持有讀鎖 A 等寫鎖 死鎖！"]
  N9["正確做法"]
  N10["RLock() 讀 RUnlock() Lock() 寫 Unlock()"]
  N11["↑必須先釋放讀鎖，才能升級為寫鎖"]
  N12["坑二: 缺少二次檢查 重複載入 DB"]
  N13["並發 Miss 場景"]
  N14["時間"]
  N15["T1: [RLock][miss][RUnlock] [Lock][load DB!][Unlock]"]
  N16["T2: [RLock][miss][RUnlock][等Lock ][load DB!][Unlock]"]
  N17["T3: [RLock][miss][RUnlock][等等Lock ][load DB!]"]
  N18["↑ 沒有二次檢查 3 個執行緒都去 load DB N 倍壓力！"]
  N19["T1: [RLock][miss][RUnlock] [Lock][load DB][Unlock]"]
  N20["T2: [RLock][miss][RUnlock][等Lock ][二次檢查 hit! ][Unlock]"]
  N21["T3: [RLock][miss][RUnlock][等等Lock ][二次檢查 hit!][Unlock]"]
  N22["↑ 有二次檢查 只有 T1 load DB，T2/T3 直接命中 ✓"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N0 --&gt; N12
  N12 --&gt; N13
  N12 --&gt; N14
  N12 --&gt; N15
  N12 --&gt; N16
  N12 --&gt; N17
  N12 --&gt; N18
  N12 --&gt; N19
  N12 --&gt; N20
  N12 --&gt; N21
  N12 --&gt; N22
</code></pre>
<ul>
<li>鎖升級死鎖</li>
<li>雙重檢查缺失造成重複載入</li>
</ul>
<pre><code class="language-text">read lock -&gt; miss -&gt; unlock read -&gt; lock write
          -&gt; check again -&gt; load -&gt; write -&gt; unlock
</code></pre>
<h2 id="示意圖-11"><a class="header" href="#示意圖-11">示意圖</a></h2>
<pre><code class="language-text">read lock -&gt; hit -&gt; return
read lock -&gt; miss -&gt; unlock read -&gt; write lock -&gt; load -&gt; write -&gt; unlock
</code></pre>
<h2 id="跨語言完整範例-16"><a class="header" href="#跨語言完整範例-16">跨語言完整範例</a></h2>
<h3 id="c--pthread-讀寫鎖保護-map-快取"><a class="header" href="#c--pthread-讀寫鎖保護-map-快取">C — pthread 讀寫鎖保護 map 快取</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define CACHE_SIZE 64

typedef struct { char key[32]; int value; int used; } Entry;

static Entry cache[CACHE_SIZE];
static pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

static int db_load(const char *key) {
    return (int)strlen(key) * 7;  /* 模擬資料庫查詢 */
}

int get_or_load(const char *key) {
    pthread_rwlock_rdlock(&amp;rwlock);
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (cache[i].used &amp;&amp; strcmp(cache[i].key, key) == 0) {
            int v = cache[i].value;
            pthread_rwlock_unlock(&amp;rwlock);
            return v;
        }
    }
    pthread_rwlock_unlock(&amp;rwlock);

    pthread_rwlock_wrlock(&amp;rwlock);
    /* 雙重檢查 */
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (cache[i].used &amp;&amp; strcmp(cache[i].key, key) == 0) {
            int v = cache[i].value;
            pthread_rwlock_unlock(&amp;rwlock);
            return v;
        }
    }
    int val = db_load(key);
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (!cache[i].used) {
            strncpy(cache[i].key, key, 31);
            cache[i].value = val;
            cache[i].used = 1;
            break;
        }
    }
    pthread_rwlock_unlock(&amp;rwlock);
    return val;
}

int main(void) {
    printf("alpha = %d\n", get_or_load("alpha"));
    printf("alpha = %d (cached)\n", get_or_load("alpha"));
    printf("beta  = %d\n", get_or_load("beta"));
    return 0;
}
</code></pre>
<h3 id="c--shared_mutex-讀寫鎖快取"><a class="header" href="#c--shared_mutex-讀寫鎖快取">C++ — shared_mutex 讀寫鎖快取</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;shared_mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

class RWCache {
    std::unordered_map&lt;std::string, int&gt; data_;
    mutable std::shared_mutex mu_;

    int load_from_db(const std::string &amp;key) {
        return static_cast&lt;int&gt;(key.size()) * 7;
    }
public:
    int get(const std::string &amp;key) {
        {
            std::shared_lock r(mu_);
            auto it = data_.find(key);
            if (it != data_.end()) return it-&gt;second;
        }
        std::unique_lock w(mu_);
        auto it = data_.find(key);  /* double-check */
        if (it != data_.end()) return it-&gt;second;
        int val = load_from_db(key);
        data_[key] = val;
        return val;
    }
};

int main() {
    RWCache cache;
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++) {
        threads.emplace_back([&amp;cache, i]() {
            std::string key = "key" + std::to_string(i % 2);
            for (int j = 0; j &lt; 100; j++) {
                int v = cache.get(key);
                (void)v;
            }
        });
    }
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "alpha=" &lt;&lt; cache.get("alpha") &lt;&lt; "\n";
    std::cout &lt;&lt; "完成：多讀者並發無競態\n";
}
</code></pre>
<h3 id="rust--rwlock-讀寫快取"><a class="header" href="#rust--rwlock-讀寫快取">Rust — RwLock<HashMap> 讀寫快取</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::thread;

struct RwCache {
    data: RwLock&lt;HashMap&lt;String, i32&gt;&gt;,
}

impl RwCache {
    fn new() -&gt; Self {
        RwCache { data: RwLock::new(HashMap::new()) }
    }
    fn get_or_load(&amp;self, key: &amp;str) -&gt; i32 {
        {
            let r = self.data.read().unwrap();
            if let Some(&amp;v) = r.get(key) { return v; }
        }
        let mut w = self.data.write().unwrap();
        if let Some(&amp;v) = w.get(key) { return v; }  /* double-check */
        let val = key.len() as i32 * 7;
        w.insert(key.to_string(), val);
        val
    }
}

fn main() {
    let cache = Arc::new(RwCache::new());
    let mut handles = vec![];
    for i in 0..4 {
        let c = Arc::clone(&amp;cache);
        handles.push(thread::spawn(move || {
            let key = format!("key{}", i % 2);
            for _ in 0..100 {
                let _ = c.get_or_load(&amp;key);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("alpha={}", cache.get_or_load("alpha"));
    println!("完成：Rust RwLock 快取正確");
}</code></pre></pre>
<h3 id="go--syncrwmutex-讀寫快取"><a class="header" href="#go--syncrwmutex-讀寫快取">Go — sync.RWMutex 讀寫快取</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

type RWCache struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewRWCache() *RWCache {
    return &amp;RWCache{data: make(map[string]int)}
}

func (c *RWCache) GetOrLoad(key string) int {
    c.mu.RLock()
    if v, ok := c.data[key]; ok {
        c.mu.RUnlock()
        return v
    }
    c.mu.RUnlock()

    c.mu.Lock()
    defer c.mu.Unlock()
    if v, ok := c.data[key]; ok { // double-check
        return v
    }
    val := len(key) * 7
    c.data[key] = val
    return val
}

func main() {
    cache := NewRWCache()
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id%2)
            for j := 0; j &lt; 100; j++ {
                cache.GetOrLoad(key)
            }
        }(i)
    }
    wg.Wait()
    fmt.Printf("alpha=%d\n", cache.GetOrLoad("alpha"))
    fmt.Println("完成：Go RWMutex 快取正確")
}
</code></pre>
<h3 id="python--threadingrlock-讀寫快取模擬"><a class="header" href="#python--threadingrlock-讀寫快取模擬">Python — threading.RLock 讀寫快取模擬</a></h3>
<pre><code class="language-python">"""Chapter 17: RW-lock cache — multi-reader concurrent, miss loads once."""
import threading
import time


class RWCache:
    def __init__(self, loader):
        self._data = {}
        self._lock = threading.Lock()
        self._readers = 0
        self._read_lock = threading.Lock()
        self._write_lock = threading.Lock()
        self._loader = loader

    def _rlock(self):
        with self._read_lock:
            self._readers += 1
            if self._readers == 1:
                self._write_lock.acquire()

    def _runlock(self):
        with self._read_lock:
            self._readers -= 1
            if self._readers == 0:
                self._write_lock.release()

    def get(self, key):
        self._rlock()
        val = self._data.get(key)
        self._runlock()
        if val is not None:
            return val
        with self._write_lock:
            if key in self._data:       # double-check
                return self._data[key]
            val = self._loader(key)
            self._data[key] = val
            return val


def main():
    load_count = [0]

    def db_load(key):
        load_count[0] += 1
        time.sleep(0.01)               # 模擬 DB 延遲
        return len(key) * 7

    cache = RWCache(db_load)
    results = []
    lock = threading.Lock()

    def reader(key):
        v = cache.get(key)
        with lock:
            results.append(v)

    threads = [threading.Thread(target=reader, args=("alpha",)) for _ in range(8)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    print(f"alpha 值: {results[0]}, 所有結果一致: {len(set(results)) == 1}")
    print(f"DB 實際載入次數: {load_count[0]} (應為 1，雙重檢查生效)")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-16"><a class="header" href="#完整專案級範例python-16">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch17.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch17.py
</code></pre>
<pre><code class="language-python">"""Chapter 17: rw-lock cache (simple)."""
import threading

cache = {}
lock = threading.RLock()


def get_or_load(k: str) -&gt; int:
    with lock:
        if k in cache:
            return cache[k]
    with lock:
        if k not in cache:
            cache[k] = len(k)
        return cache[k]


if __name__ == "__main__":
    print(get_or_load("alpha"))
    print(get_or_load("alpha"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第18章-aqs-可重入鎖實戰"><a class="header" href="#第18章-aqs-可重入鎖實戰">第18章 AQS 可重入鎖實戰</a></h1>
<h2 id="181-目標"><a class="header" href="#181-目標">18.1 目標</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-71"><a class="header" href="#本小節示意圖-71">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["手寫鎖 vs OS Mutex 功能對比"]
  N2["功能 手寫可重入鎖 OS Mutex"]
  N3["互斥保護 ✓ ✓"]
  N4["可重入 ✓ 計數器追蹤 △ 依 OS/語言而定"]
  N5["(同執行緒多次鎖) state 欄位 pthread 預設不可"]
  N6["可阻塞等待 ✓ park/unpark ✓"]
  N7["可喚醒 ✓ unpark 精確 ✓"]
  N8["喚醒指定執行緒"]
  N9["可超時 ✓ 需自行實作 △ 部分 OS 支援"]
  N10["(tryLock + timeout) 計時邏輯 timedwait"]
  N11["可中斷 ✓ 需自行實作 △ 依實作而定"]
  N12["(interrupt 喚醒) 中斷標記"]
  N13["公平性控制 ✓ 可選公平/ ✗ 通常 OS 決定"]
  N14["非公平佇列"]
  N15["自訂條件變數數量 ✓ 多個 Condition △ 有限"]
  N16["目標: 自己做出「可重入 + 可阻塞等待 + 可喚醒」的鎖，"]
  N17["同時支援超時與中斷路徑。"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N16 --&gt; N17
</code></pre>
<p>自己做出「可重入 + 可阻塞等待 + 可喚醒」的鎖。</p>
<h2 id="182-狀態定義"><a class="header" href="#182-狀態定義">18.2 狀態定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-72"><a class="header" href="#本小節示意圖-72">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["可重入鎖的三個核心欄位"]
  N2["ReentrantLock 結構"]
  N3["state: AtomicInt"]
  N4["0 鎖空閒（free）"]
  N5["1 被持有一次"]
  N6["2 同一執行緒重入兩次"]
  N7["n 同一執行緒重入 n 次"]
  N8["作用: 追蹤重入深度，state 0 才真正釋放鎖"]
  N9["owner: Thread (nullable)"]
  N10["null 無人持有"]
  N11["Thread A Thread A 持有"]
  N12["作用: 判斷當前執行緒是否為持有者"]
  N13["若是 state++（重入）"]
  N14["若否 進入等待佇列"]
  N15["waiters: Queue&amp;lt;Thread&amp;gt;"]
  N16["[Thread B] [Thread C] [Thread D] null"]
  N17["作用: FIFO 佇列儲存等待的執行緒"]
  N18["公平鎖: 按入隊順序喚醒"]
  N19["非公平鎖: 允許搶占"]
  N20["三個欄位的協作"]
  N21["owner=Thread A, state=2, waiters=[B, C]"]
  N22["Thread A 再次 lock() owner==A state=3（重入）"]
  N23["Thread B 呼叫 lock() owner!=B 入隊，park()"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
</code></pre>
<ul>
<li><code>state</code>: 重入次數</li>
<li><code>owner</code>: 持有者執行緒</li>
<li>queue: 等待節點</li>
</ul>
<h2 id="183-獲取與釋放對應-18311833"><a class="header" href="#183-獲取與釋放對應-18311833">18.3 獲取與釋放（對應 18.3.1~18.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-73"><a class="header" href="#本小節示意圖-73">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["可重入鎖狀態機"]
  N2["lock() 流程"]
  N3["Thread 呼叫 lock()"]
  N4["是"]
  N5["owner == current state++（重入） 返回"]
  N6["執行緒？ state=1 2 3 ..."]
  N7["否"]
  N8["是"]
  N9["state == 0？ CAS(state, 0, 1)"]
  N10["鎖空閒？ owner = current 進入臨界區"]
  N11["否（鎖被他人持有）"]
  N12["入隊（enqueue）"]
  N13["park()睡眠等待"]
  N14["被 unpark() 喚醒"]
  N15["失敗（被搶占）"]
  N16["retry: 重新嘗試"]
  N17["CAS(0 1)"]
  N18["unlock() 流程"]
  N19["Thread 呼叫 unlock()"]
  N20["assert owner == current（必須是持有者才能解鎖）"]
  N21["state"]
  N22["state &amp;gt; 0 仍有重入層，繼續持有鎖，返回"]
  N23["state == 0 真正釋放"]
  N24["owner = null"]
  N25["waiters 佇列有人？"]
  N26["有 無"]
  N27["取出隊首 Thread 鎖空閒"]
  N28["unpark() 喚醒 等待下次競爭"]
  N29["重入計數示意"]
  N30["outer() { inner() {"]
  N31["lock() state=1 lock() state=2"]
  N32["inner() ..."]
  N33["unlock() state=1 unlock() state=1"]
  N34["state: 1 2 1 0（真正釋放）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N6 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N10 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N13 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N20 --&gt; N21
  N20 --&gt; N22
  N20 --&gt; N23
  N23 --&gt; N24
  N20 --&gt; N25
  N25 --&gt; N26
  N20 --&gt; N27
  N20 --&gt; N28
  N1 --&gt; N29
  N1 --&gt; N30
  N1 --&gt; N31
  N1 --&gt; N32
  N1 --&gt; N33
  N1 --&gt; N34
</code></pre>
<ul>
<li>owner 再次進入：<code>state++</code></li>
<li>其他執行緒：排隊等待</li>
<li>釋放：<code>state--</code> 到 0 才真正解鎖</li>
</ul>
<h2 id="184-測試面向"><a class="header" href="#184-測試面向">18.4 測試面向</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-74"><a class="header" href="#本小節示意圖-74">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["可重入鎖測試矩陣"]
  N2["測試面向 測試方法 驗收標準"]
  N3["可重入正確性 同一執行緒連續 lock() 不死鎖"]
  N4["N 次後 unlock() N 次 state 歸零後其他執行"]
  N5["驗證臨界區資料一致性 緒可正常獲得鎖"]
  N6["競爭公平性 M 個執行緒並發競爭 每個執行緒等待時間"]
  N7["記錄各自獲鎖時間 差異在合理範圍內"]
  N8["計算標準差 （公平模式）"]
  N9["中斷路徑 執行緒等待鎖時 中斷後執行緒正確退出"]
  N10["從另一執行緒發送中斷 不留殭屍"]
  N11["驗證等待執行緒退出 鎖狀態保持一致"]
  N12["超時路徑 tryLock(timeout=100ms) 超時後返回 false"]
  N13["持鎖者睡眠 200ms 不死鎖"]
  N14["等待者應超時返回 計時誤差 &amp;lt; 10ms"]
  N15["多條件變數 producer/consumer 模型 signal 精確喚醒一個"]
  N16["condition.await() signalAll 喚醒全部"]
  N17["condition.signal() 不丟失喚醒"]
  N18["壓力測試 1000 執行緒 × 10000 計數器最終值正確"]
  N19["次 lock/unlock 無資料競態"]
  N20["原子計數器累加 無死鎖"]
  N21["測試覆蓋路徑圖"]
  N22["lock()"]
  N23["owner == self state++ [可重入路徑] ✓"]
  N24["state == 0 CAS 成功 [首次獲取路徑] ✓"]
  N25["state == 0 CAS 失敗 retry [競爭路徑] ✓"]
  N26["state &amp;gt; 0 park() unpark [等待喚醒路徑] ✓"]
  N27["state &amp;gt; 0 park() interrupt [中斷路徑] ✓"]
  N28["state &amp;gt; 0 tryLock + timeout [超時路徑] ✓"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
</code></pre>
<ul>
<li>可重入正確性</li>
<li>競爭時公平性/吞吐</li>
<li>中斷與超時路徑</li>
</ul>
<h2 id="示意圖-12"><a class="header" href="#示意圖-12">示意圖</a></h2>
<pre><code class="language-text">owner=T1, state=2 (重入2次)
T1 unlock -&gt; state=1
T1 unlock -&gt; state=0 -&gt; 喚醒下一個
</code></pre>
<h2 id="跨語言完整範例-17"><a class="header" href="#跨語言完整範例-17">跨語言完整範例</a></h2>
<h3 id="c--pthread_mutex_t-遞迴鎖pthread_mutex_recursive"><a class="header" href="#c--pthread_mutex_t-遞迴鎖pthread_mutex_recursive">C — pthread_mutex_t 遞迴鎖（PTHREAD_MUTEX_RECURSIVE）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

static pthread_mutex_t mu;
static int shared_value = 0;

void inner_work(void) {
    pthread_mutex_lock(&amp;mu);      /* 重入：同執行緒第二次鎖 */
    shared_value += 10;
    printf("inner: shared_value = %d\n", shared_value);
    pthread_mutex_unlock(&amp;mu);
}

void outer_work(void) {
    pthread_mutex_lock(&amp;mu);      /* 第一次鎖 */
    shared_value += 1;
    printf("outer before inner: shared_value = %d\n", shared_value);
    inner_work();                 /* 呼叫 inner，不應死鎖 */
    printf("outer after inner: shared_value = %d\n", shared_value);
    pthread_mutex_unlock(&amp;mu);
}

int main(void) {
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&amp;attr);
    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&amp;mu, &amp;attr);
    pthread_mutexattr_destroy(&amp;attr);

    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, (void *(*)(void *))outer_work, NULL);
    pthread_create(&amp;t2, NULL, (void *(*)(void *))outer_work, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("最終 shared_value = %d (expected 22)\n", shared_value);
    pthread_mutex_destroy(&amp;mu);
    return 0;
}
</code></pre>
<h3 id="c--stdrecursive_mutex-可重入鎖"><a class="header" href="#c--stdrecursive_mutex-可重入鎖">C++ — std::recursive_mutex 可重入鎖</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

std::recursive_mutex rmu;
int shared_value = 0;

void inner_work() {
    std::lock_guard&lt;std::recursive_mutex&gt; lk(rmu);  /* 重入 */
    shared_value += 10;
    std::cout &lt;&lt; "inner: " &lt;&lt; shared_value &lt;&lt; "\n";
}

void outer_work() {
    std::lock_guard&lt;std::recursive_mutex&gt; lk(rmu);  /* 首次鎖 */
    shared_value += 1;
    inner_work();  /* 同執行緒再次鎖，不應死鎖 */
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++)
        threads.emplace_back(outer_work);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "最終 shared_value = " &lt;&lt; shared_value
              &lt;&lt; " (expected 44)\n";
}
</code></pre>
<h3 id="rust--parking_lotreentrantmutex-可重入鎖"><a class="header" href="#rust--parking_lotreentrantmutex-可重入鎖">Rust — parking_lot::ReentrantMutex 可重入鎖</a></h3>
<pre><pre class="playground"><code class="language-rust">use parking_lot::ReentrantMutex;
use std::cell::Cell;
use std::sync::Arc;
use std::thread;

fn inner_work(lock: &amp;ReentrantMutex&lt;Cell&lt;i32&gt;&gt;) {
    let guard = lock.lock();          /* 重入：同執行緒第二次 */
    guard.set(guard.get() + 10);
    println!("inner: {}", guard.get());
}

fn outer_work(lock: Arc&lt;ReentrantMutex&lt;Cell&lt;i32&gt;&gt;&gt;) {
    let guard = lock.lock();          /* 首次鎖 */
    guard.set(guard.get() + 1);
    drop(guard);                      /* Rust 需手動 drop 才能重入 */
    inner_work(&amp;lock);
}

fn main() {
    let lock = Arc::new(ReentrantMutex::new(Cell::new(0)));
    let mut handles = vec![];
    for _ in 0..4 {
        let l = Arc::clone(&amp;lock);
        handles.push(thread::spawn(move || outer_work(l)));
    }
    for h in handles { h.join().unwrap(); }
    println!("最終值 = {}", lock.lock().get());
}</code></pre></pre>
<h3 id="go--syncmutex--輔助函式go-無原生-recursive-mutex用呼叫鏈迴避"><a class="header" href="#go--syncmutex--輔助函式go-無原生-recursive-mutex用呼叫鏈迴避">Go — sync.Mutex + 輔助函式（Go 無原生 recursive mutex，用呼叫鏈迴避）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

// Go 的 sync.Mutex 不可重入，正確做法是把鎖傳遞給子函式
// 而非在子函式重複 Lock 同一把鎖
type ReentrantGuard struct {
    mu    sync.Mutex
    owner int64
    depth int
    once  sync.Mutex
}

var mu sync.Mutex
var sharedValue int

// outer 持鎖後直接呼叫 inner（不再重複鎖）
func inner(val *int) {
    *val += 10
    fmt.Printf("inner: shared_value = %d\n", *val)
}

func outer() {
    mu.Lock()
    defer mu.Unlock()
    sharedValue += 1
    inner(&amp;sharedValue) // inner 不重複 Lock，由 outer 持有鎖
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            outer()
        }()
    }
    wg.Wait()
    fmt.Printf("最終 shared_value = %d (expected 44)\n", sharedValue)
}
</code></pre>
<h3 id="python--threadingrlock-可重入鎖"><a class="header" href="#python--threadingrlock-可重入鎖">Python — threading.RLock 可重入鎖</a></h3>
<pre><code class="language-python">"""Chapter 18: reentrant lock — outer calls inner, both lock same RLock."""
import threading

rlock = threading.RLock()
shared_value = 0


def inner_work():
    with rlock:           # RLock 允許同執行緒第二次進入
        global shared_value
        shared_value += 10
        print(f"inner: shared_value = {shared_value}")


def outer_work():
    with rlock:           # 首次獲得鎖
        global shared_value
        shared_value += 1
        inner_work()      # 同執行緒再次 with rlock，不應死鎖


def main():
    threads = [threading.Thread(target=outer_work) for _ in range(4)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    print(f"最終 shared_value = {shared_value} (expected 44)")
    assert shared_value == 44, "RLock 可重入失敗！"
    print("通過：RLock 可重入，outer 呼叫 inner 不死鎖")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-17"><a class="header" href="#完整專案級範例python-17">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch18.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch18.py
</code></pre>
<pre><code class="language-python">"""Chapter 18: reentrant lock."""
import threading

r = threading.RLock()


def outer():
    with r:
        inner()


def inner():
    with r:
        print("reentered")


if __name__ == "__main__":
    outer()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第19章-分散式鎖架構"><a class="header" href="#第19章-分散式鎖架構">第19章 分散式鎖架構</a></h1>
<h2 id="191-為什麼需要分散式鎖"><a class="header" href="#191-為什麼需要分散式鎖">19.1 為什麼需要分散式鎖</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-75"><a class="header" href="#本小節示意圖-75">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["單節點 vs 多節點鎖的邊界"]
  N2["單節點（JVM Mutex 夠用）"]
  N3["App Instance"]
  N4["Thread A"]
  N5["[JVM Mutex] DB"]
  N6["Thread B"]
  N7["(等待)"]
  N8["✓ 同一 JVM 內，mutex 可保護共享資源"]
  N9["多節點（JVM Mutex 失效）"]
  N10["App Instance 1 App Instance 2"]
  N11["[JVM Lock A] [JVM Lock B]"]
  N12["↑ 只保護本 JVM ↑ 只保護本 JVM"]
  N13["都能同時存取"]
  N14["共享資源: DB / Redis / 文件"]
  N15["Lock A 和 Lock B 互不可見 兩個實例同時操作 競態"]
  N16["✗ 跨 JVM / 跨進程 / 跨機器 需要分散式鎖"]
  N17["分散式鎖解法"]
  N18["App Instance 1 App Instance 2"]
  N19["先搶鎖 搶鎖失敗，等待"]
  N20["Redis / ZooKeeper（分散式鎖服務）"]
  N21["lock:order = \"instance-1-uuid\" TTL=10s"]
  N22["持有鎖"]
  N23["共享資源: DB"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N12 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N18 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N21 --&gt; N22
  N1 --&gt; N23
</code></pre>
<p>單機鎖只能管單進程，服務多副本時會失效。</p>
<h2 id="192-超賣案例對應-19211922"><a class="header" href="#192-超賣案例對應-19211922">19.2 超賣案例（對應 19.2.1~19.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-76"><a class="header" href="#本小節示意圖-76">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["read-modify-write 競態導致超賣"]
  N2["時間軸"]
  N3["T+0 T+1 T+2 T+3 T+4 T+5"]
  N4["App1 [讀 stock] [扣減] [寫 stock=0]"]
  N5["stock=1 stock=1-1=0"]
  N6["App2 [讀 stock] [扣減] [寫 stock=-1]"]
  N7["stock=1 stock=1-1=0"]
  N8["↑ 讀到舊值！ ↑ 再次扣減 超賣！"]
  N9["問題根源: Read-Modify-Write 非原子"]
  N10["Step 1: stock = DB.read(\"stock_001\") stock = 1"]
  N11["Step 2: if stock &amp;gt; 0: stock -= 1 stock = 0"]
  N12["Step 3: DB.write(\"stock_001\", stock) stock = 0"]
  N13["兩個 App 在 Step 1 和 Step 3 之間沒有互斥"]
  N14["都讀到 stock=1 都認為可以扣減 stock 變 -1"]
  N15["正確做法: 加分散式鎖後"]
  N16["App1 [取鎖 ✓][讀 stock=1][扣減][寫 stock=0][釋放鎖]"]
  N17["App2 [等鎖 ][取鎖][讀 stock=0][售罄]"]
  N18["結果: stock = 0（正確），不超賣"]
  N0 --&gt; N1
  N1 --&gt; N2
  N2 --&gt; N3
  N1 --&gt; N4
  N4 --&gt; N5
  N1 --&gt; N6
  N6 --&gt; N7
  N6 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
</code></pre>
<p>多節點同時扣庫存，若無跨節點互斥，庫存會變負數。</p>
<h2 id="193-jvm-本地鎖邊界對應-19311932"><a class="header" href="#193-jvm-本地鎖邊界對應-19311932">19.3 JVM 本地鎖邊界（對應 19.3.1~19.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-77"><a class="header" href="#本小節示意圖-77">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["JVM 本地鎖的可見範圍邊界"]
  N2["機器 A"]
  N3["App Instance 1 (JVM)"]
  N4["synchronized(lockObj) { ... } JVM 鎖"]
  N5["Thread Pool"]
  N6["T1"]
  N7["[JVM Lock] ✓"]
  N8["T2"]
  N9["JVM Lock 邊界到此為止"]
  N10["鎖的狀態不會跨越這條線"]
  N11["網路"]
  N12["機器 B"]
  N13["App Instance 2 (JVM)"]
  N14["synchronized(lockObj) { ... } 完全獨立的 JVM 鎖"]
  N15["↑ 和機器A的鎖物件不同，互不可見"]
  N16["共享資源: MySQL / Redis"]
  N17["兩個 App 可以同時操作 競態！"]
  N18["結論: synchronized 只在同 JVM 內有效，"]
  N19["水平擴展後必須用外部分散式鎖。"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N18 --&gt; N19
</code></pre>
<p><code>synchronized</code> 只在同 JVM 內有效。</p>
<h2 id="194-分散式鎖要求對應-19411942"><a class="header" href="#194-分散式鎖要求對應-19411942">19.4 分散式鎖要求（對應 19.4.1~19.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-78"><a class="header" href="#本小節示意圖-78">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["分散式鎖五大需求與實現挑戰"]
  N2["需求 1: 互斥性（Mutual Exclusion）"]
  N3["同一時刻只有一個客戶端持有鎖"]
  N4["實現: Redis SET NX（Not Exist）原子指令"]
  N5["挑戰: 網路分區時可能出現兩個持有者"]
  N6["需求 2: 不死鎖（No Deadlock）"]
  N7["持鎖客戶端崩潰後，鎖必須自動釋放"]
  N8["實現: TTL 自動過期（SET NX PX 10000）"]
  N9["挑戰: TTL 設定多長？太短 任務未完鎖已過期"]
  N10["需求 3: 可重入（Reentrancy）"]
  N11["同一客戶端可多次獲取同一把鎖"]
  N12["實現: 鎖值包含 clientID，每次重入計數"]
  N13["挑戰: 需要 Lua 腳本保證 check-increment 原子性"]
  N14["需求 4: 高可用（High Availability）"]
  N15["鎖服務本身不能是單點"]
  N16["實現: Redis Sentinel / Cluster；ZooKeeper Quorum"]
  N17["挑戰: 主從切換窗口期可能導致鎖丟失"]
  N18["需求 5: 可續租（Watchdog / Lease Renewal）"]
  N19["任務執行時間超過 TTL 時，自動延長鎖的生命週期"]
  N20["實現: 後台執行緒定期 EXPIRE key new_ttl"]
  N21["挑戰: 續租執行緒本身崩潰 鎖不再續租 自然過期"]
  N22["各需求依賴關係"]
  N23["互斥 NX 指令"]
  N24["不死鎖 TTL"]
  N25["誤刪保護 UUID value"]
  N26["可重入 Lua 原子 check-increment"]
  N27["可續租 Watchdog 執行緒"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
</code></pre>
<ul>
<li>互斥</li>
<li>可釋放（不死鎖）</li>
<li>故障可恢復</li>
<li>最好可重入/可續租</li>
</ul>
<h2 id="195-apcp-取捨對應-19511954"><a class="header" href="#195-apcp-取捨對應-19511954">19.5 AP/CP 取捨（對應 19.5.1~19.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-79"><a class="header" href="#本小節示意圖-79">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["CAP 定理與分散式鎖選型"]
  N2["一致性 (C)"]
  N3["CP 區域"]
  N4["ZooKeeper"]
  N5["etcd"]
  N6["可用性 (A)"]
  N7["AP 區域"]
  N8["Redis (主從)"]
  N9["Redis Cluster"]
  N10["(P = 分區容忍，實際分散式系統必須接受 P)"]
  N11["Redis (偏 AP)"]
  N12["優點"]
  N13["・極高吞吐（單機 10萬+ QPS）"]
  N14["・低延遲（sub-millisecond）"]
  N15["・部署簡單"]
  N16["弱點"]
  N17["・主從複製非同步 主節點掛掉切換期間，新主可能無鎖記錄"]
  N18["・Cluster 模式 SET NX 無法跨 slot 原子操作"]
  N19["・Redlock 演算法有爭議（時鐘漂移問題）"]
  N20["適用: 電商庫存、快取更新、冪等控制等容忍極短暫鎖丟失的場景"]
  N21["ZooKeeper (偏 CP)"]
  N22["優點"]
  N23["・強一致性（Zab 協議 Quorum 提交）"]
  N24["・臨時節點 + Watcher 天然支援鎖失效通知"]
  N25["・公平鎖（順序節點）"]
  N26["弱點"]
  N27["・寫入延遲高（需要多數節點確認）"]
  N28["・單機 QPS 約 1 萬（vs Redis 10 萬+）"]
  N29["・ZooKeeper 本身是有狀態的複雜系統"]
  N30["適用: 金融交易、配置管理、Leader 選舉等強一致性要求的場景"]
  N31["選型建議"]
  N32["・高吞吐 + 可接受極短暫不一致 Redis"]
  N33["・強一致 + 低吞吐可接受 ZooKeeper / etcd"]
  N0 --&gt; N1
  N1 --&gt; N2
  N2 --&gt; N3
  N2 --&gt; N4
  N2 --&gt; N5
  N1 --&gt; N6
  N6 --&gt; N7
  N6 --&gt; N8
  N6 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
  N1 --&gt; N29
  N1 --&gt; N30
  N1 --&gt; N31
  N1 --&gt; N32
  N1 --&gt; N33
</code></pre>
<p>Redis 常偏 AP；ZooKeeper 常偏 CP。</p>
<h2 id="196-redis-鎖演進對應-196119612"><a class="header" href="#196-redis-鎖演進對應-196119612">19.6 Redis 鎖演進（對應 19.6.1~19.6.12）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-80"><a class="header" href="#本小節示意圖-80">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Redis 分散式鎖四代演進"]
  N2["V1: SET NX（最簡版）"]
  N3["SET lock_key 1 NX"]
  N4["✓ 獲得鎖"]
  N5["DEL lock_key 崩潰時沒執行 鎖永久存在 死鎖！"]
  N6["問題: 無 TTL，崩潰後永不釋放"]
  N7["V2: SET NX PX ttl（加 TTL）"]
  N8["SET lock_key 1 NX PX 10000"]
  N9["✓ 獲得鎖（10秒後自動過期）"]
  N10["DEL lock_key 若任務執行時間 &amp;gt; 10s，鎖已被其他人拿走"]
  N11["此時 DEL 刪掉別人的鎖！ 誤刪！"]
  N12["問題: 鎖的 value 沒有身份，誰都可以刪"]
  N13["V3: SET NX PX + Lua 原子 check-delete（加身份驗證）"]
  N14["SET lock_key {uuid} NX PX 10000"]
  N15["✓ 獲得鎖"]
  N16["解鎖時執行 Lua 腳本（原子）"]
  N17["if redis.call('GET', key) == uuid then"]
  N18["return redis.call('DEL', key)"]
  N19["else"]
  N20["return 0 -- 不是我的鎖，不刪"]
  N21["end"]
  N22["問題: 任務執行超過 TTL 鎖過期 他人取鎖 兩個持有者！"]
  N23["V4: Lua + Watchdog 續租（完整版）"]
  N24["主執行緒 Watchdog 執行緒"]
  N25["SET lock {uuid} NX PX 30s"]
  N26["開始執行業務邏輯 每 10s 執行"]
  N27["EXPIRE lock 30s (續租)"]
  N28["業務完成 ↑ 確保鎖不過期"]
  N29["Lua check-delete Watchdog 停止"]
  N30["若主執行緒崩潰"]
  N31["Watchdog 也停止 鎖 TTL 自然倒數 30s 後自動釋放"]
  N32["演進總結"]
  N33["版本 解決的問題 引入的問題"]
  N34["V1 互斥 崩潰 死鎖"]
  N35["V2 死鎖（TTL） 誤刪他人的鎖"]
  N36["V3 誤刪（UUID+Lua） 任務超時鎖過期"]
  N37["V4 超時（Watchdog） Watchdog 複雜度增加"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N10 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
  N1 --&gt; N29
  N1 --&gt; N30
  N1 --&gt; N31
  N1 --&gt; N32
  N1 --&gt; N33
  N1 --&gt; N34
  N1 --&gt; N35
  N1 --&gt; N36
  N1 --&gt; N37
</code></pre>
<ol>
<li><code>SET key val NX PX ttl</code></li>
<li><code>finally</code> 解鎖</li>
<li>用 Lua 比對 value 再刪（防誤刪）</li>
<li>看門狗續租（避免任務未完鎖先過期）</li>
</ol>
<pre><code class="language-text">ClientA set lock=uuidA ttl=10s
ClientB 不能覆蓋
unlock 必須檢查 value==uuidA
</code></pre>
<h2 id="示意圖-13"><a class="header" href="#示意圖-13">示意圖</a></h2>
<pre><code class="language-text">App1 --SET NX PX--&gt; Redis(lock:order)
App2 --SET NX PX--&gt; fail (已被占用)
App1 --Lua check value then del--&gt; unlock
</code></pre>
<h2 id="跨語言完整範例-18"><a class="header" href="#跨語言完整範例-18">跨語言完整範例</a></h2>
<h3 id="c--mockredis-模擬-set-nx-px--lua-check-delete"><a class="header" href="#c--mockredis-模擬-set-nx-px--lua-check-delete">C — MockRedis 模擬 SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;pthread.h&gt;

#define KEY_MAX 64
#define VAL_MAX 64

typedef struct {
    char key[KEY_MAX];
    char val[VAL_MAX];
    long expire_ms;        /* UNIX 毫秒時間戳，0 表示無記錄 */
    int  used;
} RedisEntry;

#define STORE_SIZE 16
static RedisEntry store[STORE_SIZE];
static pthread_mutex_t store_mu = PTHREAD_MUTEX_INITIALIZER;

static long now_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &amp;ts);
    return ts.tv_sec * 1000L + ts.tv_nsec / 1000000L;
}

/* SET key val NX PX ttl → 1: 成功, 0: 已存在 */
int redis_set_nx_px(const char *key, const char *val, int ttl_ms) {
    pthread_mutex_lock(&amp;store_mu);
    long now = now_ms();
    int slot = -1;
    for (int i = 0; i &lt; STORE_SIZE; i++) {
        if (store[i].used &amp;&amp; strcmp(store[i].key, key) == 0) {
            if (store[i].expire_ms &gt; now) { /* 鎖仍有效 */
                pthread_mutex_unlock(&amp;store_mu);
                return 0;
            }
            slot = i;  /* 已過期，可覆蓋 */
            break;
        }
        if (!store[i].used &amp;&amp; slot == -1) slot = i;
    }
    if (slot == -1) { pthread_mutex_unlock(&amp;store_mu); return 0; }
    strncpy(store[slot].key, key, KEY_MAX - 1);
    strncpy(store[slot].val, val, VAL_MAX - 1);
    store[slot].expire_ms = now + ttl_ms;
    store[slot].used = 1;
    pthread_mutex_unlock(&amp;store_mu);
    return 1;
}

/* Lua: if GET(key)==val then DEL(key) end → 1: 刪成功, 0: 不是自己的鎖 */
int redis_lua_unlock(const char *key, const char *val) {
    pthread_mutex_lock(&amp;store_mu);
    for (int i = 0; i &lt; STORE_SIZE; i++) {
        if (store[i].used &amp;&amp; strcmp(store[i].key, key) == 0) {
            if (strcmp(store[i].val, val) == 0) {
                store[i].used = 0;
                pthread_mutex_unlock(&amp;store_mu);
                return 1;
            }
            break;
        }
    }
    pthread_mutex_unlock(&amp;store_mu);
    return 0;
}

int main(void) {
    const char *key = "lock:order";
    const char *uuid_a = "client-A-uuid";
    const char *uuid_b = "client-B-uuid";

    int ok = redis_set_nx_px(key, uuid_a, 10000);
    printf("Client A 加鎖: %s\n", ok ? "成功" : "失敗");

    ok = redis_set_nx_px(key, uuid_b, 10000);
    printf("Client B 加鎖: %s (應為失敗)\n", ok ? "成功" : "失敗");

    /* Client B 嘗試刪 Client A 的鎖 → 應失敗 */
    ok = redis_lua_unlock(key, uuid_b);
    printf("Client B 解鎖: %s (應為失敗)\n", ok ? "成功" : "失敗");

    ok = redis_lua_unlock(key, uuid_a);
    printf("Client A 解鎖: %s (應為成功)\n", ok ? "成功" : "失敗");

    ok = redis_set_nx_px(key, uuid_b, 10000);
    printf("Client B 再次加鎖: %s (應為成功)\n", ok ? "成功" : "失敗");
    return 0;
}
</code></pre>
<h3 id="c--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#c--mockredis-set-nx-px--lua-check-delete">C++ — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;

class MockRedis {
    struct Entry { std::string val; long long expire_ms; };
    std::unordered_map&lt;std::string, Entry&gt; store_;
    std::mutex mu_;

    long long now_ms() {
        using namespace std::chrono;
        return duration_cast&lt;milliseconds&gt;(
            steady_clock::now().time_since_epoch()).count();
    }
public:
    bool set_nx_px(const std::string &amp;key, const std::string &amp;val, int ttl_ms) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        auto it = store_.find(key);
        if (it != store_.end() &amp;&amp; it-&gt;second.expire_ms &gt; now_ms())
            return false;
        store_[key] = {val, now_ms() + ttl_ms};
        return true;
    }
    bool lua_unlock(const std::string &amp;key, const std::string &amp;val) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        auto it = store_.find(key);
        if (it != store_.end() &amp;&amp; it-&gt;second.val == val) {
            store_.erase(it);
            return true;
        }
        return false;
    }
};

int main() {
    MockRedis redis;
    std::string key = "lock:order";
    std::string uuid_a = "client-A-uuid";
    std::string uuid_b = "client-B-uuid";

    std::cout &lt;&lt; "A 加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_a, 10000) &lt;&lt; "\n";
    std::cout &lt;&lt; "B 加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_b, 10000)
              &lt;&lt; " (應為0)\n";
    std::cout &lt;&lt; "B 解鎖: " &lt;&lt; redis.lua_unlock(key, uuid_b)
              &lt;&lt; " (應為0，誤刪保護生效)\n";
    std::cout &lt;&lt; "A 解鎖: " &lt;&lt; redis.lua_unlock(key, uuid_a) &lt;&lt; "\n";
    std::cout &lt;&lt; "B 再加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_b, 10000) &lt;&lt; "\n";
}
</code></pre>
<h3 id="rust--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#rust--mockredis-set-nx-px--lua-check-delete">Rust — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

struct MockRedis {
    store: Mutex&lt;HashMap&lt;String, (String, Instant)&gt;&gt;,
}

impl MockRedis {
    fn new() -&gt; Self {
        MockRedis { store: Mutex::new(HashMap::new()) }
    }
    fn set_nx_px(&amp;self, key: &amp;str, val: &amp;str, ttl_ms: u64) -&gt; bool {
        let mut store = self.store.lock().unwrap();
        if let Some((_, exp)) = store.get(key) {
            if exp.elapsed() &lt; Duration::from_millis(0) {
                return false; // still valid
            }
        }
        let entry = store.entry(key.to_string()).or_insert_with(|| {
            (String::new(), Instant::now())
        });
        if entry.1.elapsed().as_millis() == 0 &amp;&amp; !entry.0.is_empty() {
            return false;
        }
        *entry = (val.to_string(), Instant::now() + Duration::from_millis(ttl_ms));
        true
    }
    fn lua_unlock(&amp;self, key: &amp;str, val: &amp;str) -&gt; bool {
        let mut store = self.store.lock().unwrap();
        if let Some((v, _)) = store.get(key) {
            if v == val {
                store.remove(key);
                return true;
            }
        }
        false
    }
}

fn main() {
    let redis = Arc::new(MockRedis::new());
    println!("A 加鎖: {}", redis.set_nx_px("lock:order", "uuid-a", 10000));
    println!("B 加鎖: {} (應為false)", redis.set_nx_px("lock:order", "uuid-b", 10000));
    println!("B 解鎖: {} (應為false，誤刪保護)", redis.lua_unlock("lock:order", "uuid-b"));
    println!("A 解鎖: {}", redis.lua_unlock("lock:order", "uuid-a"));
    println!("B 再加鎖: {}", redis.set_nx_px("lock:order", "uuid-b", 10000));
}</code></pre></pre>
<h3 id="go--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#go--mockredis-set-nx-px--lua-check-delete">Go — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type entry struct {
    val    string
    expiry time.Time
}

type MockRedis struct {
    mu    sync.Mutex
    store map[string]entry
}

func NewMockRedis() *MockRedis {
    return &amp;MockRedis{store: make(map[string]entry)}
}

func (r *MockRedis) SetNXPX(key, val string, ttl time.Duration) bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    if e, ok := r.store[key]; ok &amp;&amp; time.Now().Before(e.expiry) {
        return false
    }
    r.store[key] = entry{val, time.Now().Add(ttl)}
    return true
}

// LuaUnlock 模擬原子 check-delete
func (r *MockRedis) LuaUnlock(key, val string) bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    if e, ok := r.store[key]; ok &amp;&amp; e.val == val {
        delete(r.store, key)
        return true
    }
    return false
}

func main() {
    redis := NewMockRedis()
    ttl := 10 * time.Second
    fmt.Println("A 加鎖:", redis.SetNXPX("lock:order", "uuid-a", ttl))
    fmt.Println("B 加鎖:", redis.SetNXPX("lock:order", "uuid-b", ttl), "(應為false)")
    fmt.Println("B 解鎖:", redis.LuaUnlock("lock:order", "uuid-b"), "(應為false，誤刪保護)")
    fmt.Println("A 解鎖:", redis.LuaUnlock("lock:order", "uuid-a"))
    fmt.Println("B 再加鎖:", redis.SetNXPX("lock:order", "uuid-b", ttl))
}
</code></pre>
<h3 id="python--mockredis-set-nx-px--lua-check-delete多執行緒驗證"><a class="header" href="#python--mockredis-set-nx-px--lua-check-delete多執行緒驗證">Python — MockRedis SET NX PX + Lua check-delete（多執行緒驗證）</a></h3>
<pre><code class="language-python">"""Chapter 19: distributed lock protocol — MockRedis NX PX + Lua check-delete."""
import threading
import time
import uuid


class MockRedis:
    """模擬 Redis SET NX PX 與 Lua 原子解鎖。"""

    def __init__(self):
        self._store = {}          # key → (value, expire_time)
        self._mu = threading.Lock()

    def set_nx_px(self, key: str, val: str, ttl_ms: int) -&gt; bool:
        """SET key val NX PX ttl → True: 成功取鎖"""
        deadline = time.monotonic() + ttl_ms / 1000
        with self._mu:
            cur = self._store.get(key)
            if cur and cur[1] &gt; time.monotonic():
                return False       # 鎖仍有效，NX 失敗
            self._store[key] = (val, deadline)
            return True

    def lua_unlock(self, key: str, val: str) -&gt; bool:
        """原子 check-and-delete：只有 value 匹配才刪除"""
        with self._mu:
            cur = self._store.get(key)
            if cur and cur[0] == val:
                del self._store[key]
                return True
            return False           # 不是自己的鎖，拒絕刪除


def acquire_and_work(redis: MockRedis, client_id: str, results: list):
    lock_key = "lock:order"
    token = f"{client_id}:{uuid.uuid4()}"
    ok = redis.set_nx_px(lock_key, token, 3000)
    results.append((client_id, "acquired" if ok else "failed"))
    if ok:
        time.sleep(0.05)          # 模擬業務處理
        released = redis.lua_unlock(lock_key, token)
        results.append((client_id, "released" if released else "release_failed"))


def main():
    redis = MockRedis()

    # 基本流程測試
    uuid_a = "client-A"
    ok = redis.set_nx_px("lock:order", uuid_a, 5000)
    print(f"A 加鎖: {ok}")                          # True
    ok = redis.set_nx_px("lock:order", "client-B", 5000)
    print(f"B 加鎖: {ok} (應為 False)")             # False
    ok = redis.lua_unlock("lock:order", "client-B")
    print(f"B 解鎖: {ok} (應為 False，誤刪保護)")   # False
    ok = redis.lua_unlock("lock:order", uuid_a)
    print(f"A 解鎖: {ok}")                          # True

    # 並發競爭測試
    print("\n並發競爭測試（10 客戶端搶同一把鎖）：")
    results = []
    threads = [
        threading.Thread(target=acquire_and_work,
                         args=(redis, f"client-{i}", results))
        for i in range(10)
    ]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    acquired = [r for r in results if r[1] == "acquired"]
    print(f"成功取鎖數量: {len(acquired)} (應為 1，互斥保證)")
    assert len(acquired) == 1, "互斥性失敗！"
    print("通過：分散式鎖互斥性正確")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-18"><a class="header" href="#完整專案級範例python-18">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch19.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch19.py
</code></pre>
<pre><code class="language-python">"""Chapter 19: distributed lock protocol (mocked redis)."""
import time


class MockRedis:
    def __init__(self):
        self.store = {}

    def set_nx_px(self, key: str, val: str, ttl_ms: int) -&gt; bool:
        now = time.time() * 1000
        cur = self.store.get(key)
        if cur and cur[1] &gt; now:
            return False
        self.store[key] = (val, now + ttl_ms)
        return True

    def unlock_if_value(self, key: str, val: str) -&gt; bool:
        cur = self.store.get(key)
        if cur and cur[0] == val:
            del self.store[key]
            return True
        return False


if __name__ == "__main__":
    r = MockRedis()
    owner = "uuid-a"
    ok = r.set_nx_px("lock:order", owner, 3000)
    print("lock acquired", ok)
    print("unlock", r.unlock_if_value("lock:order", owner))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第20章-秒殺系統架構"><a class="header" href="#第20章-秒殺系統架構">第20章 秒殺系統架構</a></h1>
<h2 id="201-電商基礎架構"><a class="header" href="#201-電商基礎架構">20.1 電商基礎架構</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-81"><a class="header" href="#本小節示意圖-81">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["電商系統分層架構"]
  N2["使用者請求"]
  N3["接入層"]
  N4["CDN Nginx"]
  N5["靜態資源 反向代理"]
  N6["快取 負載均衡"]
  N7["動態請求"]
  N8["閘道層"]
  N9["限流 認證/鑑權"]
  N10["Token Bucket JWT / Session"]
  N11["業務層"]
  N12["訂單服務 庫存服務"]
  N13["OrderService StockService"]
  N14["防重 / 支付 扣減 / 補償"]
  N15["快取層"]
  N16["Redis Cluster"]
  N17["・庫存計數（stock:sku:001 = 1000）"]
  N18["・防重 Token（setnx order:uid）"]
  N19["・限流計數器"]
  N20["讀未命中 / 最終持久化"]
  N21["資料層"]
  N22["MySQL（主從分離）"]
  N23["・訂單表 / 庫存表"]
  N24["・對賬記錄"]
  N25["Consumer 消費"]
  N26["異步層"]
  N27["MQ（Kafka/RMQ） Consumer Worker"]
  N28["削峰平滑流量 非同步落庫"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N6 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N19 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N24 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
</code></pre>
<p>入口層、業務層、資料層、異步層缺一不可。</p>
<h2 id="202-秒殺特性對應-20212022"><a class="header" href="#202-秒殺特性對應-20212022">20.2 秒殺特性（對應 20.2.1~20.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-82"><a class="header" href="#本小節示意圖-82">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["正常流量 vs 秒殺瞬間流量對比"]
  N2["QPS"]
  N3["(萬)"]
  N4["100"]
  N5["50"]
  N6["10 正常基線"]
  N7["1"]
  N8["0 時間"]
  N9["秒殺 持續約 5 分鐘 流量回落"]
  N10["開始"]
  N11["T0"]
  N12["秒殺瞬間特性"]
  N13["・流量是平時的 100x（10萬 QPS vs 正常 1000 QPS）"]
  N14["・熱點 key: 少數 SKU 被高頻存取（Redis 熱點問題）"]
  N15["・超賣風險: 多節點並發扣減同一庫存"]
  N16["・重複下單: 用戶多次點擊「搶購」按鈕"]
  N17["・容錯窗口極短: 5 分鐘內必須解決，無法慢慢修"]
  N18["關鍵挑戰"]
  N19["問題 應對策略"]
  N20["熱點 key 庫存分段（多個 Redis key 分散）"]
  N21["超賣 Lua 原子扣減 + 回滾"]
  N22["重複下單 SETNX 冪等 Token"]
  N23["DB 打爆 異步 MQ 削峰"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N4 --&gt; N5
  N4 --&gt; N6
  N6 --&gt; N7
  N6 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
</code></pre>
<p>高峰值、瞬時流量、熱點資料、低容錯窗口。</p>
<h2 id="203-活動前中後對應-20312032"><a class="header" href="#203-活動前中後對應-20312032">20.3 活動前中後（對應 20.3.1~20.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-83"><a class="header" href="#本小節示意圖-83">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["秒殺活動生命週期時間軸"]
  N2["活動前（T0 之前）"]
  N3["T-24h T-1h T-10min T0（秒殺開始）"]
  N4["[庫存 [壓測 [暖機 [流量"]
  N5["資料 模擬 Redis 湧入]"]
  N6["預熱] 100x 庫存]"]
  N7["流量] 必須在 T0 前完成所有準備"]
  N8["預熱快取"]
  N9["・提前 SET stock:sku:001 1000（庫存寫入 Redis）"]
  N10["・提前載入商品詳情到快取（避免秒殺時打 DB）"]
  N11["壓測"]
  N12["・使用 wrk/JMeter 模擬 10萬 QPS"]
  N13["・確認系統瓶頸、調整連線池/執行緒池"]
  N14["擴容"]
  N15["・水平擴展應用層（K8s 預先 scale out）"]
  N16["・Redis 記憶體確認充裕"]
  N17["秒殺進行中（T0 ~ T0+5min）"]
  N18["T0 T0+1min T0+5min"]
  N19["[限流閘道] [庫存售罄] [流量回落]"]
  N20["[MQ 緩衝] [標記售罄標誌] [等待 MQ 消化]"]
  N21["[降級靜態頁] [拒絕後續請求]"]
  N22["活動後（T0+5min 之後）"]
  N23["T0+5min T0+1h T0+24h"]
  N24["[Consumer [對賬: [縮容"]
  N25["消化 MQ] Redis庫存 釋放多餘"]
  N26["[落庫訂單] vs DB庫存] 應用實例]"]
  N27["[補償異常單]"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N4 --&gt; N5
  N4 --&gt; N6
  N6 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N24 --&gt; N25
  N1 --&gt; N26
  N26 --&gt; N27
</code></pre>
<ul>
<li>前：預熱快取、壓測、擴容</li>
<li>中：限流、降級、削峰</li>
<li>後：對賬、補償、回放</li>
</ul>
<h2 id="204-同步與異步下單對應-20412042"><a class="header" href="#204-同步與異步下單對應-20412042">20.4 同步與異步下單（對應 20.4.1~20.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-84"><a class="header" href="#本小節示意圖-84">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["同步下單 vs 異步下單對比"]
  N2["同步下單（直接寫 DB）"]
  N3["User API Server MySQL DB"]
  N4["每次請求直接寫 DB"]
  N5["響應 200ms~2s"]
  N6["問題"]
  N7["・10 萬 QPS DB 無法承受（通常 MySQL 上限 1000~5000 QPS）"]
  N8["・響應時間長 連線池耗盡 雪崩"]
  N9["時間軸"]
  N10["Req1 [API] [DB寫] 回應"]
  N11["Req2 [API] [DB寫] 回應"]
  N12["Req1000 [API] DB 超載！逾時！"]
  N13["異步下單（MQ 削峰）"]
  N14["User API Server MQ (Kafka) Consumer MySQL DB"]
  N15["毫秒級入隊 按 DB 速率消費"]
  N16["（平滑寫入）"]
  N17["立即返回「搶購成功，訂單處理中」"]
  N18["時間軸"]
  N19["T=0: User 請求 API 入 MQ 立即返回（&amp;lt; 10ms）"]
  N20["T=1s: Consumer 消費 MQ 寫 DB（每秒 5000 條）"]
  N21["T=20s: 所有訂單落庫完成"]
  N22["比較"]
  N23["同步下單 異步下單"]
  N24["響應時間 200ms~2s &amp;lt; 10ms"]
  N25["DB 峰值壓力 = 用戶 QPS Consumer 速率控制"]
  N26["用戶體驗 等待結果 樂觀返回+通知"]
  N27["複雜度 低 高（需 MQ+補償）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N3 --&gt; N4
  N3 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N14 --&gt; N15
  N14 --&gt; N16
  N14 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
</code></pre>
<p>同步直寫簡單但容易打爆；異步用 MQ 平滑流量。</p>
<h2 id="205-扣庫存策略對應-20512055"><a class="header" href="#205-扣庫存策略對應-20512055">20.5 扣庫存策略（對應 20.5.1~20.5.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-85"><a class="header" href="#本小節示意圖-85">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["三種扣庫存時機比較"]
  N2["策略一: 下單時扣庫存"]
  N3["用戶下單 扣減 stock 建立訂單 等待支付 支付完成"]
  N4["若超時未支付 需要定時任務歸還庫存"]
  N5["優點: 超賣風險低（下單即鎖定）"]
  N6["缺點: 惡意用戶可佔庫存不付款；持鎖時間長"]
  N7["策略二: 付款時扣庫存"]
  N8["用戶下單 建立訂單(不扣庫存) 支付完成 扣減 stock"]
  N9["可能已無庫存"]
  N10["超賣！"]
  N11["優點: 庫存利用率高"]
  N12["缺點: 超賣風險高（多人下單 同時支付 最後才扣庫存）"]
  N13["策略三: 預扣 + 支付確認（最安全）"]
  N14["用戶下單"]
  N15["Redis 預扣: DECR stock:sku:001"]
  N16["成功（&amp;gt;= 0） 建立預訂單（鎖定庫存）"]
  N17["用戶支付"]
  N18["支付成功 支付失敗/超時"]
  N19["DB 落庫 補償: INCR stock 歸還"]
  N20["失敗（&amp;lt; 0） INCR 回滾 返回售罄"]
  N21["策略對比"]
  N22["策略 超賣風險 持鎖時間 補償複雜度"]
  N23["下單扣 低 長 定時任務歸還"]
  N24["付款扣 高 短 超賣後補"]
  N25["預扣+確認 極低 中 INCR 補償"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N3 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N8 --&gt; N9
  N9 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N15 --&gt; N16
  N15 --&gt; N17
  N15 --&gt; N18
  N15 --&gt; N19
  N15 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
</code></pre>
<p>下單扣、付款扣、預扣各有一致性風險。</p>
<h2 id="206-redis-庫存與防超賣對應-20612064"><a class="header" href="#206-redis-庫存與防超賣對應-20612064">20.6 Redis 庫存與防超賣（對應 20.6.1~20.6.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-86"><a class="header" href="#本小節示意圖-86">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Redis Lua 原子扣減防超賣 + SETNX 防重下單"]
  N2["Lua 原子扣減流程"]
  N3["用戶請求"]
  N4["Lua 腳本（原子執行，不被中斷）"]
  N5["local stock = redis.call('DECR', KEYS[1])"]
  N6["if stock &amp;gt;= 0 then"]
  N7["return 1 -- 扣減成功"]
  N8["else"]
  N9["redis.call('INCR', KEYS[1]) -- 回滾"]
  N10["return 0 -- 售罄"]
  N11["end"]
  N12["返回 1 or 0"]
  N13["1（成功） 進入下單流程"]
  N14["0（售罄） 返回「已售罄」頁面"]
  N15["SETNX 防重下單"]
  N16["用戶 uid=1001 點擊搶購"]
  N17["SETNX order:1001:sku:001 \"1\" EX 300"]
  N18["成功（首次） 允許下單"]
  N19["失敗（已有） 返回「您已下單，請勿重複」"]
  N20["整體防超賣流程"]
  N21["請求進入"]
  N22["[限流檢查: 令牌桶]"]
  N23["通過"]
  N24["[防重檢查: SETNX order:uid:sku]"]
  N25["非重複"]
  N26["[Lua 原子扣庫存: DECR stock:sku]"]
  N27["stock &amp;gt;= 0"]
  N28["[入 MQ 異步落庫]"]
  N29["[返回: 「搶購成功」]"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N11 --&gt; N12
  N11 --&gt; N13
  N11 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N17 --&gt; N18
  N17 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N22 --&gt; N23
  N1 --&gt; N24
  N24 --&gt; N25
  N1 --&gt; N26
  N26 --&gt; N27
  N1 --&gt; N28
  N1 --&gt; N29
</code></pre>
<p>原子扣減 + 分段庫存 + 防重 + 風控。</p>
<h2 id="207-系統與網路優化對應-20712074"><a class="header" href="#207-系統與網路優化對應-20712074">20.7 系統與網路優化（對應 20.7.1~20.7.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-87"><a class="header" href="#本小節示意圖-87">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["系統調優清單"]
  N2["OS 層優化"]
  N3["・ulimit -n 65535 增大最大檔案/連線數"]
  N4["・/proc/sys/net/core/somaxconn 增大 listen backlog"]
  N5["・TCP_NODELAY 關閉 Nagle 算法，降低延遲"]
  N6["・vm.swappiness=1 減少 swap，避免延遲尖刺"]
  N7["網路層優化"]
  N8["・TCP keepalive 複用連線，避免頻繁三次握手"]
  N9["・SO_REUSEPORT 多個 worker 共用同一 port，核心分流"]
  N10["Worker 1 Worker 2 Worker 3"]
  N11["8080 :8080 :8080"]
  N12["核心按 CPU 親和性分發連線（SO_REUSEPORT）"]
  N13["連線池優化"]
  N14["DB 連線池"]
  N15["・pool_size = CPU核數 × 2（避免過多上下文切換）"]
  N16["・max_overflow = pool_size × 2"]
  N17["・pool_timeout = 30s（避免無限等待）"]
  N18["Redis 連線池"]
  N19["・每個應用節點保持 10~50 個長連線"]
  N20["・避免頻繁 connect/disconnect"]
  N21["CDN 與靜態資源"]
  N22["用戶 CDN（命中） 直接返回靜態頁（不過業務層）"]
  N23["CDN（未命中） 回源 Nginx 快取"]
  N24["秒殺頁面應 100% 靜態化"]
  N25["・商品詳情頁: 提前生成 HTML"]
  N26["・圖片/JS/CSS: CDN 邊緣節點快取"]
  N27["・倒計時: 前端 JS 本地計算，不請求後端"]
  N28["整體優化效益"]
  N29["項目 優化前 優化後"]
  N30["最大 QPS 1萬 20萬"]
  N31["P99 延遲 500ms 20ms"]
  N32["DB 壓力 100% 10%（MQ 削峰）"]
  N33["CPU 使用率 90%（白旋） 60%（有效計算）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
  N1 --&gt; N29
  N1 --&gt; N30
  N1 --&gt; N31
  N1 --&gt; N32
  N1 --&gt; N33
</code></pre>
<p>OS 參數、連線池、TCP 調優、機房拓樸都影響上限。</p>
<pre><code class="language-text">User -&gt; Gateway -&gt; RateLimit -&gt; MQ -&gt; OrderSvc -&gt; Stock(Redis/DB)
</code></pre>
<h2 id="示意圖-14"><a class="header" href="#示意圖-14">示意圖</a></h2>
<pre><code class="language-text">Client -&gt; Gateway -&gt; RateLimiter -&gt; MQ -&gt; OrderWorker -&gt; RedisStock -&gt; DB
高峰流量先削峰，再異步消化
</code></pre>
<h2 id="跨語言完整範例-19"><a class="header" href="#跨語言完整範例-19">跨語言完整範例</a></h2>
<h3 id="c--秒殺核心原子庫存扣減--防重--令牌桶限流"><a class="header" href="#c--秒殺核心原子庫存扣減--防重--令牌桶限流">C — 秒殺核心：原子庫存扣減 + 防重 + 令牌桶限流</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define MAX_USERS   100
#define INIT_STOCK  5

/* ── 令牌桶限流 ── */
typedef struct {
    atomic_int tokens;
    int capacity;
    pthread_mutex_t mu;
} TokenBucket;

void bucket_init(TokenBucket *b, int cap) {
    atomic_init(&amp;b-&gt;tokens, cap);
    b-&gt;capacity = cap;
    pthread_mutex_init(&amp;b-&gt;mu, NULL);
}

int bucket_take(TokenBucket *b) {
    int t = atomic_fetch_sub(&amp;b-&gt;tokens, 1);
    return t &gt; 0;
}

/* ── 防重（冪等）表 ── */
static int order_submitted[MAX_USERS];
static pthread_mutex_t idem_mu = PTHREAD_MUTEX_INITIALIZER;

int check_and_mark(int uid) {
    pthread_mutex_lock(&amp;idem_mu);
    int dup = order_submitted[uid];
    if (!dup) order_submitted[uid] = 1;
    pthread_mutex_unlock(&amp;idem_mu);
    return !dup;  /* 1: 首次, 0: 重複 */
}

/* ── 庫存原子扣減 ── */
static atomic_int stock = ATOMIC_VAR_INIT(INIT_STOCK);

int deduct_stock(void) {
    int cur = atomic_fetch_sub(&amp;stock, 1);
    if (cur &gt; 0) return 1;
    atomic_fetch_add(&amp;stock, 1);  /* 回滾 */
    return 0;
}

/* ── 秒殺主流程 ── */
typedef struct { int uid; TokenBucket *bucket; int *results; } Task;

void *seckill(void *arg) {
    Task *t = (Task *)arg;
    int uid = t-&gt;uid;
    /* 限流 */
    if (!bucket_take(t-&gt;bucket)) { t-&gt;results[uid] = -1; return NULL; }
    /* 防重 */
    if (!check_and_mark(uid)) { t-&gt;results[uid] = -2; return NULL; }
    /* 扣庫存 */
    t-&gt;results[uid] = deduct_stock() ? 1 : 0;
    return NULL;
}

int main(void) {
    TokenBucket bucket;
    bucket_init(&amp;bucket, 20);  /* 限流：每批最多 20 個請求 */

    int results[MAX_USERS] = {0};
    pthread_t tids[MAX_USERS];
    Task tasks[MAX_USERS];

    for (int i = 0; i &lt; MAX_USERS; i++) {
        tasks[i] = (Task){i, &amp;bucket, results};
        pthread_create(&amp;tids[i], NULL, seckill, &amp;tasks[i]);
    }
    for (int i = 0; i &lt; MAX_USERS; i++) pthread_join(tids[i], NULL);

    int success = 0;
    for (int i = 0; i &lt; MAX_USERS; i++) if (results[i] == 1) success++;
    printf("成功購買人數: %d (初始庫存 %d)\n", success, INIT_STOCK);
    printf("剩餘庫存: %d (應為 0)\n", atomic_load(&amp;stock));
    return 0;
}
</code></pre>
<h3 id="c--秒殺核心原子庫存--防重--令牌桶"><a class="header" href="#c--秒殺核心原子庫存--防重--令牌桶">C++ — 秒殺核心：原子庫存 + 防重 + 令牌桶</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

class TokenBucket {
    std::atomic&lt;int&gt; tokens_;
public:
    TokenBucket(int cap) : tokens_(cap) {}
    bool take() {
        int t = tokens_.fetch_sub(1, std::memory_order_acq_rel);
        return t &gt; 0;
    }
};

class IdempotentGuard {
    std::unordered_set&lt;int&gt; seen_;
    std::mutex mu_;
public:
    bool mark_first(int uid) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        return seen_.insert(uid).second;
    }
};

class StockManager {
    std::atomic&lt;int&gt; stock_;
public:
    StockManager(int init) : stock_(init) {}
    bool deduct() {
        int cur = stock_.fetch_sub(1, std::memory_order_acq_rel);
        if (cur &gt; 0) return true;
        stock_.fetch_add(1, std::memory_order_acq_rel);  /* 回滾 */
        return false;
    }
    int remaining() const { return stock_.load(); }
};

int main() {
    const int USER_COUNT = 100;
    const int INIT_STOCK = 5;

    TokenBucket bucket(20);
    IdempotentGuard idem;
    StockManager stock(INIT_STOCK);
    std::atomic&lt;int&gt; success_count{0};

    auto seckill = [&amp;](int uid) {
        if (!bucket.take()) return;          /* 限流 */
        if (!idem.mark_first(uid)) return;   /* 防重 */
        if (stock.deduct()) {
            success_count.fetch_add(1, std::memory_order_relaxed);
        }
    };

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; USER_COUNT; i++)
        threads.emplace_back(seckill, i);
    for (auto &amp;t : threads) t.join();

    std::cout &lt;&lt; "成功購買人數: " &lt;&lt; success_count.load()
              &lt;&lt; " (初始庫存 " &lt;&lt; INIT_STOCK &lt;&lt; ")\n";
    std::cout &lt;&lt; "剩餘庫存: " &lt;&lt; stock.remaining() &lt;&lt; " (應為 0)\n";
}
</code></pre>
<h3 id="rust--秒殺核心atomici32-原子庫存--hashset-防重"><a class="header" href="#rust--秒殺核心atomici32-原子庫存--hashset-防重">Rust — 秒殺核心：AtomicI32 原子庫存 + HashSet 防重</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;
use std::sync::{Arc, Mutex, atomic::{AtomicI32, Ordering}};
use std::thread;

struct Seckill {
    stock: AtomicI32,
    seen: Mutex&lt;HashSet&lt;u32&gt;&gt;,
    tokens: AtomicI32,
}

impl Seckill {
    fn new(init_stock: i32, rate_limit: i32) -&gt; Self {
        Seckill {
            stock: AtomicI32::new(init_stock),
            seen: Mutex::new(HashSet::new()),
            tokens: AtomicI32::new(rate_limit),
        }
    }
    fn try_buy(&amp;self, uid: u32) -&gt; &amp;'static str {
        if self.tokens.fetch_sub(1, Ordering::AcqRel) &lt;= 0 {
            self.tokens.fetch_add(1, Ordering::AcqRel);
            return "限流拒絕";
        }
        {
            let mut seen = self.seen.lock().unwrap();
            if !seen.insert(uid) { return "重複下單"; }
        }
        let cur = self.stock.fetch_sub(1, Ordering::AcqRel);
        if cur &gt; 0 { "購買成功" } else {
            self.stock.fetch_add(1, Ordering::AcqRel);
            "售罄"
        }
    }
}

fn main() {
    let sk = Arc::new(Seckill::new(5, 20));
    let mut handles = vec![];
    for uid in 0..100u32 {
        let sk = Arc::clone(&amp;sk);
        handles.push(thread::spawn(move || {
            let result = sk.try_buy(uid);
            if result == "購買成功" {
                println!("uid={} 購買成功", uid);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("剩餘庫存: {} (應為 0)", sk.stock.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--秒殺核心syncatomic-庫存--syncmap-防重"><a class="header" href="#go--秒殺核心syncatomic-庫存--syncmap-防重">Go — 秒殺核心：sync/atomic 庫存 + sync.Map 防重</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var (
    stock      int64 = 5
    tokens     int64 = 20
    orderSeen  sync.Map
    successCnt int64
)

func rateLimitPass() bool {
    t := atomic.AddInt64(&amp;tokens, -1)
    return t &gt;= 0
}

func markFirst(uid int) bool {
    _, loaded := orderSeen.LoadOrStore(uid, struct{}{})
    return !loaded
}

func deductStock() bool {
    cur := atomic.AddInt64(&amp;stock, -1)
    if cur &gt;= 0 {
        return true
    }
    atomic.AddInt64(&amp;stock, 1) // 回滾
    return false
}

func seckill(uid int, wg *sync.WaitGroup) {
    defer wg.Done()
    if !rateLimitPass() {
        return
    }
    if !markFirst(uid) {
        return
    }
    if deductStock() {
        atomic.AddInt64(&amp;successCnt, 1)
    }
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go seckill(i, &amp;wg)
    }
    wg.Wait()
    fmt.Printf("成功購買人數: %d (初始庫存 5)\n", atomic.LoadInt64(&amp;successCnt))
    fmt.Printf("剩餘庫存: %d (應為 0)\n", atomic.LoadInt64(&amp;stock))
}
</code></pre>
<h3 id="python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流"><a class="header" href="#python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流">Python — 秒殺核心：MockRedis Lua 原子扣減 + SETNX 防重 + 限流</a></h3>
<pre><code class="language-python">"""Chapter 20: seckill core — atomic stock deduct + idempotent + rate limit."""
import threading
import time


class MockRedis:
    """模擬 Redis 的原子操作：DECR（Lua）與 SETNX。"""

    def __init__(self):
        self._data = {}
        self._mu = threading.Lock()

    def set(self, key: str, value):
        with self._mu:
            self._data[key] = value

    def setnx(self, key: str, value) -&gt; bool:
        """SET key value NX → True: 首次設置成功"""
        with self._mu:
            if key in self._data:
                return False
            self._data[key] = value
            return True

    def lua_deduct_stock(self, key: str) -&gt; bool:
        """原子：DECR key → if &lt; 0: INCR (回滾) return False"""
        with self._mu:
            cur = self._data.get(key, 0)
            if cur &lt;= 0:
                return False
            self._data[key] = cur - 1
            return True

    def get(self, key: str):
        with self._mu:
            return self._data.get(key)


class TokenBucket:
    def __init__(self, capacity: int, refill_per_sec: int):
        self._tokens = capacity
        self._capacity = capacity
        self._refill_rate = refill_per_sec
        self._last_refill = time.monotonic()
        self._mu = threading.Lock()

    def take(self) -&gt; bool:
        with self._mu:
            now = time.monotonic()
            elapsed = now - self._last_refill
            self._tokens = min(
                self._capacity,
                self._tokens + int(elapsed * self._refill_rate)
            )
            self._last_refill = now
            if self._tokens &gt; 0:
                self._tokens -= 1
                return True
            return False


def run_seckill(user_count: int = 100, init_stock: int = 5):
    redis = MockRedis()
    bucket = TokenBucket(capacity=20, refill_per_sec=10)

    redis.set("stock:sku:001", init_stock)

    results = {"success": 0, "sold_out": 0, "limited": 0, "dup": 0}
    results_lock = threading.Lock()

    def buyer(uid: int):
        # 步驟 1：限流
        if not bucket.take():
            with results_lock:
                results["limited"] += 1
            return

        # 步驟 2：防重下單（SETNX）
        order_key = f"order:{uid}:sku:001"
        if not redis.setnx(order_key, "1"):
            with results_lock:
                results["dup"] += 1
            return

        # 步驟 3：Lua 原子扣庫存
        if redis.lua_deduct_stock("stock:sku:001"):
            with results_lock:
                results["success"] += 1
        else:
            with results_lock:
                results["sold_out"] += 1

    threads = [threading.Thread(target=buyer, args=(uid,)) for uid in range(user_count)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    remaining = redis.get("stock:sku:001")
    print(f"初始庫存: {init_stock}")
    print(f"成功購買: {results['success']} (應 &lt;= {init_stock})")
    print(f"售罄拒絕: {results['sold_out']}")
    print(f"限流拒絕: {results['limited']}")
    print(f"重複下單: {results['dup']}")
    print(f"剩餘庫存: {remaining} (應為 0 或正數，不能為負)")
    assert results["success"] &lt;= init_stock, "超賣！"
    assert remaining &gt;= 0, "庫存為負數！"
    print("通過：原子扣減防止超賣，SETNX 防止重複下單")


if __name__ == "__main__":
    run_seckill(user_count=100, init_stock=5)
</code></pre>
<h2 id="完整專案級範例python-19"><a class="header" href="#完整專案級範例python-19">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch20.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch20.py
</code></pre>
<pre><code class="language-python">"""Chapter 20: seckill pipeline demo."""
import queue
import threading

stock = 5
q: queue.Queue[str] = queue.Queue()
mu = threading.Lock()


def worker():
    global stock
    while True:
        user = q.get()
        if user == "STOP":
            return
        with mu:
            if stock &gt; 0:
                stock -= 1
                print(user, "success, left", stock)
            else:
                print(user, "sold out")


if __name__ == "__main__":
    t = threading.Thread(target=worker)
    t.start()
    for i in range(10):
        q.put(f"u{i}")
    q.put("STOP")
    t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附錄ccrustgopython-對照速查"><a class="header" href="#附錄ccrustgopython-對照速查">附錄：C/C++/Rust/Go/Python 對照速查</a></h1>
<div class="table-wrapper"><table><thead><tr><th>主題</th><th>C/C++</th><th>Rust</th><th>Go</th><th>Python</th></tr></thead><tbody>
<tr><td>執行單元</td><td>pthread / std::thread</td><td>std::thread / tokio::spawn</td><td>goroutine</td><td>threading.Thread</td></tr>
<tr><td>互斥鎖</td><td>pthread_mutex / std::mutex</td><td>Mutex&lt;T&gt;</td><td>sync.Mutex</td><td>threading.Lock()</td></tr>
<tr><td>讀寫鎖</td><td>pthread_rwlock / std::shared_mutex</td><td>RwLock&lt;T&gt;</td><td>sync.RWMutex</td><td>threading.RLock()</td></tr>
<tr><td>條件變數</td><td>pthread_cond / condition_variable</td><td>Condvar</td><td>sync.Cond</td><td>threading.Condition</td></tr>
<tr><td>原子操作</td><td>stdatomic.h / std::atomic</td><td>Atomic* (SeqCst/Acquire/Release)</td><td>sync/atomic</td><td>threading.Lock()(模擬)</td></tr>
<tr><td>信號量</td><td>sem_t / counting_semaphore</td><td>Mutex+Condvar / tokio::Semaphore</td><td>channel(buffered)</td><td>threading.Semaphore</td></tr>
<tr><td>執行緒本地</td><td>__thread / thread_local</td><td>thread_local!</td><td>context.Context(顯式傳遞)</td><td>threading.local()</td></tr>
<tr><td>執行緒池</td><td>自建 / OpenMP</td><td>rayon::ThreadPool / tokio</td><td>worker+channel 慣例</td><td>ThreadPoolExecutor</td></tr>
<tr><td>中斷/取消</td><td>stop flag / std::stop_token</td><td>無內建，用 channel</td><td>context.WithCancel</td><td>threading.Event</td></tr>
<tr><td>記憶體順序</td><td>memory_order_*</td><td>Ordering::*</td><td>sync/atomic (無細粒度)</td><td>GIL 保證(CPython)</td></tr>
<tr><td>無鎖計數器</td><td>atomic_fetch_add</td><td>fetch_add(Ordering)</td><td>atomic.AddInt64</td><td>需 Lock(GIL 不保證)</td></tr>
<tr><td>分散式鎖</td><td>不內建</td><td>不內建</td><td>不內建</td><td>不內建(需 Redis 等)</td></tr>
</tbody></table>
</div>
<h2 id="一個跨語言都成立的原則"><a class="header" href="#一個跨語言都成立的原則">一個跨語言都成立的原則</a></h2>
<p>先保證正確性，再談吞吐。</p>
<pre><code class="language-text">正確性(資料不錯) -&gt; 可用性(不死鎖) -&gt; 效能(夠快)
</code></pre>
<h2 id="共同最小模板"><a class="header" href="#共同最小模板">共同最小模板</a></h2>
<pre><code class="language-text">1) 先用 atomic 解決單變數競態
2) 需要複合一致性時改用 lock
3) 併發量大再加 queue/pool/backpressure
</code></pre>
<pre><code class="language-c">// C: atomic -&gt; mutex 升級路徑
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
atomic_int counter = 0;          // 單變數競態 → atomic
pthread_mutex_t mu;              // 複合操作 → mutex
</code></pre>
<pre><code class="language-cpp">// C++: atomic -&gt; mutex 升級路徑
#include &lt;atomic&gt;
#include &lt;mutex&gt;
std::atomic&lt;int&gt; counter{0};    // 單變數
std::mutex mu;                  // 複合操作
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust: Atomic* -&gt; Mutex/RwLock
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::{Mutex, RwLock};
static COUNTER: AtomicI32 = AtomicI32::new(0);  // 單變數
let shared = Mutex::new(HashMap::new());         // 複合操作
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-go">// Go: sync/atomic -&gt; sync.Mutex/RWMutex
import "sync/atomic"
import "sync"
var counter atomic.Int64          // 單變數
var mu sync.Mutex                 // 複合操作
</code></pre>
<pre><code class="language-python"># Python: Lock 保護複合操作（CPython GIL 不保證原子性）
import threading
lock = threading.Lock()
counter = 0                       # 不安全（GIL 不保證 counter += 1）
with lock:                        # 安全的複合操作
    counter += 1
</code></pre>
<h2 id="python-特別說明"><a class="header" href="#python-特別說明">Python 特別說明</a></h2>
<div class="table-wrapper"><table><thead><tr><th>項目</th><th>CPython 行為</th><th>注意事項</th></tr></thead><tbody>
<tr><td>GIL（全域直譯器鎖）</td><td>同一時刻只有一個執行緒跑 Python bytecode</td><td>I/O 密集可受益，CPU 密集用 multiprocessing</td></tr>
<tr><td><code>counter += 1</code></td><td><strong>不是原子</strong>（3 條 bytecode：LOAD/BINARY_ADD/STORE）</td><td>需加 Lock</td></tr>
<tr><td><code>threading.Lock</code></td><td>OS mutex 封裝</td><td>可跨執行緒互斥</td></tr>
<tr><td><code>threading.RLock</code></td><td>可重入鎖</td><td>同執行緒可多次 acquire</td></tr>
<tr><td>真正並行</td><td><code>multiprocessing</code> / <code>concurrent.futures.ProcessPoolExecutor</code></td><td>各自有獨立 GIL</td></tr>
<tr><td>異步並發</td><td><code>asyncio</code>（單執行緒事件迴圈）</td><td>適合 I/O 密集，非多核並行</td></tr>
</tbody></table>
</div>
<h2 id="選型快速決策"><a class="header" href="#選型快速決策">選型快速決策</a></h2>
<pre><code class="language-text">需要多核 CPU 並行運算？
  ├─ 是 → C/C++/Rust/Go（Python 用 multiprocessing）
  └─ 否（I/O 密集）→ 各語言都行，Python asyncio 亦可

需要極低延遲無 GC？
  └─ C/C++/Rust

需要記憶體安全無 data race 編譯期保證？
  └─ Rust

需要最簡單的並發模型？
  └─ Go（goroutine + channel）

需要快速腳本/原型？
  └─ Python（注意 GIL 限制）
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/beautiful-mermaid.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
