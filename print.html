<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>高並發編程通用概念（跨 Java/C++/Rust/Go）</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/flowchart.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">高並發編程通用概念（跨 Java/C++/Rust/Go）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言如何讀這本並發書"><a class="header" href="#前言如何讀這本並發書">前言：如何讀這本並發書</a></h1>
<p>這本書雖然以 Java 展開，但大部分核心概念都不是 Java 專屬，而是所有高並發系統都要面對的通用問題。</p>
<h2 id="三句話抓重點"><a class="header" href="#三句話抓重點">三句話抓重點</a></h2>
<ol>
<li>並發問題的根源是「多執行單元同時碰同一份資料」。</li>
<li>解法分三層：語言層（原子/鎖）、執行時層（排程/執行緒池）、架構層（分散式鎖/削峰）。</li>
<li>高吞吐不是只靠語法，而是整條鏈路一起優化。</li>
</ol>
<h2 id="統一心智模型"><a class="header" href="#統一心智模型">統一心智模型</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 請求 → 任務切分 → 排隊 → 執行 → 寫回資料\n           ｜         ｜       ｜\n         分工      背壓    一致性
st-&gt;n1
</code></pre>
<h2 id="語言對照最小表"><a class="header" href="#語言對照最小表">語言對照最小表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>通用概念</th><th>Java</th><th>C/C++</th><th>Rust</th><th>Go</th></tr></thead><tbody>
<tr><td>執行單元</td><td>Thread</td><td>std::thread/pthread</td><td>std::thread</td><td>goroutine</td></tr>
<tr><td>互斥</td><td>synchronized/Lock</td><td>mutex</td><td>Mutex<T></td><td>sync.Mutex</td></tr>
<tr><td>原子</td><td>Atomic*</td><td>std::atomic</td><td>Atomic*</td><td>sync/atomic</td></tr>
<tr><td>可見性順序</td><td>JMM</td><td>C++ memory model</td><td>同 C++ 原子語義</td><td>Go memory model</td></tr>
</tbody></table>
</div>
<h2 id="閱讀建議"><a class="header" href="#閱讀建議">閱讀建議</a></h2>
<ul>
<li>先讀第 1~6 章建立底層觀念。</li>
<li>再讀第 7~14 章看語言與框架實作。</li>
<li>最後讀第 15~20 章把概念落到工程。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第1章-作業系統與線程調度"><a class="header" href="#第1章-作業系統與線程調度">第1章 作業系統與線程調度</a></h1>
<h2 id="11-計算機基礎對應-111112"><a class="header" href="#11-計算機基礎對應-111112">1.1 計算機基礎（對應 1.1.1~1.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖"><a class="header" href="#本小節示意圖">本小節示意圖</a></h3>
<pre><code class="language-flowchart">cpu=&gt;subroutine: CPU
cu=&gt;operation: 控制單元 (CU)
alu=&gt;operation: 算術邏輯單元 (ALU)
regs=&gt;operation: 暫存器組 (R0..R15)
bus=&gt;operation: 系統匯流排 (System Bus)
ram=&gt;inputoutput: 記憶體 (RAM)
io=&gt;inputoutput: I/O 裝置 (磁碟/網路/鍵盤)

cpu-&gt;cu
cpu-&gt;alu
cpu-&gt;regs
cu-&gt;bus
alu-&gt;bus
regs-&gt;bus
bus-&gt;ram
bus-&gt;io
</code></pre>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 快取層次（速度由快到慢，容量由小到大）：\n　\n  ┌────────────────────────────────────────────────────────────────────────────────┐\n  │  速度: 最快 ◄──────────────────────────────────► 最慢                                │\n  │  容量: 最小 ◄──────────────────────────────────► 最大                                │\n  └────────────────────────────────────────────────────────────────────────────────┘
n2=&gt;operation: 　\n  ┌────────┐   ┌────────┐   ┌────────┐   ┌────────┐   ┌──────────┐   ┌─────────────┐\n  │Register│──▶│  L1$   │──▶│  L2$   │──▶│  L3$   │──▶│   RAM    │──▶│ Disk        │\n  │  ~1ns  │   │  ~4ns  │   │ ~12ns  │   │ ~30ns  │   │ ~100ns   │   │~10ms        │\n  │  &lt;1KB  │   │  64KB  │   │  512KB │   │   8MB  │   │  GB 級別   │   │ TB級         │\n  └────────┘   └────────┘   └────────┘   └────────┘   └──────────┘   └─────────────┘
n3=&gt;operation:    核心獨享      核心獨享      核心獨享      插槽共享        DRAM         持久化
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
</code></pre>
<p>重點：CPU 做計算，記憶體放資料，I/O 負責進出。</p>
<p>白話例子：廚房裡，廚師=CPU，冰箱=記憶體，外送窗口=I/O。快取好比廚師的備料台，常用食材放在手邊，不用每次跑去冰箱。</p>
<h2 id="12-多核與多-cpu對應-121125"><a class="header" href="#12-多核與多-cpu對應-121125">1.2 多核與多 CPU（對應 1.2.1~1.2.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-1"><a class="header" href="#本小節示意圖-1">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 單核時間切片（Concurrency，並發但非並行）：\n　\n時間軸 ──────────────────────────────────────────────►\n       ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐\nCore0  │  T1 │  T2 │  T1 │  T3 │  T2 │  T1 │  T3 │\n       └─────┴─────┴─────┴─────┴─────┴─────┴─────┘
n2=&gt;operation:         ▲                               ▲\n     Context Switch               Context Switch\n     （上下文切換，有額外成本）\n　\n多核真並行（Parallelism）：\n　
n3=&gt;operation: 時間軸 ──────────────────────────────────────────────►\n       ┌─────────────────────────────────────────┐\nCore0  │  T1 │  T1 │  T1 │  T1 │  T1 │  T1 │   │\n       ├─────────────────────────────────────────┤\nCore1  │  T2 │  T2 │  T2 │  T2 │  T2 │  T2 │   │\n       ├─────────────────────────────────────────┤
n4=&gt;operation: Core2  │  T3 │  T3 │  T3 │  T3 │  T3 │  T3 │   │\n       ├─────────────────────────────────────────┤\nCore3  │  T4 │  T4 │  T4 │  T4 │  T4 │  T4 │   │\n       └─────────────────────────────────────────┘\n        真正同時執行，吞吐量 ≈ 單核 × 核心數\n　
n5=&gt;operation: NUMA 多插槽架構（跨 Socket 成本警示）：\n　\n  ┌────────────── Socket 0 ──────────────┐   ┌────────────── Socket 1 ───────────────┐\n  │  ┌────────┐  ┌────────┐             │   │  ┌────────┐  ┌────────┐                │\n  │  │ Core0  │  │ Core1  │  ...        │   │  │ Core4  │  │ Core5  │  ...           │\n  │  └────────┘  └────────┘             │   │  └────────┘  └────────┘                │
n6=&gt;operation:   │       └──────────┘                  │   │       └──────────┘                     │\n  │           L3 Cache (共享)             │   │           L3 Cache (共享)                │\n  │           Local RAM                 │   │           Local RAM                    │\n  └──────────────┬──────────────────────┘   └──────────────┬─────────────────────────┘\n                 │                                         │\n                 └──────────── QPI / UPI 互連 ───────────────┘
n7=&gt;operation:                                （跨 Socket 延遲 ≈ 本地 RAM 的 2~3 倍）\n  ⚠ 跨 Socket 存取 Remote RAM 比 Local RAM 慢得多，設計時盡量讓執行緒存取本地記憶體
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>重點：</p>
<ul>
<li>單核：同時只能真做一件事，靠時間切換看起來像同時。</li>
<li>多核：可真並行。</li>
<li>多 CPU：更多插槽，但跨 Socket 總線協調成本高。</li>
</ul>
<h2 id="13-線程模型對應-131133"><a class="header" href="#13-線程模型對應-131133">1.3 線程模型（對應 1.3.1~1.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-2"><a class="header" href="#本小節示意圖-2">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 三種線程模型對比：\n　\n┌───────────────────────────────────────────────────────────────────────────────────┐\n│  模型 1：1:1 模型（Java / C++ / Rust 標準線程）                                              │\n│                                                                                   │\n│  User Space   [Thread A] [Thread B] [Thread C]                                    │
n2=&gt;operation: │                    │          │          │         每個用戶線程                         │\n│  Kernel Space  [KThread]  [KThread]  [KThread]    直接對應一個核心線程                      │\n│                    │          │          │                                        │\n│  CPU Core      [Core 0]   [Core 1]   [Core 2]                                     │\n│                                                                                   │\n│  優點：OS 直接調度，真正並行；阻塞不影響其他線程                                                        │
n3=&gt;operation: │  缺點：線程創建/切換成本高（syscall），線程數受 OS 限制                                                │\n└───────────────────────────────────────────────────────────────────────────────────┘\n　\n┌───────────────────────────────────────────────────────────────────────────────────┐\n│  模型 2：M:1 模型（舊版 Green Thread / 早期 JVM）                                            │\n│                                                                                   │
n4=&gt;operation: │  User Space  [Thread A][Thread B][Thread C][Thread D][Thread E]                   │\n│                  │         │         │         │         │                        │\n│              └───┴─────────┴─────────┴─────────┴─────────┘                        │\n│                              User-Level Scheduler                                 │\n│                                       │                                           │\n│  Kernel Space                     [KThread]  ← 只有一個核心線程                           │
n5=&gt;operation: │                                       │                                           │\n│  CPU Core                         [Core 0]                                        │\n│                                                                                   │\n│  優點：切換快（不需要 syscall）                                                              │\n│  缺點：任一線程阻塞 → 整個進程卡住；無法利用多核                                                        │\n└───────────────────────────────────────────────────────────────────────────────────┘
n6=&gt;operation: 　\n┌───────────────────────────────────────────────────────────────────────────────────┐\n│  模型 3：M:N 模型（Go goroutine / Erlang process）                                       │\n│                                                                                   │\n│  User Space  [G1][G2][G3][G4][G5][G6][G7][G8]  ← N 個 goroutine（可達百萬）              │\n│               └──┬──┘  └──┬──┘  └──┬──┘  └─┘                                      │
n7=&gt;operation: │              [P0 Queue] [P1 Queue] [P2 Queue]  ← M 個邏輯處理器（≈CPU核數）                 │\n│                    │          │          │                                        │\n│  Kernel Space [KThread0] [KThread1] [KThread2] ← K 個核心線程                          │\n│                    │          │          │                                        │\n│  CPU Core     [Core 0]   [Core 1]   [Core 2]                                      │\n│                                                                                   │
n8=&gt;operation: │  優點：輕量（goroutine ~2KB），阻塞自動切換，真並行                                                 │\n│  缺點：Runtime 複雜；Work Stealing 調度有額外開銷                                              │\n└───────────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<ul>
<li>使用者線程：切換快，但碰到阻塞可能整批卡住。</li>
<li>核心線程：由 OS 調度，隔離好，成本較高。</li>
<li>混合模型：兩者折衷，Go 是最成功的 M:N 實作之一。</li>
</ul>
<h2 id="14-java-線程與-os-線程映射"><a class="header" href="#14-java-線程與-os-線程映射">1.4 Java 線程與 OS 線程映射</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-3"><a class="header" href="#本小節示意圖-3">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Java 線程完整映射鏈：\n　\n  Java 層                  JVM 層               OS 層          硬體層\n  ─────────                ──────               ─────          ──────\n  new Thread()\n      │
n2=&gt;operation:       │ Java API\n      ▼\n  thread.start()\n      │\n      │ JNI 呼叫\n      ▼
n3=&gt;operation:   ┌─────────────────────────────────────────────────────────────────────┐\n  │  JVM Native  │ ──────────────────► pthread_create()\n  │  Thread Code │                                                      │\n  └──────────────┘                          │ Linux syscall\n                                            ▼\n                                    ┌────────────────┐
n4=&gt;operation:                                     │  OS Kernel     │\n                                    │  pthread /     │\n                                    │  clone()       │\n                                    └───────┬────────┘\n                                            │ 調度\n                                            ▼
n5=&gt;operation:                                     ┌────────────────┐\n                                    │   CPU Core     │\n                                    │  執行機器碼         │\n                                    └────────────────┘\n　\nJava 線程狀態機：
n6=&gt;operation: 　\n         ┌─────────────────────────────────────────────────┐\n         │                                                 │\n  start()│                                                 │run() 結束\n         ▼                                                 │\n  ┌─────────┐   OS 分配時間片    ┌───────────┐             │
n7=&gt;operation:   │   NEW   │──────────────────►│ RUNNABLE  │─────────────►│ TERMINATED │\n  └─────────┘                   └─────┬─────┘             │            │\n                                      │                   └────────────┘\n                      synchronized/IO │阻塞\n                      ┌───────────────┼───────────────┐\n                      ▼               ▼               ▼
n8=&gt;operation:                ┌──────────┐  ┌──────────────┐  ┌─────────────────┐\n               │ BLOCKED  │  │   WAITING    │  │TIMED_WAITING    │\n               │(等待鎖)     │  │(wait/join/   │  │(sleep/          │\n               └────┬─────┘  │ park 無超時)  │  │ wait有超時)   │\n                    │        └──────┬───────┘  └──────┬───────┘\n                    │               │                  │
n9=&gt;operation:                     │  鎖釋放        │ notify/          │ 超時/\n                    │               │ unpark           │ interrupt\n                    └───────────────┴──────────────────┘\n                                    │\n                                    ▼\n                               RUNNABLE（重新競爭）
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>Java 的 <code>Thread</code> 最終也要跑在 OS 調度上。C/C++/Rust/Go 一樣，差別主要在 runtime 包裝方式。</p>
<h2 id="跨語言對照"><a class="header" href="#跨語言對照">跨語言對照</a></h2>
<div class="table-wrapper"><table><thead><tr><th>概念</th><th>C</th><th>C++</th><th>Rust</th><th>Go</th></tr></thead><tbody>
<tr><td>執行單元</td><td>pthread</td><td>std::thread</td><td>std::thread</td><td>goroutine（M:N）</td></tr>
<tr><td>啟動方式</td><td>pthread_create</td><td>thread.detach/join</td><td>thread::spawn</td><td>go func()</td></tr>
<tr><td>核數查詢</td><td>sysconf</td><td>thread::hardware_concurrency</td><td>num_cpus crate</td><td>runtime.NumCPU()</td></tr>
<tr><td>線程模型</td><td>1:1（OS pthread）</td><td>1:1（OS pthread）</td><td>1:1（OS pthread）</td><td>M:N（Go runtime）</td></tr>
</tbody></table>
</div>
<h2 id="示意圖"><a class="header" href="#示意圖">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 多核並行執行示意（兩核四線程）：\n　\n時間軸 ────────────────────────────────────────────►\n       ┌──────┬──────┬──────┬──────┬──────┬──────┐\nCore0  │  T1  │  T1  │  T1  │  T3  │  T3  │  T3  │\n       ├──────┼──────┼──────┼──────┼──────┼──────┤
n2=&gt;operation: Core1  │  T2  │  T2  │  T2  │  T4  │  T4  │  T4  │\n       └──────┴──────┴──────┴──────┴──────┴──────┘\n                           ▲\n                      Context Switch\n        （T1/T2 → T3/T4，OS 調度器決定切換時機）
st-&gt;n1
n1-&gt;n2
</code></pre>
<h2 id="跨語言完整範例"><a class="header" href="#跨語言完整範例">跨語言完整範例</a></h2>
<p>建立 2 個執行緒各自打印 tick，並印出 CPU 核心數。</p>
<h3 id="cpthread"><a class="header" href="#cpthread">C（pthread）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

struct args { const char *name; int ticks; };

void *tick_worker(void *arg) {
    struct args *a = (struct args *)arg;
    for (int i = 0; i &lt; a-&gt;ticks; i++) {
        printf("%s tick %d\n", a-&gt;name, i);
        usleep(50000);
    }
    return NULL;
}

int main(void) {
    long cpu_count = sysconf(_SC_NPROCESSORS_ONLN);
    printf("cpu_count = %ld\n", cpu_count);

    pthread_t t1, t2;
    struct args a1 = {"T1", 3}, a2 = {"T2", 3};
    pthread_create(&amp;t1, NULL, tick_worker, &amp;a1);
    pthread_create(&amp;t2, NULL, tick_worker, &amp;a2);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -o tick tick.c -lpthread &amp;&amp; ./tick
</code></pre>
<h3 id="cstdthread"><a class="header" href="#cstdthread">C++（std::thread）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

void tick_worker(const std::string &amp;name, int ticks) {
    for (int i = 0; i &lt; ticks; i++) {
        std::cout &lt;&lt; name &lt;&lt; " tick " &lt;&lt; i &lt;&lt; "\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
}

int main() {
    unsigned int cores = std::thread::hardware_concurrency();
    std::cout &lt;&lt; "cpu_count = " &lt;&lt; cores &lt;&lt; "\n";

    std::thread t1(tick_worker, "T1", 3);
    std::thread t2(tick_worker, "T2", 3);
    t1.join();
    t2.join();
    return 0;
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o tick tick.cpp -lpthread &amp;&amp; ./tick
</code></pre>
<h3 id="ruststdthread"><a class="header" href="#ruststdthread">Rust（std::thread）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn tick_worker(name: &amp;str, ticks: u32) {
    for i in 0..ticks {
        println!("{} tick {}", name, i);
        thread::sleep(Duration::from_millis(50));
    }
}

fn main() {
    let cpu_count = std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(1);
    println!("cpu_count = {}", cpu_count);

    let t1 = thread::spawn(|| tick_worker("T1", 3));
    let t2 = thread::spawn(|| tick_worker("T2", 3));
    t1.join().unwrap();
    t2.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine"><a class="header" href="#gogoroutine">Go（goroutine）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func tickWorker(name string, ticks int, wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 0; i &lt; ticks; i++ {
        fmt.Printf("%s tick %d\n", name, i)
        time.Sleep(50 * time.Millisecond)
    }
}

func main() {
    fmt.Printf("cpu_count = %d\n", runtime.NumCPU())

    var wg sync.WaitGroup
    wg.Add(2)
    go tickWorker("T1", 3, &amp;wg)
    go tickWorker("T2", 3, &amp;wg)
    wg.Wait()
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonthreading"><a class="header" href="#pythonthreading">Python（threading）</a></h3>
<pre><code class="language-python">import os
import threading
import time

def tick_worker(name: str, ticks: int):
    for i in range(ticks):
        print(f"{name} tick {i}")
        time.sleep(0.05)

if __name__ == "__main__":
    print(f"cpu_count = {os.cpu_count()}")
    t1 = threading.Thread(target=tick_worker, args=("T1", 3))
    t2 = threading.Thread(target=tick_worker, args=("T2", 3))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
</code></pre>
<pre><code class="language-bash">python3 tick.py
</code></pre>
<h2 id="完整專案級範例python"><a class="header" href="#完整專案級範例python">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch01.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch01.py
</code></pre>
<pre><code class="language-python">"""Chapter 01: OS scheduling and threads.

展示：
1. 印出 CPU 核心數
2. 建立 2 個執行緒各自打印 tick
3. 觀察執行緒交錯輸出（並發）
"""
import os
import threading
import time


def work(name: str, ticks: int = 3):
    for i in range(ticks):
        print(f"{name} tick {i}", flush=True)
        time.sleep(0.05)


if __name__ == "__main__":
    print(f"cpu_count = {os.cpu_count()}")
    t1 = threading.Thread(target=work, args=("T1",))
    t2 = threading.Thread(target=work, args=("T2",))
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print("done")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第2章-並發基礎概念與風險"><a class="header" href="#第2章-並發基礎概念與風險">第2章 並發基礎概念與風險</a></h1>
<h2 id="21-基本名詞對應-211219"><a class="header" href="#21-基本名詞對應-211219">2.1 基本名詞（對應 2.1.1~2.1.9）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-4"><a class="header" href="#本小節示意圖-4">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 進程 vs 線程：\n　\n  ┌───────────────────────────────────────────────────────────────────┐\n  │  Process 進程（資源容器）                                                 │\n  │  ┌──────────────────────────────────────────────┐                 │\n  │  │  虛擬記憶體空間 / 檔案描述符 / 信號處理器        │                              │
n2=&gt;operation:   │  └──────────────────────────────────────────────┘                 │\n  │                                                                   │\n  │  ┌────────────┐  ┌────────────┐  ┌────────────┐                   │\n  │  │  Thread A  │  │  Thread B  │  │  Thread C  │                   │\n  │  │ (執行單位)     │  │ (執行單位)     │  │ (執行單位)     │                   │\n  │  │  Stack     │  │  Stack     │  │  Stack     │                   │
n3=&gt;operation:   │  │  PC/暫存器    │  │  PC/暫存器    │  │  PC/暫存器    │                   │\n  │  └────────────┘  └────────────┘  └────────────┘                   │\n  │       └──────────────┴──────────────┘                             │\n  │                   共享 Heap / 全域變數                                  │\n  └───────────────────────────────────────────────────────────────────┘\n　
n4=&gt;operation: 並發 Concurrency（交錯推進，不一定同時）：\n　\n  時間軸 ─────────────────────────────────────────────►\n         ┌───┬───┬───┬───┬───┬───┬───┬───┬─────────┐\n  Core0  │ A │ B │ A │ C │ B │ C │ A │ B │ C │\n         └───┴───┴───┴───┴───┴───┴───┴───┴─────────┘
n5=&gt;operation:           ▲   ▲\n        切換  切換（Context Switch）\n　\n並行 Parallelism（真正同時，需要多核）：\n　\n  時間軸 ──────────────────────────────────────────────►
n6=&gt;operation:          ┌─────────────────────────────────────────┐\n  Core0  │  A  │  A  │  A  │  A  │  A  │  A  │    │\n         ├─────────────────────────────────────────┤\n  Core1  │  B  │  B  │  B  │  B  │  B  │  B  │    │\n         └─────────────────────────────────────────┘\n　
n7=&gt;operation: 同步 Sync（呼叫後阻塞等待結果）：\n　\n  caller ──► [發出請求] ──► [等待中...] ──► [得到結果] ──► 繼續往下\n　\n異步 Async（呼叫後立即返回，結果晚點通知）：\n　
n8=&gt;operation:   caller ──► [發出請求] ──► 繼續做其他事情 ...\n                  └──────────────────────────► [callback/future 收到結果]\n　\n阻塞 Blocking（等待期間執行流停住）：\n　\n  T1: ──► [發出 I/O 請求] ──► ░░░░░░░░ WAIT ░░░░░░░░ ──► [繼續]
n9=&gt;operation:                                ▲ 這段時間 CPU 不執行此線程\n　\n非阻塞 Non-blocking（不停住，改輪詢或事件驅動）：\n　\n  T1: ──► [發出 I/O 請求] ──► [做其他工作] ──► [輪詢/事件] ──► [繼續]
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<ul>
<li>進程：資源容器。</li>
<li>線程：執行單位。</li>
<li>並發：交錯進行。</li>
<li>並行：同時進行。</li>
<li>同步/異步：拿結果的方式。</li>
<li>阻塞/非阻塞：等待時是否卡住執行流。</li>
</ul>
<h2 id="22-三大風險對應-221223"><a class="header" href="#22-三大風險對應-221223">2.2 三大風險（對應 2.2.1~2.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-5"><a class="header" href="#本小節示意圖-5">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 並發三大風險三角形：\n　\n                        ┌────────────────────────┐\n                        │    安全性（Safety）         │\n                        │    結果正確性               │\n                        │                        │
n2=&gt;operation:                         │  典型症狀：                 │\n                        │  ・counter 結果偏小         │\n                        │  ・資料庫記錄重複              │\n                        │  ・賬戶餘額計算錯誤             │\n                        └──────────┬─────────────┘\n                                   │
n3=&gt;operation:                          三者往往互相影響\n                        ┌──────────┴─────────────┐\n                        │                        │\n           ┌────────────┴──────────┐  ┌────────┴────────────────────────┐\n           │   活躍性（Liveness）      │  │   效能（Performance）                │\n           │   程式能繼續推進            │  │   速度是否夠快                         │
n4=&gt;operation:            │                      │  │                                  │\n           │  典型症狀：               │  │  典型症狀：                           │\n           │  ・死鎖 Deadlock        │  │  ・鎖競爭（Contention）                │\n           │    T1 等 T2 的鎖        │  │  ・上下文切換過多                        │\n           │    T2 等 T1 的鎖        │  │  ・快取失效（Cache Miss）               │\n           │  ・飢餓 Starvation      │  │  ・假共享（False Sharing）             │
n5=&gt;operation:            │    低優先級線程永遠          │  │                                  │\n           │    搶不到鎖              │  │  解法：鎖粒度、CAS、                     │\n           │  ・活鎖 Livelock        │  │  無鎖結構、線程池調優                      │\n           │    雙方都在讓步但都          │  │                                  │\n           │    無法推進              │  │                                  │\n           └──────────────────────┘  └──────────────────────────────────┘
n6=&gt;operation: 　\n三者關係：\n  ・過度加鎖 → 安全性高，但效能差\n  ・不加鎖   → 效能好，但安全性崩潰\n  ・鎖粒度錯 → 可能同時損失效能和活躍性（死鎖）\n　
n7=&gt;operation: 死鎖示意（T1/T2 互等）：\n　\n  T1: ──► [持有 Lock A] ──► [等待 Lock B] ─► 永久阻塞\n  T2: ──► [持有 Lock B] ──► [等待 Lock A] ─► 永久阻塞\n                    ▲                  ▲\n                    └──── 循環等待 ─────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<ul>
<li>安全性：結果錯（資料競爭）。</li>
<li>活躍性：做不完（死鎖/飢餓/活鎖）。</li>
<li>效能：做得慢（鎖競爭、上下文切換）。</li>
</ul>
<h2 id="23-鎖分類對應-231238"><a class="header" href="#23-鎖分類對應-231238">2.3 鎖分類（對應 2.3.1~2.3.8）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-6"><a class="header" href="#本小節示意圖-6">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 鎖分類樹狀圖：\n　\n                              ┌──────────┐\n                              │   鎖      │\n                              └────┬─────┘\n         ┌──────────┬──────────────┼──────────────┬──────────────┐
n2=&gt;operation:          ▼          ▼              ▼              ▼              ▼\n    ┌─────────┐ ┌─────────┐ ┌───────────┐ ┌──────────┐ ┌─────────────────────────────────┐\n    │悲觀/樂觀    │  │公平/非公平   │  │可重入/不可  │   │共享/獨占    │   │  自旋/阻塞                        │\n    └────┬────┘ └────┬────┘ │重入       │ └────┬─────┘ └──────┬────────────────────────────┘\n         │           │      └─────┬─────┘       │                │\n    ┌────┴────┐  ┌───┴────┐  ┌───┴────┐    ┌───┴────┐    ┌───┴───────────────────────────┐
n3=&gt;operation:     │悲觀鎖      │  │公平鎖      │  │可重入鎖    │    │共享鎖     │    │自旋鎖                           │\n    │先鎖再操作    │  │FIFO 排隊  │  │同線程可    │    │多讀者     │    │忙等                            │\n    │         │  │         │  │多次獲得    │    │同時持有    │    │適合短臨                          │\n    │例：       │  │例：       │  │        │    │        │    │界區                            │\n    │Mutex    │  │Java     │  │例：      │    │例：      │    │                              │\n    │         │  │ReentrantLock│Java    │    │RWLock  │    │                             │
n4=&gt;operation:     │         │  │(fair=true)  │ Reentrant│  │ReadLock│    │                             │\n    └─────────┘  └─────────┘  │Lock   │    └────────┘    └───────────────────────────────┘\n    ┌─────────┐  ┌─────────┐  └────────┘   ┌────────┐    ┌───────────────────────────────┐\n    │樂觀鎖   │  │非公平鎖  │  ┌────────┐   │獨占鎖  │    │阻塞鎖                                     │\n    │先操作後     │  │可插隊      │  │不可重入    │   │同時只有     │    │掛起線程                          │\n    │校驗衝突     │  │         │  │同線程再    │   │一個持有     │    │適合長臨                          │
n5=&gt;operation:     │         │  │例：       │  │次獲取     │   │         │    │界區                            │\n    │例：CAS/   │  │Java     │  │→ 死鎖    │   │例：       │    │                              │\n    │MVCC     │  │Reentrant│  │        │   │Mutex/   │    │例：OS                          │\n    │         │  │Lock     │  │        │   │WriteLock│   │futex                          │\n    └─────────┘  │(預設)   │  └────────┘   └────────┘    └─────────────────────────────────┘\n                 └─────────┘
n6=&gt;operation: 　\n各鎖使用場景選擇指引：\n　\n  ┌────────────────┬────────────────────────────────────────────────┐\n  │  場景           │  推薦鎖類型                                          │\n  ├────────────────┼────────────────────────────────────────────────┤
n7=&gt;operation:   │  讀多寫少       │  共享讀鎖（RWLock）                                     │\n  │  衝突少         │  樂觀鎖（CAS/MVCC）                                   │\n  │  衝突多         │  悲觀鎖（Mutex）                                      │\n  │  臨界區極短     │  自旋鎖（SpinLock）                                     │\n  │  臨界區較長     │  阻塞鎖（OS Mutex）                                     │\n  │  需要遞迴獲取   │  可重入鎖（ReentrantLock）                                │
n8=&gt;operation:   └────────────────┴────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<ul>
<li>悲觀/樂觀</li>
<li>公平/非公平</li>
<li>可重入/不可重入</li>
<li>可中斷/不可中斷</li>
<li>共享/獨占</li>
<li>自旋/阻塞</li>
</ul>
<p>白話例子：</p>
<ul>
<li>公平鎖像銀行抽號，先到先得。</li>
<li>非公平鎖像空位誰搶到誰先辦。</li>
<li>可重入鎖像房間主人可以再進自己的房間；不可重入則會把自己鎖在外面。</li>
</ul>
<h2 id="示意圖-1"><a class="header" href="#示意圖-1">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 競態條件（Race Condition）導致丟失更新：\n　\n  時間軸 ─────────────────────────────────────────────────►\n         Step 1          Step 2          Step 3\n  T1: ──►[read x=0] ──► [計算 0+1=1] ──►           [write x=1] ──►\n  T2: ──►[read x=0] ────────────────────►[計算 0+1=1] ──► [write x=1]
n2=&gt;operation: 　\n  預期：x = 2\n  實際：x = 1  ← T1 的更新被 T2 覆蓋，丟失一次遞增！
st-&gt;n1
n1-&gt;n2
</code></pre>
<h2 id="跨語言完整範例-1"><a class="header" href="#跨語言完整範例-1">跨語言完整範例</a></h2>
<p>無鎖版 vs 加鎖版 counter++（展示 race condition）。</p>
<h3 id="cpthread--無鎖加鎖對比"><a class="header" href="#cpthread--無鎖加鎖對比">C（pthread + 無鎖/加鎖對比）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define THREADS 4
#define ITER    100000

long unsafe_counter = 0;
long safe_counter = 0;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void *unsafe_inc(void *arg) {
    for (int i = 0; i &lt; ITER; i++)
        unsafe_counter++;   /* 非原子，有競態 */
    return NULL;
}

void *safe_inc(void *arg) {
    for (int i = 0; i &lt; ITER; i++) {
        pthread_mutex_lock(&amp;lock);
        safe_counter++;     /* 加鎖保護，結果正確 */
        pthread_mutex_unlock(&amp;lock);
    }
    return NULL;
}

int main(void) {
    pthread_t tid[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, unsafe_inc, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("unsafe_counter = %ld (expected %d)\n", unsafe_counter, THREADS * ITER);

    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, safe_inc, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("safe_counter   = %ld (expected %d)\n", safe_counter, THREADS * ITER);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -O0 -o race race.c -lpthread &amp;&amp; ./race
</code></pre>
<h3 id="cstdthread--stdmutex"><a class="header" href="#cstdthread--stdmutex">C++（std::thread + std::mutex）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

const int THREADS = 4, ITER = 100000;
long unsafe_counter = 0;
long safe_counter = 0;
std::mutex lock;

void unsafe_inc() {
    for (int i = 0; i &lt; ITER; i++)
        unsafe_counter++;
}

void safe_inc() {
    for (int i = 0; i &lt; ITER; i++) {
        std::lock_guard&lt;std::mutex&gt; g(lock);
        safe_counter++;
    }
}

void run(void(*fn)()) {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) ts.emplace_back(fn);
    for (auto &amp;t : ts) t.join();
}

int main() {
    run(unsafe_inc);
    std::cout &lt;&lt; "unsafe: " &lt;&lt; unsafe_counter &lt;&lt; " (expected " &lt;&lt; THREADS*ITER &lt;&lt; ")\n";
    run(safe_inc);
    std::cout &lt;&lt; "safe:   " &lt;&lt; safe_counter   &lt;&lt; " (expected " &lt;&lt; THREADS*ITER &lt;&lt; ")\n";
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -O0 -o race race.cpp -lpthread &amp;&amp; ./race
</code></pre>
<h3 id="ruststdthread--mutex-vs-atomici64"><a class="header" href="#ruststdthread--mutex-vs-atomici64">Rust（std::thread + Mutex vs AtomicI64）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::sync::atomic::{AtomicI64, Ordering};
use std::thread;

const THREADS: usize = 4;
const ITER: i64 = 100_000;

fn main() {
    // 加鎖版：結果正確
    let safe = Arc::new(Mutex::new(0i64));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;safe);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { *c.lock().unwrap() += 1; }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("safe (mutex):  {} (expected {})", *safe.lock().unwrap(), THREADS as i64 * ITER);

    // 原子版：無鎖且正確
    let atomic = Arc::new(AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;atomic);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { c.fetch_add(1, Ordering::Relaxed); }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("safe (atomic): {} (expected {})", atomic.load(Ordering::SeqCst), THREADS as i64 * ITER);
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine--syncmutex-vs-atomic"><a class="header" href="#gogoroutine--syncmutex-vs-atomic">Go（goroutine + sync.Mutex vs atomic）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

const threads, iter = 4, 100_000

func main() {
    // 無鎖（競態，結果通常偏小）
    var unsafe_counter int64
    var wg sync.WaitGroup
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                unsafe_counter++ // data race!
            }
        }()
    }
    wg.Wait()
    fmt.Printf("unsafe:  %d (expected %d)\n", unsafe_counter, threads*iter)

    // 原子版（無鎖且正確）
    var safe_counter int64
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                atomic.AddInt64(&amp;safe_counter, 1)
            }
        }()
    }
    wg.Wait()
    fmt.Printf("safe:    %d (expected %d)\n", safe_counter, threads*iter)
}
</code></pre>
<pre><code class="language-bash">go run main.go
# 加 -race 旗標可偵測競態：
go run -race main.go
</code></pre>
<h3 id="pythonthreading--lock-對比"><a class="header" href="#pythonthreading--lock-對比">Python（threading + Lock 對比）</a></h3>
<pre><code class="language-python">import threading

THREADS, ITER = 4, 100_000

unsafe_counter = 0
safe_counter = 0
lock = threading.Lock()

def unsafe_inc():
    global unsafe_counter
    for _ in range(ITER):
        unsafe_counter += 1   # Python GIL 下通常安全，但不保證

def safe_inc():
    global safe_counter
    for _ in range(ITER):
        with lock:
            safe_counter += 1

def run_threads(fn):
    ts = [threading.Thread(target=fn) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()

run_threads(unsafe_inc)
print(f"unsafe: {unsafe_counter} (expected {THREADS * ITER})")
run_threads(safe_inc)
print(f"safe:   {safe_counter} (expected {THREADS * ITER})")
</code></pre>
<pre><code class="language-bash">python3 race.py
</code></pre>
<h2 id="完整專案級範例python-1"><a class="header" href="#完整專案級範例python-1">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch02.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch02.py
</code></pre>
<pre><code class="language-python">"""Chapter 02: race risk and lock.

展示：
1. 無鎖版 counter（可能有競態，Python GIL 有時會掩蓋，但 C/Rust/Go 明確可見）
2. 有鎖版 counter（結果正確，永遠等於 THREADS * ITER）
"""
import threading

THREADS = 4
ITER = 50_000

counter = 0
lock = threading.Lock()


def inc(n: int):
    global counter
    for _ in range(n):
        with lock:
            counter += 1


if __name__ == "__main__":
    threads = [threading.Thread(target=inc, args=(ITER,)) for _ in range(THREADS)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    print(f"counter = {counter} (expected {THREADS * ITER})")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第3章-三大核心問題分工同步互斥"><a class="header" href="#第3章-三大核心問題分工同步互斥">第3章 三大核心問題：分工、同步、互斥</a></h1>
<h2 id="31-分工對應-311312"><a class="header" href="#31-分工對應-311312">3.1 分工（對應 3.1.1~3.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-7"><a class="header" href="#本小節示意圖-7">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 任務切分流水線（Pipeline 分工）：\n　\n  原始任務（序列）：\n  ┌─────────────────────────────────────────────────────────────────────────────────┐\n  │  Input ──► Parse ──► Compute ──► Store  （全部串行，吞吐量受限）                            │\n  └─────────────────────────────────────────────────────────────────────────────────┘
n2=&gt;operation: 　\n  分工並行化（三個執行緒分擔不同角色）：\n　\n  資料流向：\n　\n  ┌─────────────┐     Queue1      ┌──────────────┐     Queue2     ┌─────────────────┐
n3=&gt;operation:   │   Input     │ ─────────────► │   Parse      │ ─────────────► │   Compute        │\n  │  (讀取資料)     │                │  Thread T1   │                │  Thread T2       │\n  └─────────────┘                └──────────────┘                └──────┬───────────┘\n                                                                         │  Queue3\n                                                                         ▼\n                                                                ┌──────────────┐
n4=&gt;operation:                                                                 │   Store      │\n                                                                │  Thread T3   │\n                                                                └──────────────┘\n　\n  時間軸對比：\n　
n5=&gt;operation:   串行（總時間 = T_parse + T_compute + T_store）：\n  ┌────────┬─────────┬──────────────────────────────────────────────────────────────┐\n  │ Parse  │ Compute │ Store                                                        │\n  └────────┴─────────┴──────────────────────────────────────────────────────────────┘\n　\n  流水線並行（穩態吞吐量 ≈ max(T_parse, T_compute, T_store) 決定瓶頸）：
n6=&gt;operation:   Time: 1  2  3  4  5  6\n  T1:  [P1][P2][P3][P4][P5][P6]  ← Parse\n  T2:     [C1][C2][C3][C4][C5]   ← Compute（等 P1 完）\n  T3:        [S1][S2][S3][S4]    ← Store（等 C1 完）\n              ▲\n           穩態後三個階段同時跑，吞吐量 ≈ 串行的 3 倍
n7=&gt;operation: 　\n  ⚠ 注意：Stage 之間必須用 Queue 緩衝（解耦速率差異）\n  ⚠ 注意：最慢的 Stage 決定整個 Pipeline 的上限（木桶效應）
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>把任務切成可平行的小任務，減少單點瓶頸。</p>
<h2 id="32-同步對應-321322"><a class="header" href="#32-同步對應-321322">3.2 同步（對應 3.2.1~3.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-8"><a class="header" href="#本小節示意圖-8">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 同步：因果關係約束（T1 完成 → T2 才能開始）\n　\n  因果關係圖：\n　\n  Thread T1                           Thread T2\n  ──────────                          ──────────
n2=&gt;operation:   [計算數據]\n  [準備結果]\n       │\n       │  signal / notify / set()\n       ▼\n  ┌────────────┐ ─────────────────────► ┌─────────────────────────────┐
n3=&gt;operation:   │ done 事件  │                         │ 等待 done                      │\n  │ (已發出)    │                         │ wait() 阻塞                    │\n  └────────────┘                         └─────┬──────────────────────┘\n                                               │ 收到通知\n                                               ▼\n                                         [開始消費結果]
n4=&gt;operation:                                          [繼續往下執行]\n　\n  時間軸視角（等待/喚醒機制）：\n　\n  時間 ──────────────────────────────────────────────────►\n  T1:  [工作][工作][工作] ──► signal ──────────────────────
n5=&gt;operation:   T2:  [wait...]░░░░░░░░░░░░░░░░░░░░░░░░ ──► [繼續執行]\n                ▲                            ▲\n           T2 被阻塞                     T1 發出信號後 T2 喚醒\n　\n  常見同步原語對比：\n　
n6=&gt;operation:   ┌──────────────┬────────────────────────────────────────────────────┐\n  │  原語         │  語意                                                 │\n  ├──────────────┼────────────────────────────────────────────────────┤\n  │  Event/Flag  │  1:N 通知，一次性或可重置                                    │\n  │  Semaphore   │  計數信號量，允許 N 個執行緒同時通過                               │\n  │  Barrier     │  所有參與者都到達後才一起放行                                    │
n7=&gt;operation:   │  CountDown   │  計數到 0 後通知等待者                                      │\n  │  Condition   │  wait/notify，配合鎖使用                                 │\n  └──────────────┴────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>約束「先後順序」，避免讀到半成品。</p>
<h2 id="33-互斥對應-331332"><a class="header" href="#33-互斥對應-331332">3.3 互斥（對應 3.3.1~3.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-9"><a class="header" href="#本小節示意圖-9">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 互斥：臨界區保護（同一時間只有一個執行緒進入）\n　\n  ┌────────────────────────────────────────────────────────────────────┐\n  │                       臨界區（Critical Section）                        │\n  │                                                                    │\n  │  ┌──────────┐     lock()    ┌───────────────────┐                  │
n2=&gt;operation:   │  │ Thread 1 │ ─────────────►│  正在執行          │                     │\n  │  └──────────┘   成功，進入   │  counter++         │                     │\n  │                             └───────────────────┘                  │\n  │  ┌──────────┐     lock()    ┌───────────────────┐                  │\n  │  │ Thread 2 │ ─────────────►│  阻塞等待...       │                     │\n  │  └──────────┘   失敗，排隊   │  ░░░░░░░░░░░░░░    │                     │
n3=&gt;operation:   │                             └───────────────────┘                  │\n  │  ┌──────────┐     lock()    ┌───────────────────┐                  │\n  │  │ Thread 3 │ ─────────────►│  阻塞等待...       │                     │\n  │  └──────────┘   失敗，排隊   │  ░░░░░░░░░░░░░░    │                     │\n  │                             └───────────────────┘                  │\n  └────────────────────────────────────────────────────────────────────┘
n4=&gt;operation: 　\n  鎖的生命週期：\n　\n  Thread 1:  ──► lock() ──► [臨界區] ──► unlock() ──►\n                  │                          │\n                  │ 獲取鎖（進入）            │ 釋放鎖
n5=&gt;operation:                   ▼                          ▼\n  Thread 2:  ──► lock() ── 阻塞....... ──► [臨界區] ──► unlock() ──►\n                           ▲               ▲\n                        T1 持有鎖時        T1 unlock 後\n                        T2 被阻塞          T2 被喚醒\n　
n6=&gt;operation:   互斥保護的是「操作的不可分性」，確保中間狀態不被其他執行緒看見。
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>同一時間只允許一個執行單元修改共享資料。</p>
<p>白話例子：結帳金額是共享資源，兩個收銀機同時改同筆訂單會亂掉；互斥鎖好比「正在服務中，請稍候」的牌子。</p>
<h2 id="示意圖-2"><a class="header" href="#示意圖-2">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 三大核心問題綜合示意（Pipeline + 同步 + 互斥）：\n　\n  ┌──────────┐       Queue        ┌──────────────┐      Queue      ┌─────────────────────────────┐\n  │ Producer │ ──────────────────►│    Buffer    │───────────────► │ Consumer                    │\n  │  Thread  │  (互斥：每次只有          │  (同步：        │ (互斥：每次只有        │  Thread                     │\n  │ 生產資料     │   一個寫入者)           │  Buffer 非空   │  一個讀取者)         │ 消費資料                        │
n2=&gt;operation:   └──────────┘                    │  才能消費）   │                 └─────────────────────────────────┘\n                                  └──────────────┘\n　\n  分工：Producer 和 Consumer 各自獨立執行（分工）\n  同步：Consumer 等待 Buffer 有資料（同步）\n  互斥：Buffer 的讀寫必須互斥，防止資料損毀（互斥）
st-&gt;n1
n1-&gt;n2
</code></pre>
<h2 id="跨語言完整範例-2"><a class="header" href="#跨語言完整範例-2">跨語言完整範例</a></h2>
<p>三執行緒 Pipeline（Producer → Buffer → Consumer），展示分工 + 同步 + 互斥。</p>
<h3 id="cpthread--condition-variable"><a class="header" href="#cpthread--condition-variable">C（pthread + condition variable）</a></h3>
<pre><code class="language-c">#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define BUFFER_SIZE 8
#define ITEMS 10

int buffer[BUFFER_SIZE];
int head = 0, tail = 0, count = 0;
int done = 0;

pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t not_full  = PTHREAD_COND_INITIALIZER;
pthread_cond_t not_empty = PTHREAD_COND_INITIALIZER;

void *producer(void *arg) {
    for (int i = 0; i &lt; ITEMS; i++) {
        pthread_mutex_lock(&amp;mu);
        while (count == BUFFER_SIZE)
            pthread_cond_wait(&amp;not_full, &amp;mu);
        buffer[tail] = i;
        tail = (tail + 1) % BUFFER_SIZE;
        count++;
        printf("[Producer] put %d\n", i);
        pthread_cond_signal(&amp;not_empty);
        pthread_mutex_unlock(&amp;mu);
    }
    pthread_mutex_lock(&amp;mu);
    done = 1;
    pthread_cond_signal(&amp;not_empty);
    pthread_mutex_unlock(&amp;mu);
    return NULL;
}

void *consumer(void *arg) {
    while (1) {
        pthread_mutex_lock(&amp;mu);
        while (count == 0 &amp;&amp; !done)
            pthread_cond_wait(&amp;not_empty, &amp;mu);
        if (count == 0 &amp;&amp; done) { pthread_mutex_unlock(&amp;mu); break; }
        int val = buffer[head];
        head = (head + 1) % BUFFER_SIZE;
        count--;
        printf("[Consumer] got %d\n", val);
        pthread_cond_signal(&amp;not_full);
        pthread_mutex_unlock(&amp;mu);
    }
    return NULL;
}

int main(void) {
    pthread_t p, c;
    pthread_create(&amp;p, NULL, producer, NULL);
    pthread_create(&amp;c, NULL, consumer, NULL);
    pthread_join(p, NULL);
    pthread_join(c, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -o pipeline pipeline.c -lpthread &amp;&amp; ./pipeline
</code></pre>
<h3 id="cstdthread--condition_variable"><a class="header" href="#cstdthread--condition_variable">C++（std::thread + condition_variable）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;queue&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

const int ITEMS = 10;
std::queue&lt;int&gt; buffer;
std::mutex mu;
std::condition_variable not_empty;
bool producer_done = false;

void producer() {
    for (int i = 0; i &lt; ITEMS; i++) {
        std::unique_lock&lt;std::mutex&gt; lock(mu);
        buffer.push(i);
        std::cout &lt;&lt; "[Producer] put " &lt;&lt; i &lt;&lt; "\n";
        not_empty.notify_one();
    }
    std::unique_lock&lt;std::mutex&gt; lock(mu);
    producer_done = true;
    not_empty.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock&lt;std::mutex&gt; lock(mu);
        not_empty.wait(lock, [] { return !buffer.empty() || producer_done; });
        if (buffer.empty()) break;
        int val = buffer.front(); buffer.pop();
        std::cout &lt;&lt; "[Consumer] got " &lt;&lt; val &lt;&lt; "\n";
    }
}

int main() {
    std::thread p(producer), c(consumer);
    p.join(); c.join();
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o pipeline pipeline.cpp -lpthread &amp;&amp; ./pipeline
</code></pre>
<h3 id="ruststdsyncmpsc-channel"><a class="header" href="#ruststdsyncmpsc-channel">Rust（std::sync::mpsc channel）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

const ITEMS: i32 = 10;

fn main() {
    let (tx, rx) = mpsc::channel::&lt;i32&gt;();

    let producer = thread::spawn(move || {
        for i in 0..ITEMS {
            println!("[Producer] put {}", i);
            tx.send(i).unwrap();
            thread::sleep(Duration::from_millis(10));
        }
        // tx 在此 drop，channel 自動關閉
    });

    let consumer = thread::spawn(move || {
        for val in rx {   // rx 迭代到 channel 關閉為止
            println!("[Consumer] got {}", val);
        }
        println!("[Consumer] done");
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gogoroutine--channel"><a class="header" href="#gogoroutine--channel">Go（goroutine + channel）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "time"
)

const items = 10

func producer(ch chan&lt;- int) {
    for i := 0; i &lt; items; i++ {
        fmt.Printf("[Producer] put %d\n", i)
        ch &lt;- i
        time.Sleep(10 * time.Millisecond)
    }
    close(ch)
}

func consumer(ch &lt;-chan int) {
    for val := range ch {
        fmt.Printf("[Consumer] got %d\n", val)
    }
    fmt.Println("[Consumer] done")
}

func main() {
    ch := make(chan int, 4)  // 緩衝 channel 作為 buffer
    go producer(ch)
    consumer(ch)             // 主 goroutine 當 consumer
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonqueuequeue--threading"><a class="header" href="#pythonqueuequeue--threading">Python（queue.Queue + threading）</a></h3>
<pre><code class="language-python">import queue
import threading

ITEMS = 10
buf: queue.Queue[int] = queue.Queue(maxsize=4)

def producer():
    for i in range(ITEMS):
        buf.put(i)                   # 滿了就阻塞（同步）
        print(f"[Producer] put {i}")
    buf.put(None)                    # 哨兵值通知結束

def consumer():
    while True:
        val = buf.get()              # 空了就阻塞（同步）
        if val is None:
            break
        print(f"[Consumer] got {val}")
    print("[Consumer] done")

if __name__ == "__main__":
    t_prod = threading.Thread(target=producer)
    t_cons = threading.Thread(target=consumer)
    t_prod.start()
    t_cons.start()
    t_prod.join()
    t_cons.join()
</code></pre>
<pre><code class="language-bash">python3 pipeline.py
</code></pre>
<h2 id="完整專案級範例python-2"><a class="header" href="#完整專案級範例python-2">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch03.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch03.py
</code></pre>
<pre><code class="language-python">"""Chapter 03: split work + sync.

展示三大核心問題：
1. 分工：Producer 和 Consumer 各自獨立執行
2. 同步：Consumer 等待 Buffer 有資料（queue.Queue 內建阻塞語意）
3. 互斥：Queue 內部使用鎖保護 Buffer 讀寫
"""
import queue
import threading

buf: queue.Queue[int] = queue.Queue()
barrier = threading.Barrier(3)


def worker(name: str):
    s = 0
    while True:
        try:
            s += buf.get_nowait()
        except queue.Empty:
            break
    print(name, "partial=", s)
    barrier.wait()


if __name__ == "__main__":
    for i in range(1, 11):
        buf.put(i)
    ts = [threading.Thread(target=worker, args=(f"W{i}",)) for i in (1, 2)]
    for t in ts:
        t.start()
    barrier.wait()
    print("all workers reached sync point")
    for t in ts:
        t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4章-本質問題原子性可見性有序性"><a class="header" href="#第4章-本質問題原子性可見性有序性">第4章 本質問題：原子性、可見性、有序性</a></h1>
<h2 id="41-背景對應-411415"><a class="header" href="#41-背景對應-411415">4.1 背景（對應 4.1.1~4.1.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-10"><a class="header" href="#本小節示意圖-10">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 程式從源碼到執行的完整路徑，每個階段都可能引入問題：\n　\n  ┌───────────────────────────────────────────────────────────────────────────┐\n  │  源碼（Source Code）                                                          │\n  │  int x = 0;                                                               │\n  │  x++;                                                                     │
n2=&gt;operation:   └───────────────────────────┬───────────────────────────────────────────────┘\n                              │\n                    ┌─────────▼──────────┐\n                    │  編譯器優化          │  ← 潛在問題：指令重排、死碼刪除\n                    │  (Compiler)         │     volatile/memory_order 可控制\n                    └─────────┬──────────┘
n3=&gt;operation:                               │\n                    ┌─────────▼──────────┐\n                    │  機器碼              │  ← 一條 x++ 變成三條指令：\n                    │  (Machine Code)     │     LOAD r1, [x]\n                    └─────────┬──────────┘     ADD r1, 1\n                              │                STORE [x], r1
n4=&gt;operation:                     ┌─────────▼──────────┐\n                    │  CPU 亂序執行        │  ← 潛在問題：Out-of-Order Execution\n                    │  (OoOE Pipeline)    │     CPU 可調整指令執行順序提升效率\n                    └─────────┬──────────┘\n                              │\n              ┌───────────────┼───────────────┐
n5=&gt;operation:               │               │               │\n    ┌─────────▼──────┐ ┌──────▼─────┐ ┌──────▼──────┐\n    │  Store Buffer  │ │  L1 Cache  │ │  L2 Cache  │  ← 潛在問題：可見性\n    │  (寫入緩衝)        │ │  (核心私有)    │ │  (核心私有) │     一個核心的寫入\n    └────────────────┘ └────────────┘ └────────────┘     對其他核心不立即可見\n                              │
n6=&gt;operation:                     ┌─────────▼──────────┐\n                    │  L3 Cache           │  ← 所有核心共享，但同步有延遲\n                    └─────────┬──────────┘\n                              │\n                    ┌─────────▼──────────┐\n                    │  Main Memory (RAM)  │  ← 最終一致，但時序不保證
n7=&gt;operation:                     └────────────────────┘\n　\n  結論：你以為的「按順序、立即可見」在並發環境中都是假設！
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>CPU、快取、編譯器優化都會讓「你以為的順序」和實際執行不同。</p>
<h2 id="42-原子性對應-421424"><a class="header" href="#42-原子性對應-421424">4.2 原子性（對應 4.2.1~4.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-11"><a class="header" href="#本小節示意圖-11">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: x++ 非原子性拆解（Read-Modify-Write 三步）：\n　\n  高層語義（你寫的）：\n  ┌─────────────────────────────────────────────────────────────┐\n  │    x++          │  ← 看起來是一個操作\n  └─────────────────────────────────────────────────────────────┘
n2=&gt;operation: 　\n  實際機器碼（三個獨立步驟）：\n  ┌──────────┐    ┌──────────┐    ┌─────────────────────────────┐\n  │ LOAD(x)  │──► │ ADD(1)   │──► │ STORE(x)                    │\n  │ r1 = x   │    │ r1 = r1+1│    │ x = r1                      │\n  └──────────┘    └──────────┘    └─────────────────────────────┘
n3=&gt;operation:        ①               ②               ③\n       ▲               ▲               ▲\n  任何兩步之間都可能被其他執行緒打斷！\n　\n  兩個執行緒交錯導致丟失更新（Lost Update）：\n　
n4=&gt;operation:   初始狀態：x = 0\n　\n  時間  Thread T1                    Thread T2\n  ──── ──────────────────────────── ────────────────────────────\n   t1  ① LOAD  r1_T1 = x = 0\n   t2                               ① LOAD  r1_T2 = x = 0
n5=&gt;operation:    t3  ② ADD   r1_T1 = 0 + 1 = 1\n   t4                               ② ADD   r1_T2 = 0 + 1 = 1\n   t5  ③ STORE x = r1_T1 = 1\n   t6                               ③ STORE x = r1_T2 = 1\n　\n  預期結果：x = 2
n6=&gt;operation:   實際結果：x = 1  ← T1 的遞增被 T2 覆蓋，一次更新永久丟失！\n　\n  解法：原子指令（LOCK XADD / fetch_add）確保三步不可分割\n  ┌─────────────────────────────────────────────────────────────┐\n  │  LOCK XADD [x], 1  ← 一條不可分割的原子指令                            │\n  │  等價於：原子地 x = x + 1，中間態對其他 CPU 不可見                           │
n7=&gt;operation:   └─────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p><code>x++</code> 不是原子，實際是讀、改、寫三步。</p>
<h2 id="43-可見性對應-431434"><a class="header" href="#43-可見性對應-431434">4.3 可見性（對應 4.3.1~4.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-12"><a class="header" href="#本小節示意圖-12">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 快取不一致導致可見性問題：\n　\n  ┌─────────────────────────────┐     ┌──────────────────────────────────────┐\n  │         Core 0              │     │         Core 1                       │\n  │                             │     │                                      │\n  │  Thread T1（寫入方）             │     │  Thread T2（讀取方）                      │
n2=&gt;operation:   │                             │     │                                      │\n  │  x = 42;                    │     │  while (x == 0) { }                  │\n  │                             │     │  // 期望讀到 42                          │\n  │  ┌─────────────────────┐    │     │    ┌─────────────────────┐           │\n  │  │  L1 Cache           │    │     │    │  L1 Cache           │           │\n  │  │  ┌───────────────┐  │    │     │    │  ┌───────────────┐  │           │
n3=&gt;operation:   │  │  │  x = 42  (新) │  │    │     │    │  │  x = 0   (舊) │  │             │\n  │  │  └───────────────┘  │    │     │    │  └───────────────┘  │           │\n  │  └─────────────────────┘    │     │    └─────────────────────┘           │\n  └──────────────┬──────────────┘     └──────────────────────────────────────┘\n                 │                                  ▲\n                 │  cache coherence 協議             │  Core1 讀到的是舊值！
n4=&gt;operation:                  │  （MESI 狀態機）                  │  可能永遠看不到 x=42\n                 │                                  │\n                 └──────────────────────────────────┘\n                        需要 memory barrier 刷新\n　\n  MESI 快取一致性協議狀態：
n5=&gt;operation: 　\n  ┌────────────┬─────────────────────────────────────────────────────────────┐\n  │  狀態      │  含義                                                           │\n  ├────────────┼─────────────────────────────────────────────────────────────┤\n  │  Modified  │  本核心有最新值，其他核心的副本無效                                          │\n  │  Exclusive │  只有本核心有此快取行，且與記憶體一致                                         │
n6=&gt;operation:   │  Shared    │  多個核心都有此快取行，且與記憶體一致                                         │\n  │  Invalid   │  此快取行無效，需要重新從記憶體/其他核心讀取                                     │\n  └────────────┴─────────────────────────────────────────────────────────────┘\n　\n  解法：使用 volatile（Java）/ atomic store（C++/Rust/Go）\n  強制寫入時刷到記憶體，讀取時從記憶體重新讀。
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>A 執行緒改值，B 不一定立刻看得到，可能讀到舊快取。</p>
<h2 id="44-有序性對應-441444"><a class="header" href="#44-有序性對應-441444">4.4 有序性（對應 4.4.1~4.4.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-13"><a class="header" href="#本小節示意圖-13">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 指令重排導致有序性問題：\n　\n  程式員視角（期望的執行順序）：\n　\n  Writer 執行緒             Reader 執行緒\n  ──────────────────────    ───────────────────────
n2=&gt;operation:   ① data = 42              ③ if (ready == true)\n  ② ready = true           ④     print(data)  // 期望印出 42\n　\n  CPU/編譯器重排後（實際可能的執行順序）：\n　\n  Writer 執行緒             Reader 執行緒
n3=&gt;operation:   ──────────────────────    ───────────────────────\n  ② ready = true    ←─ ① 和 ② 被重排！\n  ①' data = 42             ③ if (ready == true)   ← 看到 ready=true\n                           ④     print(data)       ← 但 data 還是舊值！\n　\n  時間軸視角：
n4=&gt;operation: 　\n  時間 ─────────────────────────────────────────────────────►\n　\n  Writer: [ready=true] ...... [data=42]  ← 重排後 ready 先寫\n                ↓\n  Reader:       [讀到 ready=true] → [讀 data] ← 此時 data 可能還是 0！
n5=&gt;operation: 　\n  為什麼 CPU 會重排？\n  ┌───────────────────────────────────────────────────────────────┐\n  │  CPU 保證：單執行緒內的語義不變（as-if-serial）                              │\n  │  CPU 不保證：跨執行緒的全域可見順序                                          │\n  │                                                               │
n6=&gt;operation:   │  data 和 ready 在單執行緒內沒有依賴關係                                    │\n  │  → CPU/編譯器認為可以任意調換順序                                          │\n  └───────────────────────────────────────────────────────────────┘\n　\n  解法：Memory Barrier（記憶體屏障）\n　
n7=&gt;operation:   Writer:  data = 42\n           ┌────────────────────────────────────────────┐\n           │  StoreStore Barrier（禁止跨屏障的寫重排）             │\n           └────────────────────────────────────────────┘\n           ready = true\n　
n8=&gt;operation:   Reader:  if (ready)\n           ┌────────────────────────────────────────────┐\n           │  LoadLoad Barrier（禁止跨屏障的讀重排）               │\n           └────────────────────────────────────────────┘\n           print(data)   ← 現在保證讀到正確的 data
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>指令可能重排，只要單執行緒語義不變，編譯器就可能調整。</p>
<h2 id="45-綜合解法對應-451452"><a class="header" href="#45-綜合解法對應-451452">4.5 綜合解法（對應 4.5.1~4.5.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-14"><a class="header" href="#本小節示意圖-14">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 三種問題 vs 三種解法對比：\n　\n  ┌──────────────────┬───────────────────────────────────────────────────────────────┐\n  │  解法             │  原子性 ✓/✗   可見性 ✓/✗   有序性 ✓/✗   適用場景                            │\n  ├──────────────────┼───────────────────────────────────────────────────────────────┤\n  │  原子類型          │    ✓           ✓           部分✓         計數器、狀態旗標                 │
n2=&gt;operation:   │  (atomic int等)  │  CAS/fetch_add  強制刷新   依 memory_order  無鎖演算法                   │\n  ├──────────────────┼───────────────────────────────────────────────────────────────┤\n  │  互斥鎖            │    ✓           ✓            ✓           複雜臨界區                  │\n  │  (mutex/lock)    │  鎖保護整段     解鎖時刷新   鎖保證 HB 關係  讀寫都有的情況                         │\n  ├──────────────────┼───────────────────────────────────────────────────────────────┤\n  │  記憶體屏障         │    ✗           ✓            ✓           底層程式庫開發                 │
n3=&gt;operation:   │  (memory_order)  │  不解決原子性   禁止快取優化  禁止重排       硬體驅動開發                           │\n  └──────────────────┴───────────────────────────────────────────────────────────────┘\n　\n  選擇指引：\n　\n  需要原子計數/旗標？
n4=&gt;operation:       └──► 優先選 atomic（零鎖開銷）\n　\n  臨界區有多個操作需要一起保護？\n      └──► 必須選 mutex（原子類型只能保護單個變數）\n　\n  寫底層庫、需要精細控制記憶體順序？
n5=&gt;operation:       └──► 結合 atomic + 精確的 memory_order\n　\n  producer-consumer 資料傳遞？\n      └──► atomic flag（ready） + 適當 memory_order，或直接用 channel/queue
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<ul>
<li>原子類 + CAS</li>
<li>鎖</li>
<li>記憶體屏障/語言記憶體模型規則</li>
</ul>
<h2 id="示意圖-3"><a class="header" href="#示意圖-3">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 完整問題場景（寫端/讀端的可見性與有序性）：\n　\n  Writer:\n    data = 42;     // Step 1：寫資料\n    ready = true;  // Step 2：設旗標\n　
n2=&gt;operation:   Reader:\n    if (ready)     // Step 3：讀旗標\n        print(data) // Step 4：讀資料\n　\n  若重排/不可見：可能讀到 ready=true 但 data=舊值（0 或垃圾值）\n  解法：ready 使用 atomic，並在 writer 側加 release 屏障，reader 側加 acquire 屏障
st-&gt;n1
n1-&gt;n2
</code></pre>
<h2 id="跨語言完整範例-3"><a class="header" href="#跨語言完整範例-3">跨語言完整範例</a></h2>
<p>用 atomic flag 安全地在兩個執行緒間傳遞數據（producer-consumer with ready flag）。</p>
<h3 id="cgcc-__atomic-內建函式"><a class="header" href="#cgcc-__atomic-內建函式">C（GCC __atomic 內建函式）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;unistd.h&gt;

int data = 0;
atomic_int ready = 0;

void *writer(void *arg) {
    data = 42;                                       /* 先寫資料 */
    atomic_store_explicit(&amp;ready, 1,                 /* 再設旗標，release 語意 */
                          memory_order_release);
    return NULL;
}

void *reader(void *arg) {
    while (!atomic_load_explicit(&amp;ready,             /* 等待旗標，acquire 語意 */
                                 memory_order_acquire))
        ;                                            /* 自旋等待 */
    printf("reader got data = %d\n", data);          /* 保證看到 data=42 */
    return NULL;
}

int main(void) {
    pthread_t w, r;
    pthread_create(&amp;r, NULL, reader, NULL);
    usleep(10000);
    pthread_create(&amp;w, NULL, writer, NULL);
    pthread_join(w, NULL);
    pthread_join(r, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -std=c11 -o ready ready.c -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="cstdatomic-with-memory_order"><a class="header" href="#cstdatomic-with-memory_order">C++（std::atomic with memory_order）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;

int data = 0;
std::atomic&lt;bool&gt; ready{false};

void writer() {
    data = 42;                                     // 先寫資料
    ready.store(true, std::memory_order_release);  // release：之前的寫對 acquire 端可見
}

void reader() {
    while (!ready.load(std::memory_order_acquire)) // acquire：保證讀到 writer 的所有寫入
        std::this_thread::yield();
    std::cout &lt;&lt; "reader got data = " &lt;&lt; data &lt;&lt; "\n";
}

int main() {
    std::thread r(reader);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::thread w(writer);
    w.join();
    r.join();
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o ready ready.cpp -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="ruststdsyncatomic-with-ordering"><a class="header" href="#ruststdsyncatomic-with-ordering">Rust（std::sync::atomic with Ordering）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

static mut DATA: i32 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn main() {
    let reader = thread::spawn(|| {
        while !READY.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let val = unsafe { DATA };
        println!("reader got data = {}", val);
    });

    thread::sleep(Duration::from_millis(10));

    let writer = thread::spawn(|| {
        unsafe { DATA = 42; }                       // 先寫資料
        READY.store(true, Ordering::Release);        // release 屏障後設旗標
    });

    writer.join().unwrap();
    reader.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gosyncatomic--channel-作為-ready-信號"><a class="header" href="#gosyncatomic--channel-作為-ready-信號">Go（sync/atomic + channel 作為 ready 信號）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

var (
    data  int32
    ready atomic.Bool
)

func writer() {
    atomic.StoreInt32(&amp;data, 42)  // 寫資料
    ready.Store(true)             // 設旗標（Go atomic 已包含適當 memory barrier）
}

func reader() {
    for !ready.Load() {           // 等待旗標
        time.Sleep(time.Microsecond)
    }
    fmt.Printf("reader got data = %d\n", atomic.LoadInt32(&amp;data))
}

func main() {
    go reader()
    time.Sleep(10 * time.Millisecond)
    go writer()
    time.Sleep(100 * time.Millisecond) // 等兩個 goroutine 完成
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonthreadingevent-作為-ready-信號"><a class="header" href="#pythonthreadingevent-作為-ready-信號">Python（threading.Event 作為 ready 信號）</a></h3>
<pre><code class="language-python">import threading
import time

data = {"value": None}
ready = threading.Event()   # Event 內建 happens-before 語意

def writer():
    data["value"] = 42      # 先寫資料
    ready.set()             # 設旗標（Event.set() 保證可見性）

def reader():
    ready.wait()            # 阻塞等待旗標（比自旋更節省 CPU）
    print(f"reader got data = {data['value']}")

if __name__ == "__main__":
    t_reader = threading.Thread(target=reader)
    t_reader.start()
    time.sleep(0.02)
    t_writer = threading.Thread(target=writer)
    t_writer.start()
    t_writer.join()
    t_reader.join()
</code></pre>
<pre><code class="language-bash">python3 ready.py
</code></pre>
<h2 id="完整專案級範例python-3"><a class="header" href="#完整專案級範例python-3">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch04.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch04.py
</code></pre>
<pre><code class="language-python">"""Chapter 04: visibility/order via event.

展示：
1. Writer 先寫資料，再設旗標（模擬正確的 release 語意）
2. Reader 等待旗標後讀資料（模擬正確的 acquire 語意）
3. threading.Event 內建 happens-before 保證，確保讀到正確值
"""
import threading
import time

ready = threading.Event()
data = {"value": None}


def writer():
    data["value"] = 42      # Step 1：先寫資料
    ready.set()             # Step 2：設旗標（之後的 reader 保證看到 data=42）


def reader():
    ready.wait()            # 等待旗標（阻塞直到 writer 呼叫 set()）
    print("read value =", data["value"])   # 保證印出 42


if __name__ == "__main__":
    t1 = threading.Thread(target=writer)
    t2 = threading.Thread(target=reader)
    t2.start()
    time.sleep(0.02)
    t1.start()
    t1.join()
    t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第5章-原子性底層"><a class="header" href="#第5章-原子性底層">第5章 原子性底層</a></h1>
<h2 id="51-原子性定義"><a class="header" href="#51-原子性定義">5.1 原子性定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-15"><a class="header" href="#本小節示意圖-15">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 原子性定義：「不可被拆開觀察，要嘛全成功，要嘛回到原狀」\n　\n  骰子比喻（原子操作的語意）：\n　\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  原子操作（Atomic）                                                        │
n2=&gt;operation:   │                                                                      │\n  │  狀態 A ──────────────────────────────────────► 狀態 B                   │\n  │   (x=0)         不可見中間態                     (x=1)                     │\n  │                                                                      │\n  │  其他執行緒只能看到 A 或 B，永遠看不到「介於中間的半完成狀態」                                   │\n  │                           ✓ 成功                                       │
n3=&gt;operation:   └──────────────────────────────────────────────────────────────────────┘\n　\n  非原子操作（Non-Atomic）：x++ 的危險：\n　\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  非原子操作（x++）                                                          │
n4=&gt;operation:   │                                                                      │\n  │  狀態 A         中間態（可被觀察！）           狀態 B                              │\n  │   (x=0)                                        (x=1)                 │\n  │     │                                            │                   │\n  │     ▼                                            ▼                   │\n  │  ① LOAD r1=0  ─────────────────────────►  ③ STORE x=1                │
n5=&gt;operation:   │                     ▲                                                │\n  │                     │                                                │\n  │              ② ADD r1=r1+1                                           │\n  │              （r1 在暫存器，                                               │\n  │               此刻 x 仍是 0）                                             │\n  │                     ▲                                                │
n6=&gt;operation:   │              其他執行緒在 ① 和 ③ 之間可以讀取 x=0 的舊值！                            │\n  └──────────────────────────────────────────────────────────────────────┘\n　\n  比喻：銀行轉帳必須是原子的\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  轉帳 $100：扣款 A 帳戶 + 入款 B 帳戶                                           │
n7=&gt;operation:   │                                                                      │\n  │  原子（正確）：                                                             │\n  │  [A=1000, B=500] ──► [A=900, B=600]   ← 只有這兩種狀態                      │\n  │                                                                      │\n  │  非原子（危險）：                                                            │\n  │  [A=1000, B=500]                                                     │
n8=&gt;operation:   │      ↓ 扣款 A                                                          │\n  │  [A=900,  B=500]  ← 此刻系統崩潰，$100 憑空消失！                                │\n  └──────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>一個操作不可被拆開觀察，要嘛全成，要嘛全不成。</p>
<h2 id="52-cpu-如何做原子對應-521523"><a class="header" href="#52-cpu-如何做原子對應-521523">5.2 CPU 如何做原子（對應 5.2.1~5.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-16"><a class="header" href="#本小節示意圖-16">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: CPU 實現原子操作的三種方式：\n　\n┌───────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│  方式 1：總線鎖（Bus Lock）—— 老方法，代價高                                                                             │\n│                                                                                                           │\n│  CPU0   CPU1   CPU2   CPU3                                                                                │
n2=&gt;operation: │   │                 │                    │      │                                                         │\n│   └──────┴──────┴──────┘                                                                                  │\n│              │                                                                                            │\n│         系統匯流排（Bus）                                                                                        │\n│              │                                                                                            │\n│           記憶體（RAM）                                                                                        │
n3=&gt;operation: │                                                                                                           │\n│  CPU0 執行 LOCK 指令時：                                                                                        │\n│  ① 拉低 LOCK# 信號線，獨占整條匯流排                                                                                   │\n│  ② 其他 CPU 的記憶體存取全部被阻塞                                                                                     │\n│  ③ 完成操作後釋放 LOCK# 信號線                                                                                      │\n│                                                                                                           │
n4=&gt;operation: │  缺點：鎖住整條匯流排，其他無關的記憶體操作也被阻塞，性能差                                                                            │\n└───────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n　\n┌───────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│  方式 2：快取鎖（Cache Lock）+ MESI 協議 —— 現代主流                                                                    │\n│                                                                                                           │
n5=&gt;operation: │  ┌──────────────────┐     ┌──────────────────┐                                                            │\n│   │      CPU0        │                   │      CPU1        │                                             │\n│   │  ┌────────────┐  │                   │  ┌────────────┐  │                                             │\n│  │  │ L1 Cache   │  │     │  │ L1 Cache   │  │                                                            │\n│   │                 │ [x] M ─────┼──┼─────┼──┼─[x] I     │  │  M=Modified, I=Invalid                      │\n│   │  └────────────┘  │                   │  └────────────┘  │                                             │
n6=&gt;operation: │  └──────────────────┘     └──────────────────┘                                                            │\n│                                                                                                           │\n│  CPU0 對 x 做原子操作時：                                                                                         │\n│  ① CPU0 將 x 所在的快取行標記為 Modified（獨占修改）                                                                      │\n│  ② 通過 MESI 協議，通知 CPU1 其快取行變為 Invalid（無效）                                                                  │\n│  ③ CPU0 完成修改後，數據透過快取一致性協議同步                                                                               │
n7=&gt;operation: │                                                                                                           │\n│  優點：只鎖定快取行，不鎖整條匯流排，範圍更小、性能更好                                                                              │\n│  限制：跨快取行（Cache Line Boundary）的操作仍需要總線鎖                                                                    │\n└───────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n　\n┌───────────────────────────────────────────────────────────────────────────────────────────────────────────┐
n8=&gt;operation: │  方式 3：CAS 指令（Compare-And-Swap）—— 無鎖演算法基石                                                                  │\n│                                                                                                           │\n│  x86 指令：CMPXCHG（Compare and Exchange）                                                                     │\n│                                                                                                           │\n│  偽代碼（原子執行，不可被中斷）：                                                                                         │\n│  ┌─────────────────────────────────────────────────────────┐                                              │
n9=&gt;operation: │  │  atomic {                                               │                                              │\n│  │      if (*addr == expected) {                           │                                              │\n│  │          *addr = new_value;                             │                                              │\n│  │          return SUCCESS;                                │                                              │\n│  │      } else {                                           │                                              │\n│  │          return FAIL;      // 呼叫方通常自旋重試                 │                                              │
n10=&gt;operation: │  │      }                                                  │                                              │\n│  │  }                                                      │                                              │\n│  └─────────────────────────────────────────────────────────┘                                              │\n│                                                                                                           │\n│  優點：無鎖、輕量；缺點：ABA 問題（需加版本號解決）                                                                              │\n└───────────────────────────────────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<ul>
<li>總線鎖（老方法）</li>
<li>快取鎖（現代常見）</li>
<li>原子指令（如 CAS）</li>
</ul>
<h2 id="53-互斥鎖模型對應-531532"><a class="header" href="#53-互斥鎖模型對應-531532">5.3 互斥鎖模型（對應 5.3.1~5.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-17"><a class="header" href="#本小節示意圖-17">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 互斥鎖完整生命週期（含 OS 阻塞/喚醒路徑）：\n　\n  Thread 1 時間軸：\n  ──────────────────────────────────────────────────────────────────────────►\n  [正常執行] ──► [lock()] ──► [臨界區工作] ──► [unlock()] ──► [正常執行]\n                  │                                 │
n2=&gt;operation:                   │ 成功獲取鎖（快路徑，             │ 釋放鎖\n                  │ futex 不陷入核心）                    │\n                  ▼                              ▼\n            進入臨界區                      喚醒等待佇列中的 Thread 2\n　\n  Thread 2 時間軸（競爭失敗的情況）：
n3=&gt;operation:   ──────────────────────────────────────────────────────────────────────────►\n  [正常執行] ──► [lock()] ──► ░░░░░░░░░░░░░░░░░░░░░░ ──► [臨界區工作] ──►\n                  │           ▲                  ▲\n                  │    阻塞等待（OS 掛起 Thread 2）│ 被喚醒，重新競爭\n                  ▼                              │\n          ┌──────────────────┐                  │
n4=&gt;operation:           │  OS 核心層         │                     │\n          │                  │                    │\n          │  futex 系統呼叫   │                       │\n          │  Thread2 進入     │                     │\n          │  等待佇列（睡眠）  │──────────────────┘\n          │                  │    Thread1 unlock() 後
n5=&gt;operation:           └──────────────────┘    OS 喚醒 Thread2\n　\n  鎖的兩個路徑：\n　\n  快路徑（Fast Path）—— 無競爭：\n  lock() ──► CAS 操作成功 ──► 進入臨界區         （不需要 syscall，最快）
n6=&gt;operation: 　\n  慢路徑（Slow Path）—— 有競爭：\n  lock() ──► CAS 失敗 ──► futex_wait（陷入核心）\n           ──► 睡眠等待 ──► 被 unlock 方的 futex_wake 喚醒\n           ──► 重新嘗試 CAS ──► 進入臨界區\n　
n7=&gt;operation:   ⚠ 每次 syscall（陷入核心）大約耗時 1000~5000 ns\n  ⚠ 高競爭下鎖的開銷可能超過臨界區本身的工作量
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>鎖把臨界區包起來，保證同時只有一個執行緒改共享資料。</p>
<h2 id="54-cas"><a class="header" href="#54-cas">5.4 CAS</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-18"><a class="header" href="#本小節示意圖-18">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: CAS（Compare-And-Swap）完整流程：\n　\n  呼叫：CAS(addr, expected=10, new=11)\n　\n  ┌─────────────────────────────────────────────────────────────────────────────┐\n  │                                                                             │
n2=&gt;operation:   │  ① Load old value                                                           │\n  │     old = *addr   → old = 10                                                │\n  │                          │                                                  │\n  │  ② Compare                                                                  │\n  │     old == expected?  10 == 10 ?                                            │\n  │                          │                                                  │
n3=&gt;operation:   │              ┌───────────┴───────────┐                                      │\n  │              │ YES（匹配）            │ NO（不匹配）                                 │\n  │              ▼                       ▼                                      │\n  │  ③a Swap new value      ③b 返回 FAIL                                          │\n  │     *addr = new = 11        呼叫方重試                                           │\n  │     返回 SUCCESS              │                                               │
n4=&gt;operation:   │              │                    │                                         │\n  │              └───────────┬───┘                                              │\n  │                          ▼                                                  │\n  │                   整個步驟由 CPU 原子執行                                            │\n  │                   其他 CPU 看不到中間狀態                                            │\n  └─────────────────────────────────────────────────────────────────────────────┘
n5=&gt;operation: 　\n  CAS 自旋重試模式（無鎖計數器的典型用法）：\n　\n  ┌─────────────────────────────────────────────────────────────────────────────┐\n  │  loop {                                                                     │\n  │      old = atomic_load(counter)   ← 讀取當前值                                   │
n6=&gt;operation:   │                                                                             │\n  │      new = old + 1                ← 計算期望新值                                  │\n  │                                                                             │\n  │      if CAS(counter, old, new) {  ← 原子地「確認沒人改過再寫入」                          │\n  │          break                    ← 成功，退出                                   │\n  │      }                                                                      │
n7=&gt;operation:   │      // 失敗：說明 counter 已被其他執行緒改變，重新讀取再試                                      │\n  │  }                                                                          │\n  └─────────────────────────────────────────────────────────────────────────────┘\n　\n  ABA 問題（CAS 的已知陷阱）：\n　
n8=&gt;operation:   時間  執行緒 T1              執行緒 T2\n  ──── ────────────────────── ──────────────────────────────────────\n   t1  load: old = A\n   t2                         CAS(A → B) 成功，值改為 B\n   t3                         CAS(B → A) 成功，值又改回 A\n   t4  CAS(A → C) 成功！      ← T1 誤以為沒人動過，但其實發生了 A→B→A
n9=&gt;operation: 　\n  解法：使用帶版本號的 CAS（如 Java AtomicStampedReference）\n  CAS(addr, (expected_val, expected_stamp), (new_val, new_stamp + 1))
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>先比對舊值，符合才寫入新值，不符合就重試。</p>
<h2 id="示意圖-4"><a class="header" href="#示意圖-4">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: CAS 成功/失敗對比：\n　\n  初始：counter = 10\n　\n  情況 A（CAS 成功）：\n  T1: load=10 → CAS(addr, expect=10, new=11) → 10==10 → swap → counter=11 ✓
n2=&gt;operation: 　\n  情況 B（CAS 失敗，觸發重試）：\n  T1: load=10 → [T2 搶先改成 11] → CAS(addr, expect=10, new=11) → 10≠11 → FAIL\n  T1: load=11 → CAS(addr, expect=11, new=12) → 11==11 → swap → counter=12 ✓
st-&gt;n1
n1-&gt;n2
</code></pre>
<h2 id="跨語言完整範例-4"><a class="header" href="#跨語言完整範例-4">跨語言完整範例</a></h2>
<p>CAS 自旋計數器（多執行緒安全遞增，無鎖實作）。</p>
<h3 id="cgcc-atomic--cas-自旋"><a class="header" href="#cgcc-atomic--cas-自旋">C（GCC atomic + CAS 自旋）</a></h3>
<pre><code class="language-c">#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define ITER    100000

atomic_long counter = 0;

long cas_increment(atomic_long *c) {
    long old, new_val;
    do {
        old = atomic_load_explicit(c, memory_order_relaxed);
        new_val = old + 1;
    } while (!atomic_compare_exchange_weak_explicit(
                 c, &amp;old, new_val,
                 memory_order_release,
                 memory_order_relaxed));
    return new_val;
}

void *worker(void *arg) {
    for (int i = 0; i &lt; ITER; i++)
        cas_increment(&amp;counter);
    return NULL;
}

int main(void) {
    pthread_t tid[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tid[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tid[i], NULL);
    printf("counter = %ld (expected %d)\n", counter, THREADS * ITER);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -std=c11 -O2 -o cas_counter cas_counter.c -lpthread &amp;&amp; ./cas_counter
</code></pre>
<h3 id="cstdatomic-compare_exchange_weak"><a class="header" href="#cstdatomic-compare_exchange_weak">C++（std::atomic compare_exchange_weak）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;vector&gt;

const int THREADS = 4, ITER = 100000;
std::atomic&lt;long&gt; counter{0};

void cas_increment(std::atomic&lt;long&gt; &amp;c) {
    long old_val = c.load(std::memory_order_relaxed);
    while (!c.compare_exchange_weak(
               old_val, old_val + 1,
               std::memory_order_release,
               std::memory_order_relaxed))
        ;   // old_val 自動被更新為最新值，繼續重試
}

void worker() {
    for (int i = 0; i &lt; ITER; i++)
        cas_increment(counter);
}

int main() {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) ts.emplace_back(worker);
    for (auto &amp;t : ts) t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * ITER &lt;&lt; ")\n";
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -O2 -o cas_counter cas_counter.cpp -lpthread &amp;&amp; ./cas_counter
</code></pre>
<h3 id="rustatomici64--compare_exchange"><a class="header" href="#rustatomici64--compare_exchange">Rust（AtomicI64 + compare_exchange）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::Arc;
use std::sync::atomic::{AtomicI64, Ordering};
use std::thread;

const THREADS: usize = 4;
const ITER: i64 = 100_000;

fn cas_increment(counter: &amp;AtomicI64) {
    loop {
        let old = counter.load(Ordering::Relaxed);
        match counter.compare_exchange_weak(
            old, old + 1,
            Ordering::Release,
            Ordering::Relaxed,
        ) {
            Ok(_) =&gt; break,
            Err(_) =&gt; continue,   // 失敗，重試（old 已自動更新）
        }
    }
}

fn main() {
    let counter = Arc::new(AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..THREADS {
        let c = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..ITER { cas_increment(&amp;c); }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})", counter.load(Ordering::SeqCst), THREADS as i64 * ITER);
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gosyncatomic-compareandswap"><a class="header" href="#gosyncatomic-compareandswap">Go（sync/atomic CompareAndSwap）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

const threads, iter = 4, 100_000

func casIncrement(counter *int64) {
    for {
        old := atomic.LoadInt64(counter)
        if atomic.CompareAndSwapInt64(counter, old, old+1) {
            break   // 成功
        }
        // 失敗：counter 已被其他 goroutine 改變，重試
    }
}

func main() {
    var counter int64
    var wg sync.WaitGroup
    wg.Add(threads)
    for i := 0; i &lt; threads; i++ {
        go func() {
            defer wg.Done()
            for j := 0; j &lt; iter; j++ {
                casIncrement(&amp;counter)
            }
        }()
    }
    wg.Wait()
    fmt.Printf("counter = %d (expected %d)\n", counter, threads*iter)
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="python模擬-casthreadinglock-實作"><a class="header" href="#python模擬-casthreadinglock-實作">Python（模擬 CAS，threading.Lock 實作）</a></h3>
<pre><code class="language-python">import threading

class AtomicInt:
    """模擬 CAS 語意的原子整數（Python 無原生 CAS，用鎖模擬語意）"""
    def __init__(self, value: int = 0):
        self._value = value
        self._lock = threading.Lock()

    def compare_and_swap(self, expected: int, new: int) -&gt; bool:
        with self._lock:
            if self._value == expected:
                self._value = new
                return True
            return False

    def load(self) -&gt; int:
        with self._lock:
            return self._value

def cas_increment(counter: AtomicInt):
    while True:
        old = counter.load()
        if counter.compare_and_swap(old, old + 1):
            break

THREADS, ITER = 4, 100_000
counter = AtomicInt(0)

def worker():
    for _ in range(ITER):
        cas_increment(counter)

if __name__ == "__main__":
    threads = [threading.Thread(target=worker) for _ in range(THREADS)]
    for t in threads: t.start()
    for t in threads: t.join()
    print(f"counter = {counter.load()} (expected {THREADS * ITER})")
</code></pre>
<pre><code class="language-bash">python3 cas_counter.py
</code></pre>
<h2 id="完整專案級範例python-4"><a class="header" href="#完整專案級範例python-4">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch05.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch05.py
</code></pre>
<pre><code class="language-python">"""Chapter 05: atomicity with CAS-like primitive.

展示：
1. CAS（Compare-And-Swap）的語意：比對舊值，符合才寫入新值
2. 多執行緒安全遞增（無鎖計數器模擬）
3. CAS 失敗時重試機制
"""
import threading


class AtomicInt:
    def __init__(self, value: int = 0):
        self._v = value
        self._m = threading.Lock()

    def compare_and_swap(self, expect: int, new: int) -&gt; bool:
        with self._m:
            if self._v == expect:
                self._v = new
                return True
            return False

    def get(self) -&gt; int:
        with self._m:
            return self._v


def cas_increment(a: AtomicInt):
    """CAS 自旋重試直到成功。"""
    while True:
        old = a.get()
        if a.compare_and_swap(old, old + 1):
            break


if __name__ == "__main__":
    a = AtomicInt(10)
    print("cas 10-&gt;11", a.compare_and_swap(10, 11), "now", a.get())
    print("cas 10-&gt;12", a.compare_and_swap(10, 12), "now", a.get())  # 失敗，值已是 11

    # 多執行緒 CAS 計數器
    counter = AtomicInt(0)
    THREADS, ITER = 4, 10000
    ts = [threading.Thread(target=lambda: [cas_increment(counter) for _ in range(ITER)])
          for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"final counter = {counter.get()} (expected {THREADS * ITER})")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第6章-可見性與有序性底層"><a class="header" href="#第6章-可見性與有序性底層">第6章 可見性與有序性底層</a></h1>
<h2 id="61-多級快取對應-611613"><a class="header" href="#61-多級快取對應-611613">6.1 多級快取（對應 6.1.1~6.1.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-19"><a class="header" href="#本小節示意圖-19">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   多核 CPU 多級快取延遲金字塔\n  ════════════════════════════════════════════════════════\n　\n           ┌───────────────────────────────────────────┐\n           │           CPU Die                         │\n           │                                           │
n2=&gt;operation:            │  ┌──────────┐    ┌──────────┐             │\n           │  │  Core 0  │    │  Core 1  │             │\n           │  │          │    │          │             │\n           │  │ ┌──────┐ │    │ ┌──────┐ │             │\n           │  │ │  L1  │ │    │ │  L1  │ │             │\n           │  │ │32-64K│ │    │ │32-64K│ │             │
n3=&gt;operation:            │  │ │~4 cy │ │    │ │~4 cy │ │             │\n           │  │ └──┬───┘ │    │ └──┬───┘ │             │\n           │  │   │     │    │    │     │              │\n           │  │ ┌──▼───┐ │    │ ┌──▼───┐ │             │\n           │  │ │  L2  │ │    │ │  L2  │ │             │\n           │  │ │256K  │ │    │ │256K  │ │             │
n4=&gt;operation:            │  │ │~12 cy│ │    │ │~12 cy│ │             │\n           │  │ └──┬───┘ │    │ └──┬───┘ │             │\n           │  └────┼─────┘    └────┼─────┘             │\n           │            │               │              │\n           │       └───────┬───────┘                   │\n           │            ┌──▼───┐                       │
n5=&gt;operation:            │            │  L3      │  共享快取             │\n           │            │ 8-32M    │                   │\n           │            │~40 cy    │                   │\n           │            └──┬───┘                       │\n           └───────────────┼───────────────────────────┘\n                           │
n6=&gt;operation:                         ┌──▼───────┐\n                        │   RAM    │  主記憶體\n                        │  GB 級    │\n                        │ ~200 cy  │\n                        └──┬───────┘\n                           │
n7=&gt;operation:                         ┌──▼───────┐\n                        │   磁碟   │  持久儲存\n                        │  TB 級    │\n                        │~10M cy   │\n                        └──────────┘\n　
n8=&gt;operation:   存取延遲對比（越往下越慢）：\n  ┌──────────────┬──────────────┬────────────────────────────────┐\n  │ 快取層級         │ 存取延遲         │ 說明                             │\n  ├──────────────┼──────────────┼────────────────────────────────┤\n  │ L1 Cache     │    ~4 cycles │ 每核私有，最快                        │\n  │ L2 Cache     │   ~12 cycles │ 每核私有，較大                        │
n9=&gt;operation:   │ L3 Cache     │   ~40 cycles │ 多核共享                           │\n  │ RAM          │  ~200 cycles │ 通過記憶體匯流排存取                     │\n  │ SSD          │  ~100K cycles│ NVMe 介面                        │\n  │ HDD/磁碟       │  ~10M cycles │ 機械旋轉延遲                         │\n  └──────────────┴──────────────┴────────────────────────────────┘\n　
n10=&gt;operation:   ⚠ 重點：Core0 修改的資料在 L1/L2 中，Core1 可能看到舊值\n           必須靠快取一致性協議保證多副本同步
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<p>L1/L2/L3 讓 CPU 讀寫更快，但也帶來多副本一致性問題。</p>
<h2 id="62-快取一致性對應-621625"><a class="header" href="#62-快取一致性對應-621625">6.2 快取一致性（對應 6.2.1~6.2.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-20"><a class="header" href="#本小節示意圖-20">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   MESI 協議四狀態轉換圖\n  ════════════════════════════════════════════════════════\n　\n  狀態定義：\n  ┌─────────────┬─────────────────────────────────────────────┐\n  │ M (Modified)│ 本核修改過，其他核無副本，與 RAM 不同                       │
n2=&gt;operation:   │ E (Exclusive)│ 本核獨有，與 RAM 相同，無其他副本                        │\n  │ S (Shared)  │ 多核共有，與 RAM 相同                               │\n  │ I (Invalid) │ 快取行無效，需重新從其他核/RAM 取                         │\n  └─────────────┴─────────────────────────────────────────────┘\n　\n  狀態機轉換：
n3=&gt;operation:                       ┌─────────────────┐\n              本核讀命中 ◄─┤  E (Exclusive)  ├─► 本核寫命中\n              不需總線操作  └────────┬────────┘   M (Modified)\n                                    │\n                          其他核讀（Bus Read）\n                                    │ 降級共享
n4=&gt;operation:                                     ▼\n  ┌──────────────┐         ┌──────────────────────────────────┐\n  │ M (Modified) │         │  S (Shared)                      │\n  │              │◄────────│                                  │\n  │ 本核寫：不需       │  本核寫    │ 多核可同時持有                          │\n  │ 總線操作         │  發送     │ 只能讀，不能寫                          │
n5=&gt;operation:   └──────┬───────┘ Invalidate└───────┬────────────────────────┘\n         │        給其他核           │\n         │ 其他核讀時                 │ 所有核清除或被替換\n         │ 回寫 RAM + 降為 S         │\n         ▼                           ▼\n  ┌───────────────────────────────────────────────────────────┐
n6=&gt;operation:   │              I (Invalid)                                  │\n  │         快取行無效，需要重新載入                                      │\n  └───────────────────────────────────────────────────────────┘\n　\n  Core0 寫入流程（從 S → M，令 Core1 失效）：\n  ┌───────────────────────────────────────────────────────────┐
n7=&gt;operation:   │  時間                                                       │\n  │   │                                                       │\n  │   │  1. Core0 和 Core1 都持有 x=10（S 狀態）                      │\n  │   │     Core0 L1: [x=10, S]   Core1 L1: [x=10, S]         │\n  │   │                                                       │\n  │   │  2. Core0 寫入 x=20                                     │
n8=&gt;operation:   │   │     Core0 發送 BusUpgr（Invalidate）給 Core1               │\n  │   │     ─────────────────────────────────────────►        │\n  │   │     Core1 L1: [x=10, I]  ← 標記無效                       │\n  │   │     Core0 L1: [x=20, M]  ← 獨占修改                       │\n  │   │                                                       │\n  │   │  3. Core1 之後讀 x                                       │
n9=&gt;operation:   │   │     發現是 I（Invalid），發出 BusMiss                         │\n  │   │     Core0 攔截，回寫 x=20 到 RAM                            │\n  │   │     Core1 從 RAM 讀 x=20（S 狀態）                          │\n  │   ▼                                                       │\n  └───────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>MESI 等協議保證核心間最終一致。</p>
<h2 id="63-偽共享對應-631633"><a class="header" href="#63-偽共享對應-631633">6.3 偽共享（對應 6.3.1~6.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-21"><a class="header" href="#本小節示意圖-21">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   偽共享（False Sharing）問題示意\n  ════════════════════════════════════════════════════════\n　\n  問題：x 和 y 落在同一個 64-byte 快取行\n　\n  記憶體布局：
n2=&gt;operation:   ┌─────────────────────────────────────────────────────┐\n  │              64-byte Cache Line                     │\n  │  ┌──────────┬──────────┬──────────────────────┐     │\n  │  │  x (8B)  │  y (8B)  │   padding...  (48B)  │     │\n  │  │  addr 0  │  addr 8  │   addr 16~63         │     │\n  │  └──────────┴──────────┴──────────────────────┘     │
n3=&gt;operation:   └─────────────────────────────────────────────────────┘\n        ↑                ↑\n    Core0 寫 x       Core1 寫 y\n　\n  結果（每次寫都會使對方快取行失效）：\n  ┌─────────────────────────────────────────────────────┐
n4=&gt;operation:   │  Core0 寫 x=1                                        │\n  │    → 整條 64B Cache Line 變 M 狀態                       │\n  │    → 發 Invalidate 給 Core1                           │\n  │    → Core1 的 y 雖然沒動，快取行也失效！                         │\n  │                                                     │\n  │  Core1 要讀/寫 y                                       │
n5=&gt;operation:   │    → Cache Miss（因為被 Core0 的寫 x 連帶失效）                │\n  │    → 必須等 Core0 回寫，再從 RAM 重新載入                       │\n  │    → 效能劇烈下降（可能慢 10~100 倍）                           │\n  └─────────────────────────────────────────────────────┘\n　\n  解法 1：填充（Padding）讓 x 和 y 各占獨立快取行
n6=&gt;operation:   ┌─────────────────────────────────────────────────────┐\n  │   Cache Line 0 (64B)    │   Cache Line 1 (64B)      │\n  │  ┌──────┬─────────────┐ │ ┌──────┬─────────────┐    │\n  │  │  x   │ padding 56B │ │ │  y   │ padding 56B │    │\n  │  └──────┴─────────────┘ │ └──────┴─────────────┘    │\n  │       Core0 操作         │      Core1 操作              │
n7=&gt;operation:   └─────────────────────────────────────────────────────┘\n  Core0 修改 x → 只影響 Cache Line 0，不影響 Core1\n　\n  解法 2：編譯器對齊屬性\n  C：    __attribute__((aligned(64))) int x;\n  C++：  alignas(64) int x;
n8=&gt;operation:   Rust： #[repr(align(64))] struct PaddedCell { val: i64 }\n  Go：   使用 atomic + 手動補位元組到 64B
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>不同變數落在同一 cache line，互相拖慢。</p>
<h2 id="64-volatile-類語義對應-641643"><a class="header" href="#64-volatile-類語義對應-641643">6.4 volatile 類語義（對應 6.4.1~6.4.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-22"><a class="header" href="#本小節示意圖-22">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   volatile 可見性語義：寫前 StoreStore + 讀後 LoadLoad\n  ════════════════════════════════════════════════════════\n　\n  Thread 1 (Writer)                Thread 2 (Reader)\n  ──────────────────               ─────────────────────\n  write data = 42          │       read result = flag
n2=&gt;operation:                            │\n  ┌─ StoreStore Fence ──┐  │       ┌─ LoadLoad Fence ────┐\n  │  確保 data 寫入先    │  │       │  確保 flag 讀出後            │\n  │  於 flag 寫入可見    │  │       │  才讀 data                │\n  └─────────────────────┘  │       └─────────────────────┘\n           │               │                │
n3=&gt;operation:            ▼               │                ▼\n  write flag = true        │       if flag == true:\n  （volatile write）       │           use data  ← 保證看到 42\n           │                                │\n           └──── 可見性保證（flush store buffer）──────►\n　
n4=&gt;operation:   volatile 的保證與限制：\n  ┌──────────────────────────────────────────────────────┐\n  │  ✅ 保證：每次讀都從主記憶體/快取一致視圖讀取                             │\n  │  ✅ 保證：每次寫都立即刷新到主記憶體                                  │\n  │  ✅ 保證：寫操作對其他執行緒可見（happens-before）                    │\n  │                                                      │
n5=&gt;operation:   │  ❌ 不保證：複合操作原子性                                       │\n  │     volatile int v = 0;                              │\n  │     v++;  // 等同 v = v + 1，read-modify-write          │\n  │            // 兩個執行緒各自讀 0，都寫 1 → 遺失更新                 │\n  └──────────────────────────────────────────────────────┘\n　
n6=&gt;operation:   四種語言的 volatile 對應：\n  ┌──────────┬───────────────────────────────────────────┐\n  │ 語言     │ volatile / 可見性 API                          │\n  ├──────────┼───────────────────────────────────────────┤\n  │ C/C++    │ volatile（只阻止編譯器重排，非執行緒安全）                 │\n  │          │ atomic_store/load（正確做法）                   │
n7=&gt;operation:   │ Rust     │ AtomicXxx::store/load(Ordering)           │\n  │ Go       │ sync/atomic.Store/Load                    │\n  └──────────┴───────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>可見性強，但不保證複合操作原子性。</p>
<h2 id="65-指令重排與屏障對應-651654"><a class="header" href="#65-指令重排與屏障對應-651654">6.5 指令重排與屏障（對應 6.5.1~6.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-23"><a class="header" href="#本小節示意圖-23">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   四種記憶體屏障（Memory Fence）類型\n  ════════════════════════════════════════════════════════\n　\n  屏障阻止跨越屏障的重排序（時間從上到下）：\n　\n  ┌─────────────────┬────────────────────────────────────────┐
n2=&gt;operation:   │  LoadLoad        │  確保屏障前的 Load 先於後面的 Load               │\n  │                  │                                       │\n  │  load A          │  ─────── 屏障上方 ───────                 │\n  │  ── LL Fence ──  │  ══════════════════════════════       │\n  │  load B          │  ─────── 屏障下方 ───────                 │\n  │  保證 A 先於 B   │  A 的結果對下方 Load 可見                         │
n3=&gt;operation:   └─────────────────┴────────────────────────────────────────┘\n　\n  ┌─────────────────┬────────────────────────────────────────┐\n  │  LoadStore       │  確保屏障前的 Load 先於後面的Store               │\n  │                  │                                       │\n  │  load A          │  通常用於避免載入後的寫被提前                       │
n4=&gt;operation:   │  ── LS Fence ──  │                                       │\n  │  store B         │                                       │\n  └─────────────────┴────────────────────────────────────────┘\n　\n  ┌─────────────────┬────────────────────────────────────────┐\n  │  StoreStore      │  確保屏障前的 Store 先於後面Store               │
n5=&gt;operation:   │                  │                                       │\n  │  store A         │  ─────── 屏障上方 ───────                 │\n  │  ── SS Fence ──  │  ══════════════════════════════       │\n  │  store B         │  ─────── 屏障下方 ───────                 │\n  │  保證 A 先寫出   │  A 對其他核的可見先於 B                             │\n  └─────────────────┴────────────────────────────────────────┘
n6=&gt;operation: 　\n  ┌─────────────────┬────────────────────────────────────────┐\n  │  StoreLoad       │  最重的屏障，確保前面 Store 對所有                 │\n  │  （全屏障）      │  核可見後，才執行後面的 Load                          │\n  │                  │                                       │\n  │  store A         │  必須刷新 Store Buffer + 清空               │
n7=&gt;operation:   │  ── SL Fence ──  │  Invalidate Queue                     │\n  │  load B          │  代價最高，x86 用 MFENCE                    │\n  └─────────────────┴────────────────────────────────────────┘\n　\n  Acquire / Release 語義包含的 Fence：\n　
n8=&gt;operation:   Release（寫端）：          Acquire（讀端）：\n  ┌──────────────────┐       ┌───────────────────────────────┐\n  │  普通寫操作           │       │  acquire load                 │\n  │  普通寫操作           │       │                               │\n  │  ─ SS Fence ──   │       │  ─ LL + LS ──                 │\n  │  ─ LS Fence ──   │       │    Fence                      │
n9=&gt;operation:   │  release store   │       │                               │\n  └──────────────────┘       │  普通讀操作       │\n  保證 release 前的寫         └──────────────────┘\n  在 release store 之前可見   保證 acquire 後的讀\n                              在 acquire load 之後
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>Memory Fence 阻止特定方向的重排。</p>
<h2 id="66-記憶體模型對應-661663"><a class="header" href="#66-記憶體模型對應-661663">6.6 記憶體模型（對應 6.6.1~6.6.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-24"><a class="header" href="#本小節示意圖-24">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   各語言記憶體模型與同步 API 對比\n  ════════════════════════════════════════════════════════\n　\n  ┌──────────┬──────────────────┬─────────────────────────────────────────────┐\n  │ 語言       │ 記憶體模型            │ 同步操作 API / 保證                               │\n  ├──────────┼──────────────────┼─────────────────────────────────────────────┤
n2=&gt;operation:   │ C11/C17  │ C11 Memory Model │ atomic_store(relaxed/release/seq_cst)       │\n  │          │ 弱序 + 顯式標注        │ atomic_load(relaxed/acquire/seq_cst)        │\n  │          │                  │ atomic_thread_fence(memory_order_*)         │\n  ├──────────┼──────────────────┼─────────────────────────────────────────────┤\n  │ C++11+   │ C++ Memory Model │ std::atomic&lt;T&gt;::store(memory_order)         │\n  │          │ 與 C11 相近         │ std::atomic&lt;T&gt;::load(memory_order)          │
n3=&gt;operation:   │          │                  │ memory_order_{relaxed,acquire,              │\n  │          │                  │   release,acq_rel,seq_cst}                  │\n  ├──────────┼──────────────────┼─────────────────────────────────────────────┤\n  │ Rust     │ C++ 相容           │ AtomicI32::store(val, Ordering::*)          │\n  │          │ 型別系統強制           │ AtomicI32::load(Ordering::*)                │\n  │          │ 所有權排除競爭          │ Ordering::{Relaxed,Acquire,                 │
n4=&gt;operation:   │          │                  │   Release,AcqRel,SeqCst}                    │\n  ├──────────┼──────────────────┼─────────────────────────────────────────────┤\n  │ Go       │ Go Memory Model  │ sync/atomic.Store/Load                      │\n  │          │ 較簡單，happens-     │ sync.Mutex / sync.RWMutex                   │\n  │          │ before 為主        │ channel send/recv（天然同步點）                    │\n  │          │                  │ 無顯式 memory_order 選擇                         │
n5=&gt;operation:   └──────────┴──────────────────┴─────────────────────────────────────────────┘\n　\n  強弱排序光譜：\n  弱序（性能高，推理難）                    強序（性能低，推理易）\n  ────────────────────────────────────────────────────────►\n  Relaxed        Acquire/Release       SeqCst（全序）
n6=&gt;operation:   （無同步）      （happens-before）    （全局一致順序）\n  僅原子性        producer-consumer     計數器、旗標
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>Java、C++、Rust、Go 都定義了跨執行緒可見性規則。</p>
<h2 id="67-happens-before對應-671679"><a class="header" href="#67-happens-before對應-671679">6.7 happens-before（對應 6.7.1~6.7.9）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-25"><a class="header" href="#本小節示意圖-25">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   happens-before（HB）傳遞鏈示意\n  ════════════════════════════════════════════════════════\n　\n  執行緒 T1                     執行緒 T2\n  ──────────────────            ──────────────────\n  data = 42           ─── HB ──► (HB 傳遞)
n2=&gt;operation:       │ HB（程式順序）           │\n  unlock(L)           ═══ HB ══► lock(L)\n                                 │ HB（程式順序）\n                                read data → 42 ✅\n　\n  HB 鏈推導：
n3=&gt;operation:   ┌───────────────────────────────────────────────────────┐\n  │  data = 42                                            │\n  │      │ HB（T1 程式順序：先寫 data 再 unlock）                   │\n  │      ▼                                                │\n  │  unlock(L)                                            │\n  │      │ HB（同步動作：unlock HB lock 同一把鎖）                   │
n4=&gt;operation:   │      ▼                                                │\n  │  lock(L)   ← T2 獲取同一把鎖                                │\n  │      │ HB（T2 程式順序：先 lock 再讀 data）                     │\n  │      ▼                                                │\n  │  read data → 保證看到 42（HB 具傳遞性）                         │\n  └───────────────────────────────────────────────────────┘
n5=&gt;operation: 　\n  建立 happens-before 的常見同步事件：\n  ┌───────────────────────────────────────────────────────┐\n  │  同步事件                  HB 關係                          │\n  ├───────────────────────────────────────────────────────┤\n  │  unlock(L)           HB    lock(L)（同一鎖）               │
n6=&gt;operation:   │  volatile write      HB    volatile read（後發生）         │\n  │  thread.start()      HB    執行緒內第一個動作                  │\n  │  執行緒最後動作       HB    thread.join() 返回                 │\n  │  channel send        HB    channel recv（Go）           │\n  │  release store       HB    acquire load（C++/Rust）     │\n  └───────────────────────────────────────────────────────┘
n7=&gt;operation: 　\n  HB 具有傳遞性：若 A HB B 且 B HB C，則 A HB C\n  ┌───┐  HB  ┌───┐  HB  ┌─────────────────────────────────┐\n  │ A │─────►│ B │─────►│ C │   則 A HB C\n  └───┘      └───┘      └─────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>能建立 happens-before 的同步事件，才可推導正確性。</p>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: unlock(L) happens-before lock(L)\nwrite(x) in T1 before unlock → T2 lock 後可見
st-&gt;n1
</code></pre>
<h2 id="示意圖-5"><a class="header" href="#示意圖-5">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Core0 write → StoreBuffer → L1 → L2/L3 → Core1 read\n需要一致性協議 + memory order 才能正確觀察
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-5"><a class="header" href="#跨語言完整範例-5">跨語言完整範例</a></h2>
<p>主題：release-acquire 語義傳遞數據（producer 設 data 後 release store flag，consumer acquire load flag 後讀 data）</p>
<h3 id="cc11-atomics"><a class="header" href="#cc11-atomics">C（C11 atomics）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch06_c ch06.c
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

static int data = 0;
static atomic_int flag = ATOMIC_VAR_INIT(0);

void *producer(void *arg) {
    data = 42;                                          // 普通寫
    atomic_store_explicit(&amp;flag, 1, memory_order_release); // release
    return NULL;
}

void *consumer(void *arg) {
    int f;
    while ((f = atomic_load_explicit(&amp;flag, memory_order_acquire)) == 0)
        ;                                               // spin acquire
    printf("consumer: data = %d (expected 42)\n", data);
    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, consumer, NULL);
    pthread_create(&amp;t2, NULL, producer, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
</code></pre>
<h3 id="cstdatomic-releaseacquire"><a class="header" href="#cstdatomic-releaseacquire">C++（std::atomic release/acquire）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch06_cpp ch06.cpp
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

static int data = 0;
static std::atomic&lt;int&gt; flag{0};

void producer() {
    data = 42;                                          // 普通寫
    flag.store(1, std::memory_order_release);           // release store
}

void consumer() {
    while (flag.load(std::memory_order_acquire) == 0)  // acquire load
        ;                                               // spin
    std::cout &lt;&lt; "consumer: data = " &lt;&lt; data
              &lt;&lt; " (expected 42)\n";
}

int main() {
    std::thread t1(consumer);
    std::thread t2(producer);
    t1.join();
    t2.join();
}
</code></pre>
<h3 id="rustatomic-releaseacquire"><a class="header" href="#rustatomic-releaseacquire">Rust（Atomic release/acquire）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch06.rs &amp;&amp; ./ch06
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(AtomicI32::new(0));
    let flag = Arc::new(AtomicI32::new(0));

    let (d2, f2) = (Arc::clone(&amp;data), Arc::clone(&amp;flag));
    let producer = thread::spawn(move || {
        d2.store(42, Ordering::Relaxed);               // 普通原子寫
        f2.store(1, Ordering::Release);                // release store
    });

    let (d1, f1) = (Arc::clone(&amp;data), Arc::clone(&amp;flag));
    let consumer = thread::spawn(move || {
        while f1.load(Ordering::Acquire) == 0 {}       // acquire load spin
        println!("consumer: data = {} (expected 42)",
                 d1.load(Ordering::Relaxed));
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}</code></pre></pre>
<h3 id="gosyncatomic--channel-同步"><a class="header" href="#gosyncatomic--channel-同步">Go（sync/atomic + channel 同步）</a></h3>
<pre><code class="language-go">// 執行：go run ch06.go
package main

import (
	"fmt"
	"sync/atomic"
)

var data int64
var flag atomic.Int32

func main() {
	done := make(chan struct{})

	go func() { // consumer
		for flag.Load() == 0 { // acquire-like（Go atomic 隱含 seq_cst）
		}
		val := atomic.LoadInt64(&amp;data)
		fmt.Printf("consumer: data = %d (expected 42)\n", val)
		close(done)
	}()

	go func() { // producer
		atomic.StoreInt64(&amp;data, 42)
		flag.Store(1) // release-like
	}()

	&lt;-done
}
</code></pre>
<h3 id="pythonthreadingcondition-模擬-releaseacquire"><a class="header" href="#pythonthreadingcondition-模擬-releaseacquire">Python（threading.Condition 模擬 release/acquire）</a></h3>
<pre><code class="language-python"># 執行：python3 ch06.py
import threading

data = 0
flag = False
cv = threading.Condition()

def producer():
    global data, flag
    with cv:
        data = 42       # 設定 payload
        flag = True     # release：通知 consumer
        cv.notify_all()

def consumer():
    with cv:
        while not flag: # acquire：等待 flag
            cv.wait()
        print(f"consumer: data = {data} (expected 42)")

if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start()
    t1.join(); t2.join()
</code></pre>
<h2 id="完整專案級範例python-5"><a class="header" href="#完整專案級範例python-5">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch06.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch06.py
</code></pre>
<pre><code class="language-python">"""Chapter 06: ordering with condition variable."""
import threading

cv = threading.Condition()
ready = False
payload = 0


def producer():
    global ready, payload
    with cv:
        payload = 99
        ready = True
        cv.notify_all()


def consumer():
    with cv:
        while not ready:
            cv.wait()
        print("payload=", payload)


if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start(); t1.join(); t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第7章-synchronized-與-jvm-鎖實作"><a class="header" href="#第7章-synchronized-與-jvm-鎖實作">第7章 synchronized 與 JVM 鎖實作</a></h1>
<h2 id="71-語法層對應-711713"><a class="header" href="#71-語法層對應-711713">7.1 語法層（對應 7.1.1~7.1.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-26"><a class="header" href="#本小節示意圖-26">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   synchronized 三種語法形式與 bytecode 對應\n  ════════════════════════════════════════════════════════\n　\n  形式 1：實例方法（鎖 this）\n  ┌────────────────────────────────────────────────────────┐\n  │  Java 源碼                                               │
n2=&gt;operation:   │  synchronized void increment() { count++; }            │\n  │                                                        │\n  │  bytecode（ACC_SYNCHRONIZED flag）                       │\n  │  方法描述符帶有 ACC_SYNCHRONIZED                              │\n  │  JVM 執行前自動 monitorenter(this)                          │\n  │  JVM 執行後自動 monitorexit(this)                           │
n3=&gt;operation:   │                                                        │\n  │  鎖對象：this（呼叫此方法的實例）                                    │\n  └────────────────────────────────────────────────────────┘\n　\n  形式 2：靜態方法（鎖 Class 對象）\n  ┌────────────────────────────────────────────────────────┐
n4=&gt;operation:   │  Java 源碼                                               │\n  │  static synchronized void reset() { count = 0; }       │\n  │                                                        │\n  │  bytecode（ACC_STATIC + ACC_SYNCHRONIZED）               │\n  │  JVM 執行前 monitorenter(Counter.class)                   │\n  │  JVM 執行後 monitorexit(Counter.class)                    │
n5=&gt;operation:   │                                                        │\n  │  鎖對象：Counter.class（JVM 中 Class 對象）                     │\n  │  ⚠ 與實例鎖不同，互不衝突                                         │\n  └────────────────────────────────────────────────────────┘\n　\n  形式 3：程式區塊（鎖指定對象）
n6=&gt;operation:   ┌────────────────────────────────────────────────────────┐\n  │  Java 源碼                                               │\n  │  synchronized (lockObj) {                              │\n  │      // critical section                               │\n  │  }                                                     │\n  │                                                        │
n7=&gt;operation:   │  bytecode（顯式指令）                                        │\n  │  0: aload lockObj    ← 將鎖對象壓棧                          │\n  │  1: monitorenter     ← 嘗試獲取 monitor                    │\n  │  2: ... body ...                                       │\n  │  3: monitorexit      ← 正常退出釋放                          │\n  │  4: (exception path) │                                 │
n8=&gt;operation:   │  5: monitorexit      ← 異常退出也釋放（finally）                │\n  │                                                        │\n  │  鎖對象：lockObj（任意 Object）                                │\n  └────────────────────────────────────────────────────────┘\n　\n  三種形式對比：
n9=&gt;operation:   ┌─────────────────┬────────────────┬─────────────────────┐\n  │ 形式             │ 鎖對象          │ 適用場景                   │\n  ├─────────────────┼────────────────┼─────────────────────┤\n  │ 實例方法           │ this           │ 保護實例狀態               │\n  │ 靜態方法           │ ClassName.class│ 保護靜態狀態               │\n  │ synchronized 塊 │ 指定 Object    │ 精細控制臨界區                │
n10=&gt;operation:   └─────────────────┴────────────────┴─────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<ul>
<li>實例方法鎖 <code>this</code></li>
<li>類方法鎖 <code>Class</code></li>
<li>程式區塊鎖指定對象</li>
</ul>
<h2 id="7273-物件頭與鎖標記對應-721733"><a class="header" href="#7273-物件頭與鎖標記對應-721733">7.2~7.3 物件頭與鎖標記（對應 7.2.1~7.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-27"><a class="header" href="#本小節示意圖-27">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   64-bit JVM 物件頭（Mark Word）布局\n  ════════════════════════════════════════════════════════\n　\n  Mark Word（64 bit = 8 bytes）在不同鎖狀態下的含義：\n　\n  無鎖狀態（biasable）：
n2=&gt;operation:   ┌──────────────────────────┬──────┬─────┬──┬────────────────────┐\n  │  hashcode (31b) / unused         │ age  │  0  │0 │1           │\n  │  bit 63 ─────────── 7            │ 4b   │ 1b  │1b│1b          │\n  └──────────────────────────┴──────┴─────┴──┴────────────────────┘\n                                               └─ lock bits = 01\n　
n3=&gt;operation:   偏向鎖（Biased Lock）：\n  ┌───────────────────────────────────┬──────┬──┬──┬──────────────┐\n  │  Thread ID (54b)  │ epoch (2b)    │ age  │1 │0 │1             │\n  │  bit 63 ──────────────────── 10  │  4b  │1b│1b│1b             │\n  └───────────────────────────────────┴──────┴──┴──┴──────────────┘\n                                                   └─ lock bits = 01, biased=1
n4=&gt;operation: 　\n  輕量鎖（Lightweight Lock，CAS 競爭）：\n  ┌────────────────────────────────────────────────┬──┬───────────┐\n  │  Lock Record 指針（ptr to stack frame）(62b)       │0 │0          │\n  │  bit 63 ──────────────────────────────────── 2 │1b│1b         │\n  └────────────────────────────────────────────────┴──┴───────────┘
n5=&gt;operation:                                                        └─ lock bits = 00\n　\n  重量鎖（Heavyweight Lock，OS mutex）：\n  ┌────────────────────────────────────────────────┬──┬───────────┐\n  │  Monitor 物件指針（ptr to ObjectMonitor）(62b)       │1 │0          │\n  │  bit 63 ──────────────────────────────────── 2 │1b│1b         │
n6=&gt;operation:   └────────────────────────────────────────────────┴──┴───────────┘\n                                                       └─ lock bits = 10\n　\n  GC 標記（Marked for GC）：\n  ┌────────────────────────────────────────────────┬──┬───────────┐\n  │  forwarding pointer                            │1 │1          │
n7=&gt;operation:   └────────────────────────────────────────────────┴──┴───────────┘\n                                                       └─ lock bits = 11\n　\n  lock bits 速查表：\n  ┌───────────┬───────────────────────────────────────────────────┐\n  │ lock bits │ 含義                                                │
n8=&gt;operation:   ├───────────┼───────────────────────────────────────────────────┤\n  │    01     │ 無鎖（biasable=0）或 偏向鎖（biased=1）                     │\n  │    00     │ 輕量鎖（CAS LockRecord 指針）                            │\n  │    10     │ 重量鎖（Monitor 物件指針）                                 │\n  │    11     │ GC 標記中                                            │\n  └───────────┴───────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>這是 JVM 實作細節：物件頭記錄鎖狀態。</p>
<h2 id="7475-monitor-與-bytecode對應-741754"><a class="header" href="#7475-monitor-與-bytecode對應-741754">7.4~7.5 Monitor 與 bytecode（對應 7.4.1~7.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-28"><a class="header" href="#本小節示意圖-28">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   ObjectMonitor 結構與 monitorenter/exit 流程\n  ════════════════════════════════════════════════════════\n　\n  ObjectMonitor 內部結構：\n  ┌─────────────────────────────────────────────────────────────────┐\n  │                ObjectMonitor                                    │
n2=&gt;operation:   │                                                                 │\n  │  ┌─────────────────────────────────────────────┐                │\n  │  │  owner: Thread*    ← 當前持有鎖的執行緒              │                │\n  │  │  recursions: int   ← 重入計數器                  │                │\n  │  └─────────────────────────────────────────────┘                │\n  │                                                                 │
n3=&gt;operation:   │  ┌─────────────────────────────────────────────┐                │\n  │  │  EntryList: LinkedList&lt;Thread&gt;              │                │\n  │  │  （等待獲取鎖的執行緒佇列）                              │                │\n  │  │  T2 ──► T3 ──► T4                           │                │\n  │  └─────────────────────────────────────────────┘                │\n  │                                                                 │
n4=&gt;operation:   │  ┌─────────────────────────────────────────────┐                │\n  │  │  WaitSet: LinkedList&lt;Thread&gt;                │                │\n  │  │  （呼叫 wait() 後進入的執行緒集合）                      │                │\n  │  │  T5 ──► T6                                  │                │\n  │  └─────────────────────────────────────────────┘                │\n  └─────────────────────────────────────────────────────────────────┘
n5=&gt;operation: 　\n  monitorenter 流程：\n  ┌─────────────────────────────────────────────────────────────────┐\n  │  執行緒嘗試 monitorenter                                             │\n  │       │                                                         │\n  │       ▼                                                         │
n6=&gt;operation:   │  owner == null ?                                                │\n  │  ├─ 是 ──► CAS 設定 owner = 自己 ──► 成功，進入                           │\n  │  │                                                              │\n  │  └─ 否 ──► owner == 自己（重入）?                                      │\n  │            ├─ 是 ──► recursions++ ──► 進入                         │\n  │            │                                                    │
n7=&gt;operation:   │            └─ 否 ──► 加入 EntryList                                │\n  │                       park()（OS 睡眠）                             │\n  │                       等待 owner 釋放後被喚醒                           │\n  └─────────────────────────────────────────────────────────────────┘\n　\n  monitorexit 流程：
n8=&gt;operation:   ┌─────────────────────────────────────────────────────────────────┐\n  │  執行緒執行 monitorexit                                              │\n  │       │                                                         │\n  │       ▼                                                         │\n  │  recursions &gt; 0 ?                                               │\n  │  ├─ 是 ──► recursions-- ──► 繼續持有                                 │
n9=&gt;operation:   │  │                                                              │\n  │  └─ 否 ──► owner = null                                          │\n  │            從 EntryList 選一個執行緒 unpark()                          │\n  │            被喚醒的執行緒重新競爭 monitorenter                             │\n  └─────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>進入臨界區會走 <code>monitorenter</code>，離開走 <code>monitorexit</code>。</p>
<h2 id="76710-鎖升級與優化對應-76710"><a class="header" href="#76710-鎖升級與優化對應-76710">7.6~7.10 鎖升級與優化（對應 7.6~7.10）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-29"><a class="header" href="#本小節示意圖-29">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   JVM 鎖升級路徑（只能升級，不可降級）\n  ════════════════════════════════════════════════════════\n　\n  ┌────────────────────────────────────────────────────────────┐\n  │                                                            │\n  │  ┌──────────┐                                              │
n2=&gt;operation:   │  │  無鎖          │ lock bits = 01（biased=0）                 │\n  │  │ Unlocked     │ 首次分配物件，等待首次鎖定                            │\n  │  └────┬─────┘                                              │\n  │       │ 首次被某執行緒獲取（無競爭）                                     │\n  │       ▼ 在 Mark Word 記錄 Thread ID                           │\n  │  ┌──────────────┐                                          │
n3=&gt;operation:   │  │  偏向鎖         │ lock bits = 01（biased=1）                 │\n  │  │ Biased Lock  │ CAS 寫入 Thread ID，後續進入免 CAS               │\n  │  └──────┬───────┘ 優點：單執行緒場景近乎無鎖效能                          │\n  │         │                                                  │\n  │         │ 觸發條件：另一個執行緒嘗試獲取                                  │\n  │         │ → 觸發 STW（Stop-The-World）撤銷偏向鎖                    │
n4=&gt;operation:   │         ▼                                                  │\n  │  ┌──────────────┐                                          │\n  │  │  輕量鎖         │ lock bits = 00                           │\n  │  │ Lightweight  │ 在執行緒棧幀建立 Lock Record                     │\n  │  │    Lock      │ CAS 將 Mark Word 指向 Lock Record           │\n  │  └──────┬───────┘ 優點：避免 OS mutex，自旋等待                      │
n5=&gt;operation:   │         │                                                  │\n  │         │ 觸發條件：CAS 自旋超過閾值（預設 10 次）                         │\n  │         │ 或 等待執行緒數 &gt; 1                                     │\n  │         ▼                                                  │\n  │  ┌──────────────┐                                          │\n  │  │  重量鎖         │ lock bits = 10                           │
n6=&gt;operation:   │  │ Heavyweight  │ Mark Word 指向 ObjectMonitor               │\n  │  │    Lock      │ 使用 OS Mutex（pthread_mutex）               │\n  │  └──────────────┘ 代價最高，但公平，支援 wait/notify                  │\n  │                                                            │\n  │  升級觸發條件總結：                                                 │\n  │  ┌────────────────┬──────────────────────────────┐         │
n7=&gt;operation:   │  │ 無鎖 → 偏向鎖 │ 第一次被任意執行緒獲取        │                         │\n  │  │ 偏向鎖→輕量鎖  │ 第二個執行緒競爭（撤銷偏向）     │                         │\n  │  │ 輕量鎖→重量鎖  │ 自旋 CAS 失敗次數超過閾值    │                         │\n  │  └────────────────┴──────────────────────────────┘         │\n  └────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>偏向鎖 -&gt; 輕量鎖 -&gt; 重量鎖，競爭越激烈成本越高。</p>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 低競爭: fast path\n高競爭: 進入等待佇列 + 喚醒
st-&gt;n1
</code></pre>
<p>跨語言對應：其他語言沒有 <code>synchronized</code> 關鍵字，但 runtime 也有類似 fast/slow path 優化。</p>
<h2 id="示意圖-6"><a class="header" href="#示意圖-6">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: monitor(owner=T1)\nqueue: T2 → T3\nT1 exit monitor → wake T2
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-6"><a class="header" href="#跨語言完整範例-6">跨語言完整範例</a></h2>
<p>主題：mutex 保護共享計數器（4 個執行緒各加 10000 次，驗證最終結果正確）</p>
<h3 id="cpthread_mutex"><a class="header" href="#cpthread_mutex">C（pthread_mutex）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch07_c ch07.c
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define INCREMENTS 10000

static int counter = 0;
static pthread_mutex_t mu = PTHREAD_MUTEX_INITIALIZER;

void *worker(void *arg) {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        pthread_mutex_lock(&amp;mu);
        counter++;
        pthread_mutex_unlock(&amp;mu);
    }
    return NULL;
}

int main(void) {
    pthread_t threads[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;threads[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("counter = %d (expected %d)\n", counter, THREADS * INCREMENTS);
    pthread_mutex_destroy(&amp;mu);
    return 0;
}
</code></pre>
<h3 id="cstdmutex"><a class="header" href="#cstdmutex">C++（std::mutex）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch07_cpp ch07.cpp
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int THREADS = 4;
constexpr int INCREMENTS = 10000;

static int counter = 0;
static std::mutex mu;

void worker() {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        std::scoped_lock lock(mu);
        counter++;
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; THREADS; i++)
        threads.emplace_back(worker);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * INCREMENTS &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rustmutex"><a class="header" href="#rustmutex">Rust（Mutex<i32>）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch07.rs &amp;&amp; ./ch07
use std::sync::{Arc, Mutex};
use std::thread;

const THREADS: usize = 4;
const INCREMENTS: usize = 10_000;

fn main() {
    let counter = Arc::new(Mutex::new(0i32));
    let mut handles = Vec::new();

    for _ in 0..THREADS {
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..INCREMENTS {
                *counter.lock().unwrap() += 1;
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})",
             *counter.lock().unwrap(),
             THREADS * INCREMENTS);
}</code></pre></pre>
<h3 id="gosyncmutex"><a class="header" href="#gosyncmutex">Go（sync.Mutex）</a></h3>
<pre><code class="language-go">// 執行：go run ch07.go
package main

import (
	"fmt"
	"sync"
)

const (
	threads    = 4
	increments = 10000
)

func main() {
	var (
		counter int
		mu      sync.Mutex
		wg      sync.WaitGroup
	)
	for i := 0; i &lt; threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j &lt; increments; j++ {
				mu.Lock()
				counter++
				mu.Unlock()
			}
		}()
	}
	wg.Wait()
	fmt.Printf("counter = %d (expected %d)\n", counter, threads*increments)
}
</code></pre>
<h3 id="pythonthreadinglock"><a class="header" href="#pythonthreadinglock">Python（threading.Lock）</a></h3>
<pre><code class="language-python"># 執行：python3 ch07.py
import threading

THREADS = 4
INCREMENTS = 10000

counter = 0
lock = threading.Lock()

def worker():
    global counter
    for _ in range(INCREMENTS):
        with lock:
            counter += 1

if __name__ == "__main__":
    ts = [threading.Thread(target=worker) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"counter = {counter} (expected {THREADS * INCREMENTS})")
</code></pre>
<h2 id="完整專案級範例python-6"><a class="header" href="#完整專案級範例python-6">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch07.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch07.py
</code></pre>
<pre><code class="language-python">"""Chapter 07: synchronized equivalent in Python."""
import threading

lock = threading.Lock()
total = 0


def add():
    global total
    for _ in range(10000):
        with lock:
            total += 1


if __name__ == "__main__":
    ts = [threading.Thread(target=add) for _ in range(4)]
    for t in ts: t.start()
    for t in ts: t.join()
    print("total=", total)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第8章-aqs-佇列同步器"><a class="header" href="#第8章-aqs-佇列同步器">第8章 AQS 佇列同步器</a></h1>
<h2 id="81-aqs-核心對應-811812"><a class="header" href="#81-aqs-核心對應-811812">8.1 AQS 核心（對應 8.1.1~8.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-30"><a class="header" href="#本小節示意圖-30">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   AQS（AbstractQueuedSynchronizer）核心結構\n  ════════════════════════════════════════════════════════\n　\n  AQS 由兩個核心元件組成：\n　\n  ┌───────────────────────────────────────────────────────────────────┐
n2=&gt;operation:   │                    AQS 物件                                         │\n  │                                                                   │\n  │  state: int = 0   ← 核心同步狀態（CAS 競爭）                                │\n  │  head: Node*  ──────────────────────────────────┐                 │\n  │  tail: Node*  ──────────────────────────────────┼─┐               │\n  └──────────────────────────────────────────────────┼─┼──────────────┘
n3=&gt;operation:                                                      │ │\n  CLH 雙向等待佇列：                                  │ │\n  ┌──────────┐    ┌──────────────┐    ┌──────────────┐ │\n  │  head    │    │   Node(T2)   │    │   Node(T3)   │                │\n  │ (dummy)  │◄──►│  waitStatus  │◄──►│  waitStatus  │◄┘\n  │  Node    │    │  = SIGNAL    │    │  = SIGNAL                     │
n4=&gt;operation:   │          │    │  thread=T2   │    │  thread=T3                    │\n  └──────────┘    └──────────────┘    └──────┬────────────────────────┘\n                                              │\n                                           tail ◄── 最後入隊\n　\n  獨占模式 acquire 流程（以 ReentrantLock.lock 為例）：
n5=&gt;operation:   ┌───────────────────────────────────────────────────────────────────┐\n  │                                                                   │\n  │  Thread 呼叫 acquire(1)                                             │\n  │       │                                                           │\n  │       ▼                                                           │\n  │  tryAcquire()  ─── 成功（CAS state: 0→1）──► 持有鎖                      │
n6=&gt;operation:   │       │                                                           │\n  │       │ 失敗（state != 0，鎖被佔用）                                       │\n  │       ▼                                                           │\n  │  addWaiter(EXCLUSIVE)                                             │\n  │  建立 Node(thread=自己)，CAS 加入佇列尾部                                    │\n  │       │                                                           │
n7=&gt;operation:   │       ▼                                                           │\n  │  acquireQueued()                                                  │\n  │  ┌───────────────────────────────────────────┐                    │\n  │  │  for(;;) {                                │                    │\n  │  │    若前驅是 head → 再嘗試 tryAcquire()           │                    │\n  │  │    若成功 → 自己成為新 head，退出迴圈                  │                    │
n8=&gt;operation:   │  │    若失敗 → 前驅設為 SIGNAL                      │                    │\n  │  │    LockSupport.park()（掛起執行緒）              │                    │\n  │  │    等待 unpark() 喚醒後繼續迴圈                    │                    │\n  │  │  }                                        │                    │\n  │  └───────────────────────────────────────────┘                    │\n  │       │                                                           │
n9=&gt;operation:   │  release(1) 時：                                                    │\n  │  tryRelease() → state 0 → unpark(head.next.thread)                │\n  └───────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>AQS = <code>state</code>（整數狀態）+ FIFO 等待佇列。</p>
<h2 id="82-獨占與共享對應-821824"><a class="header" href="#82-獨占與共享對應-821824">8.2 獨占與共享（對應 8.2.1~8.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-31"><a class="header" href="#本小節示意圖-31">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   獨占模式 vs 共享模式對比\n  ════════════════════════════════════════════════════════\n　\n  獨占模式（Exclusive）— ReentrantLock\n  ┌──────────────────────────────────────────────────────────┐\n  │  state: 0 → 1（被獲取） → 0（釋放）                               │
n2=&gt;operation:   │                                                          │\n  │  時間軸：                                                    │\n  │  ─────────────────────────────────────────────►          │\n  │  T1 獲取 ████████████████████ T1 釋放                        │\n  │  T2 等待 ░░░░░░░░░░░░░░░░░░░░ T2 獲取 ████████               │\n  │  T3 等待 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ T3 獲取            │
n3=&gt;operation:   │                                                          │\n  │  state 只有 0 和 1，一次只有一個執行緒在臨界區                            │\n  │  tryAcquire：CAS(state, 0, 1) 成功才獲取                       │\n  │  tryRelease：state = 0，unpark 下一個等待者                      │\n  └──────────────────────────────────────────────────────────┘\n　
n4=&gt;operation:   共享模式（Shared）— Semaphore(permits=2)\n  ┌──────────────────────────────────────────────────────────┐\n  │  state: 2（可用名額） → 1 → 0（滿） → 1 → 2                       │\n  │                                                          │\n  │  時間軸：                                                    │\n  │  ─────────────────────────────────────────────►          │
n5=&gt;operation:   │  T1 獲取(state:2→1)████████████████ T1 釋放(→2)              │\n  │  T2 獲取(state:1→0)████████████████ T2 釋放(→1)              │\n  │  T3 等待(state=0) ░░░░░░░░░░░░░░░░ T3 獲取(1→0)██            │\n  │  T4 等待(state=0) ░░░░░░░░░░░░░░░░ T4 等待...                │\n  │                                                          │\n  │  tryAcquireShared：state &gt; 0 → CAS(state, s, s-1)         │
n6=&gt;operation:   │  tryReleaseShared：CAS(state, s, s+1)                     │\n  │                                                          │\n  │  setHeadAndPropagate：獲取成功後                               │\n  │  如果還有名額（state &gt; 0），傳播喚醒後續等待者                             │\n  │  ┌────────────────────────────────────────────┐          │\n  │  │  T2 獲取成功後：                               │            │
n7=&gt;operation:   │  │  state = 1 &gt; 0 → unpark(T3) 傳播           │            │\n  │  └────────────────────────────────────────────┘          │\n  └──────────────────────────────────────────────────────────┘\n　\n  獨占 vs 共享 API 對比：\n  ┌────────────────────────┬─────────────────────────────────┐
n8=&gt;operation:   │ 獨占（Exclusive）      │ 共享（Shared）                          │\n  ├────────────────────────┼─────────────────────────────────┤\n  │ tryAcquire(arg)        │ tryAcquireShared(arg)           │\n  │ tryRelease(arg)        │ tryReleaseShared(arg)           │\n  │ acquire(arg)           │ acquireShared(arg)              │\n  │ release(arg)           │ releaseShared(arg)              │
n9=&gt;operation:   │ ReentrantLock          │ Semaphore, ReadLock             │\n  └────────────────────────┴─────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<ul>
<li>獨占：一次一個（ReentrantLock）</li>
<li>共享：可多個（Semaphore/Read lock）</li>
</ul>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: state=0 → acquire 成功 → state=1\n        → 失敗 → 入隊等待
st-&gt;n1
</code></pre>
<p>白話例子：一個收銀櫃台（獨占） vs 多個自助結帳機（共享）。</p>
<h2 id="示意圖-7"><a class="header" href="#示意圖-7">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: state=1 (held)\nwait queue: N1 → N2 → N3\nrelease → unpark N1 → state 轉移
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-7"><a class="header" href="#跨語言完整範例-7">跨語言完整範例</a></h2>
<p>主題：Semaphore 限制最多 N 個並發任務（5 個任務，最多 2 個同時運行）</p>
<h3 id="cposix-sem_t"><a class="header" href="#cposix-sem_t">C（POSIX sem_t）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch08_c ch08.c
#include &lt;semaphore.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define MAX_CONCURRENT 2
#define TASK_COUNT 5

static sem_t sem;

void *task(void *arg) {
    int id = *(int *)arg;
    sem_wait(&amp;sem);                      // acquire（P 操作）
    printf("task %d: running\n", id);
    usleep(50000);                       // 模擬工作 50ms
    printf("task %d: done\n", id);
    sem_post(&amp;sem);                      // release（V 操作）
    return NULL;
}

int main(void) {
    sem_init(&amp;sem, 0, MAX_CONCURRENT);  // 最多 2 個並發
    pthread_t threads[TASK_COUNT];
    int ids[TASK_COUNT];
    for (int i = 0; i &lt; TASK_COUNT; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, task, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASK_COUNT; i++)
        pthread_join(threads[i], NULL);
    sem_destroy(&amp;sem);
    return 0;
}
</code></pre>
<h3 id="cstdcounting_semaphorec20"><a class="header" href="#cstdcounting_semaphorec20">C++（std::counting_semaphore，C++20）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++20 -pthread -o ch08_cpp ch08.cpp
#include &lt;semaphore&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int MAX_CONCURRENT = 2;
constexpr int TASK_COUNT = 5;

static std::counting_semaphore&lt;MAX_CONCURRENT&gt; sem(MAX_CONCURRENT);

void task(int id) {
    sem.acquire();                       // 獲取名額
    std::cout &lt;&lt; "task " &lt;&lt; id &lt;&lt; ": running\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(50));
    std::cout &lt;&lt; "task " &lt;&lt; id &lt;&lt; ": done\n";
    sem.release();                       // 釋放名額
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; TASK_COUNT; i++)
        threads.emplace_back(task, i);
    for (auto &amp;t : threads) t.join();
}
</code></pre>
<h3 id="rustsemaphore-via-arcmutex"><a class="header" href="#rustsemaphore-via-arcmutex">Rust（Semaphore via Arc&lt;Mutex<i32>&gt;）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch08.rs &amp;&amp; ./ch08
use std::sync::{Arc, Condvar, Mutex};
use std::thread;
use std::time::Duration;

const MAX_CONCURRENT: i32 = 2;
const TASK_COUNT: usize = 5;

fn main() {
    // 用 Mutex&lt;i32&gt; + Condvar 模擬 Semaphore
    let pair = Arc::new((Mutex::new(MAX_CONCURRENT), Condvar::new()));
    let mut handles = Vec::new();

    for id in 0..TASK_COUNT {
        let pair = Arc::clone(&amp;pair);
        handles.push(thread::spawn(move || {
            let (lock, cvar) = &amp;*pair;
            // acquire
            let mut count = lock.lock().unwrap();
            while *count == 0 {
                count = cvar.wait(count).unwrap();
            }
            *count -= 1;
            drop(count);

            println!("task {}: running", id);
            thread::sleep(Duration::from_millis(50));
            println!("task {}: done", id);

            // release
            *lock.lock().unwrap() += 1;
            cvar.notify_one();
        }));
    }
    for h in handles { h.join().unwrap(); }
}</code></pre></pre>
<h3 id="gochannel-作為-semaphore"><a class="header" href="#gochannel-作為-semaphore">Go（channel 作為 Semaphore）</a></h3>
<pre><code class="language-go">// 執行：go run ch08.go
package main

import (
	"fmt"
	"sync"
	"time"
)

const (
	maxConcurrent = 2
	taskCount     = 5
)

func main() {
	sem := make(chan struct{}, maxConcurrent) // 緩衝 channel 作 Semaphore
	var wg sync.WaitGroup

	for i := 0; i &lt; taskCount; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			sem &lt;- struct{}{}              // acquire（放入代表佔用名額）
			fmt.Printf("task %d: running\n", id)
			time.Sleep(50 * time.Millisecond)
			fmt.Printf("task %d: done\n", id)
			&lt;-sem                          // release（取出代表釋放名額）
		}(i)
	}
	wg.Wait()
}
</code></pre>
<h3 id="pythonthreadingsemaphore"><a class="header" href="#pythonthreadingsemaphore">Python（threading.Semaphore）</a></h3>
<pre><code class="language-python"># 執行：python3 ch08.py
import threading
import time

MAX_CONCURRENT = 2
TASK_COUNT = 5

sem = threading.Semaphore(MAX_CONCURRENT)

def task(task_id):
    with sem:                            # acquire / release 自動管理
        print(f"task {task_id}: running")
        time.sleep(0.05)
        print(f"task {task_id}: done")

if __name__ == "__main__":
    ts = [threading.Thread(target=task, args=(i,)) for i in range(TASK_COUNT)]
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<h2 id="完整專案級範例python-7"><a class="header" href="#完整專案級範例python-7">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch08.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch08.py
</code></pre>
<pre><code class="language-python">"""Chapter 08: queue synchronizer flavor via semaphore."""
import threading
import time

sem = threading.Semaphore(2)


def task(i: int):
    with sem:
        print(f"task {i} enter")
        time.sleep(0.05)
        print(f"task {i} leave")


if __name__ == "__main__":
    ts = [threading.Thread(target=task, args=(i,)) for i in range(5)]
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第9章-lock-家族"><a class="header" href="#第9章-lock-家族">第9章 Lock 家族</a></h1>
<h2 id="91-顯式鎖"><a class="header" href="#91-顯式鎖">9.1 顯式鎖</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-32"><a class="header" href="#本小節示意圖-32">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   顯式鎖三種獲取路徑對比\n  ════════════════════════════════════════════════════════\n　\n  lock()：無限等待，不可中斷\n  ┌─────────────────────────────────────────────────────────────────┐\n  │  thread.lock()                                                  │
n2=&gt;operation:   │       │                                                         │\n  │       ▼                                                         │\n  │  嘗試獲取鎖 ─── 成功 ──► 進入臨界區                                         │\n  │       │                                                         │\n  │       │ 失敗（鎖被佔用）                                                │\n  │       ▼                                                         │
n3=&gt;operation:   │  park()（永久等待）                                                   │\n  │  ⚠ 即使收到 interrupt()，仍然繼續等待                                      │\n  │  只有鎖被釋放後才被 unpark 喚醒                                            │\n  │  優點：簡單   缺點：可能永久阻塞                                              │\n  └─────────────────────────────────────────────────────────────────┘\n　
n4=&gt;operation:   tryLock(timeout)：超時等待\n  ┌─────────────────────────────────────────────────────────────────┐\n  │  lock = thread.tryLock(1, TimeUnit.SECONDS)                     │\n  │       │                                                         │\n  │       ▼                                                         │\n  │  嘗試獲取鎖 ─── 成功 ──► 進入臨界區                                         │
n5=&gt;operation:   │       │                                                         │\n  │       │ 失敗，記錄 deadline                                          │\n  │       ▼                                                         │\n  │  park(timeout)                                                  │\n  │  ┌─────────────────────────────────────────────┐                │\n  │  │  等待期間：                                     │                 │
n6=&gt;operation:   │  │  ├─ 被喚醒（鎖釋放）→ 重試 tryLock                   │                 │\n  │  │  ├─ 超時      → 返回 false，不進臨界區               │                 │\n  │  │  └─ interrupt → 拋 InterruptedException     │                 │\n  │  └─────────────────────────────────────────────┘                │\n  │  優點：避免永久阻塞   缺點：需處理返回值                                          │\n  └─────────────────────────────────────────────────────────────────┘
n7=&gt;operation: 　\n  lockInterruptibly()：可中斷等待\n  ┌─────────────────────────────────────────────────────────────────┐\n  │  thread.lockInterruptibly()                                     │\n  │       │                                                         │\n  │       ▼                                                         │
n8=&gt;operation:   │  嘗試獲取鎖 ─── 成功 ──► 進入臨界區                                         │\n  │       │                                                         │\n  │       │ 失敗，進入佇列等待                                               │\n  │       ▼                                                         │\n  │  parkInterruptibly()                                            │\n  │  ┌─────────────────────────────────────────────┐                │
n9=&gt;operation:   │  │  等待期間：                                     │                 │\n  │  │  ├─ 被喚醒（鎖釋放）→ 重試獲取                         │                 │\n  │  │  └─ interrupt → 立即拋 InterruptedException   │                 │\n  │  │     從等待佇列移除，不再等待                           │                 │\n  │  └─────────────────────────────────────────────┘                │\n  │  優點：可取消   缺點：呼叫者必須處理異常                                          │
n10=&gt;operation:   └─────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<p>比 <code>synchronized</code> 更可控：可中斷、可超時、可嘗試。</p>
<h2 id="92-公平與非公平對應-921926"><a class="header" href="#92-公平與非公平對應-921926">9.2 公平與非公平（對應 9.2.1~9.2.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-33"><a class="header" href="#本小節示意圖-33">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   公平鎖 vs 非公平鎖競爭示意\n  ════════════════════════════════════════════════════════\n　\n  公平鎖（Fair Lock）— 嚴格 FIFO 順序\n  ┌───────────────────────────────────────────────────────────────────┐\n  │                                                                   │
n2=&gt;operation:   │  等待佇列：  T2 → T3 → T4（依入隊順序）                                       │\n  │                                                                   │\n  │  T1 釋放鎖                                                           │\n  │       │                                                           │\n  │       ▼ 只喚醒佇列頭部                                                   │\n  │  T2 獲取鎖（FIFO 頭部）                                                  │
n3=&gt;operation:   │                                                                   │\n  │  此時 T5 剛好到達：                                                      │\n  │  ┌──────────────────────────────────────────────┐                 │\n  │  │  T5 發現佇列不空 → 直接入隊尾部（不搶）                   │                    │\n  │  │  等待佇列：T3 → T4 → T5                        │                    │\n  │  └──────────────────────────────────────────────┘                 │
n4=&gt;operation:   │                                                                   │\n  │  ✅ 優點：無飢餓，等待時間可預期                                                 │\n  │  ❌ 缺點：每次都要喚醒掛起執行緒（吞吐較低）                                           │\n  └───────────────────────────────────────────────────────────────────┘\n　\n  非公平鎖（Non-Fair Lock）— 先搶再排
n5=&gt;operation:   ┌───────────────────────────────────────────────────────────────────┐\n  │                                                                   │\n  │  等待佇列：  T2 → T3 → T4（已在等待）                                        │\n  │                                                                   │\n  │  T1 釋放鎖                                                           │\n  │       │                                                           │
n6=&gt;operation:   │       ▼ 喚醒佇列頭部 T2，同時...                                           │\n  │                                                                   │\n  │  此時 T5 剛好到達：                                                      │\n  │  ┌──────────────────────────────────────────────┐                 │\n  │  │  T5 先嘗試 CAS(state, 0, 1)                  │                    │\n  │  │  若 CAS 成功 → T5 直接獲取！（T2 繼續等）              │                    │
n7=&gt;operation:   │  │  若 CAS 失敗 → T5 才入隊尾部                      │                    │\n  │  └──────────────────────────────────────────────┘                 │\n  │                                                                   │\n  │  ✅ 優點：減少上下文切換（T5 不必 park/unpark）                                  │\n  │  ❌ 缺點：佇列中的執行緒可能被後來者插隊（飢餓）                                         │\n  └───────────────────────────────────────────────────────────────────┘
n8=&gt;operation: 　\n  效能對比：\n  非公平鎖吞吐量通常比公平鎖高 2~10 倍（視競爭程度）\n  ReentrantLock 預設是非公平鎖
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>公平降低飢餓但吞吐可能較低；非公平吞吐高但可能插隊。</p>
<h2 id="93-悲觀與樂觀對應-931934"><a class="header" href="#93-悲觀與樂觀對應-931934">9.3 悲觀與樂觀（對應 9.3.1~9.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-34"><a class="header" href="#本小節示意圖-34">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   悲觀鎖 vs 樂觀鎖（CAS）流程對比\n  ════════════════════════════════════════════════════════\n　\n  悲觀鎖（Pessimistic Lock）— 假設衝突必然發生\n  ┌─────────────────────────────────────────────────────────────────────────────────────────┐\n  │                                                                                         │
n2=&gt;operation:   │  ┌──────────┐                                                                           │\n  │  │  lock()                                      │← 先鎖定資源（阻塞其他執行緒）                       │\n  │  └────┬─────┘                                                                           │\n  │       │                                                                                 │\n  │       ▼                                                                                 │\n  │  ┌──────────┐                                                                           │
n3=&gt;operation:   │  │ read data                                    │← 讀取資料（安全，因為已鎖定）                       │\n  │  └────┬─────┘                                                                           │\n  │       │                                                                                 │\n  │       ▼                                                                                 │\n  │  ┌──────────┐                                                                           │\n  │  │write data                                    │← 修改資料                                 │
n4=&gt;operation:   │  └────┬─────┘                                                                           │\n  │       │                                                                                 │\n  │       ▼                                                                                 │\n  │  ┌──────────┐                                                                           │\n  │  │ unlock()                                     │← 釋放鎖                                  │\n  │  └──────────┘                                                                           │
n5=&gt;operation:   │                                                                                         │\n  │  適用：衝突頻率高、臨界區長、寫操作多                                                                     │\n  └─────────────────────────────────────────────────────────────────────────────────────────┘\n　\n  樂觀鎖（Optimistic Lock）— 假設衝突很少，先做再驗\n  ┌─────────────────────────────────────────────────────────────────────────────────────────┐
n6=&gt;operation:   │                                                                                         │\n  │  ┌─────────────────────┐                                                                │\n  │  │ read data + version                          │← 讀值 + 記版本號（無鎖）                        │\n  │  └──────────┬──────────┘                                                                │\n  │             │                                                                           │\n  │             ▼                                                                           │
n7=&gt;operation:   │  ┌─────────────────────┐                                                                │\n  │  │    compute new val                           │← 計算新值（無鎖執行）                           │\n  │  └──────────┬──────────┘                                                                │\n  │             │                                                                           │\n  │             ▼                                                                           │\n  │  ┌──────────────────────────────────────────────┐                                       │
n8=&gt;operation:   │  │  CAS(addr, old_val, new_val)                 │                                       │\n  │  │      ── 且 ──                                 │                                       │\n  │  │  version 比較（version == old_version）          │                                       │\n  │  └────────────────┬─────────────────────────────┘                                       │\n  │                   │                                                                     │\n  │          ┌────────┴────────┐                                                            │
n9=&gt;operation:   │          ▼                 ▼                                                            │\n  │    CAS 成功              CAS 失敗（有衝突）                                                      │\n  │    version++             重新 read + retry                                                │\n  │    操作完成              ↑─────────────────────┘                                            │\n  │                                                                                         │\n  │  適用：衝突頻率低、臨界區短、讀操作多                                                                     │
n10=&gt;operation:   └─────────────────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<p>衝突高用悲觀鎖，衝突低可走 CAS/版本號。</p>
<h2 id="94-可中斷對應-941944"><a class="header" href="#94-可中斷對應-941944">9.4 可中斷（對應 9.4.1~9.4.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-35"><a class="header" href="#本小節示意圖-35">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   可中斷等待 vs 不可中斷等待對比\n  ════════════════════════════════════════════════════════\n　\n  lock()：不可中斷（忽略 interrupt）\n  ┌──────────────────────────────────────────────────────┐\n  │                                                      │
n2=&gt;operation:   │  Thread T_wait                    Thread T_other     │\n  │  ──────────────                   ──────────────     │\n  │  lock()（鎖被佔用）                                        │\n  │  park()...（掛起等待）                                     │\n  │                        ──────►   T_wait.interrupt()  │\n  │  中斷標記設為 true                                         │
n3=&gt;operation:   │  但 lock() 繼續等待！                                      │\n  │  ⚠ 不拋異常，繼續 park                                      │\n  │  直到鎖釋放才 unpark                                       │\n  │  獲取鎖後才能檢查中斷標記                                        │\n  │                                                      │\n  └──────────────────────────────────────────────────────┘
n4=&gt;operation: 　\n  lockInterruptibly()：可中斷\n  ┌──────────────────────────────────────────────────────┐\n  │                                                      │\n  │  Thread T_wait                    Thread T_other     │\n  │  ──────────────                   ──────────────     │
n5=&gt;operation:   │  lockInterruptibly()                                 │\n  │  （鎖被佔用）進入等待佇列                                        │\n  │  parkInterruptibly()...                              │\n  │                        ──────►   T_wait.interrupt()  │\n  │  ↓ 被喚醒（因 interrupt）                                  │\n  │  拋出 InterruptedException ←───────────────────────    │
n6=&gt;operation:   │  從等待佇列移除                                             │\n  │  執行緒可以執行取消/清理邏輯                                      │\n  │                                                      │\n  │  使用場景：可取消的任務、避免死鎖、實作超時                               │\n  └──────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>等待鎖時可取消，避免永久卡死。</p>
<h2 id="95-獨占共享對應-951954"><a class="header" href="#95-獨占共享對應-951954">9.5 獨占/共享（對應 9.5.1~9.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-36"><a class="header" href="#本小節示意圖-36">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   獨占鎖 vs 共享鎖 相容矩陣\n  ════════════════════════════════════════════════════════\n　\n  ┌──────────────────────┬────────────────┬────────────────────────────────────┐\n  │                      │  持有讀鎖中                 │  持有寫鎖中                     │\n  ├──────────────────────┼────────────────┼────────────────────────────────────┤
n2=&gt;operation:   │  新執行緒申請讀鎖            │  ✅ 允許（共享）              │  ❌ 阻塞                      │\n  ├──────────────────────┼────────────────┼────────────────────────────────────┤\n  │  新執行緒申請寫鎖            │  ❌ 阻塞                  │  ❌ 阻塞                      │\n  └──────────────────────┴────────────────┴────────────────────────────────────┘\n　\n  說明：
n3=&gt;operation:   ┌────────────────────────────────────────────────────────────────────────────┐\n  │  讀鎖（共享）：                                                                   │\n  │  • 多個執行緒可同時持有讀鎖                                                            │\n  │  • 適合唯讀操作，不修改資料                                                            │\n  │  • 相容性：讀-讀 允許 / 讀-寫 不允許                                                    │\n  │                                                                            │
n4=&gt;operation:   │  寫鎖（獨占）：                                                                   │\n  │  • 只有一個執行緒可持有寫鎖                                                            │\n  │  • 持有期間排斥所有讀鎖和寫鎖                                                           │\n  │  • 相容性：寫-讀 不允許 / 寫-寫 不允許                                                   │\n  │                                                                            │\n  │  AQS state 編碼（ReadWriteLock）：                                              │
n5=&gt;operation:   │  ┌────────────────────────────────────────────┐                            │\n  │                      │  32-bit state                              │        │\n  │                      │  高 16 位：讀鎖計數（讀者數量）            │                     │\n  │                      │  低 16 位：寫鎖計數（重入次數）            │                     │\n  │  └────────────────────────────────────────────┘                            │\n  └────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>不同資源特性選不同模型。</p>
<h2 id="96-可重入對應-961962"><a class="header" href="#96-可重入對應-961962">9.6 可重入（對應 9.6.1~9.6.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-37"><a class="header" href="#本小節示意圖-37">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   可重入鎖（Reentrant Lock）計數器機制\n  ════════════════════════════════════════════════════════\n　\n  場景：T1 持有鎖後呼叫遞迴方法，需要再次獲取同一把鎖\n　\n  ┌───────────────────────────────────────────────────────┐
n2=&gt;operation:   │  Thread T1                          state 計數器         │\n  │  ──────────────────                 ─────────────     │\n  │                                                       │\n  │  1. lock()                          state = 0         │\n  │     CAS(state, 0, 1) 成功           state = 1           │\n  │     owner = T1                                        │
n3=&gt;operation:   │     ↓                                                 │\n  │  2. 呼叫 methodA()                                      │\n  │     ↓                                                 │\n  │  3. lock()（重入）                  state = 1             │\n  │     owner == T1（自己）→ 直接重入   state = 2                 │\n  │     recursions++                                      │
n4=&gt;operation:   │     ↓                                                 │\n  │  4. 呼叫 methodB()（繼續重入）                                │\n  │     lock()                          state = 2         │\n  │     owner == T1 → 直接重入          state = 3             │\n  │     ↓                                                 │\n  │  5. methodB 完成                                        │
n5=&gt;operation:   │     unlock()                        state = 3         │\n  │     recursions--                    state = 2         │\n  │     ↓                                                 │\n  │  6. methodA 完成                                        │\n  │     unlock()                        state = 2         │\n  │     recursions--                    state = 1         │
n6=&gt;operation:   │     ↓                                                 │\n  │  7. 最外層完成                                             │\n  │     unlock()                        state = 1         │\n  │     state = 0，owner = null         state = 0 ✅        │\n  │     喚醒等待的執行緒                                          │\n  │                                                       │
n7=&gt;operation:   │  ⚠ 若不可重入：步驟 3 會死鎖（等自己釋放鎖）                             │\n  └───────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>同執行緒可重複拿同一把鎖，靠計數器解決遞迴鎖死。</p>
<h2 id="97-讀寫鎖對應-971976"><a class="header" href="#97-讀寫鎖對應-971976">9.7 讀寫鎖（對應 9.7.1~9.7.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-38"><a class="header" href="#本小節示意圖-38">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   讀寫鎖時間軸示意\n  ════════════════════════════════════════════════════════\n　\n  時間軸（從左到右）：\n  ─────────────────────────────────────────────────────►\n　
n2=&gt;operation:   R1: ████████████████████████                  ← 讀者1\n  R2:       ████████████████████████            ← 讀者2（與R1並發）\n  R3:             ████████████████████████      ← 讀者3（與R1/R2並發）\n　\n  W1:                              ░░░░░░████   ← 寫者1（等待R1/R2/R3結束）\n                                   等待  ↑ 進入臨界區
n3=&gt;operation: 　\n  R4: （W1 等待期間到來）          ░░░░░░░░████ ← 可能被 W1 擋住（防寫者飢餓）\n  R5:                                    ░░░████← W1 完成後 R4/R5 可進入\n　\n  規則：\n  ┌──────────────────────────────────────────────────────────┐
n4=&gt;operation:   │  ✅ 多個讀者同時進入（無寫者時）                                        │\n  │  ✅ 寫者獨占（進入時排除所有讀者和其他寫者）                                  │\n  │  ⚠  寫者等待所有現有讀者完成才能進入                                     │\n  │  ⚠  有等待寫者時，新讀者可能被阻止（防飢餓策略）                               │\n  └──────────────────────────────────────────────────────────┘\n　
n5=&gt;operation:   狀態轉換：\n  ┌────────────────┬───────────────┬─────────────────────────┐\n  │  當前狀態        │ 申請讀鎖      │ 申請寫鎖                          │\n  ├────────────────┼───────────────┼─────────────────────────┤\n  │  無鎖          │ 立即獲取      │ 立即獲取                          │\n  │  讀鎖（1+個）     │ 立即獲取      │ 阻塞等待所有讀者退出                    │
n6=&gt;operation:   │  寫鎖（1個）      │ 阻塞等待      │ 阻塞（除非重入）                      │\n  └────────────────┴───────────────┴─────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>讀多寫少場景常見，讀可併發、寫需獨占。</p>
<h2 id="98-parkunpark對應-981982"><a class="header" href="#98-parkunpark對應-981982">9.8 park/unpark（對應 9.8.1~9.8.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-39"><a class="header" href="#本小節示意圖-39">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   LockSupport.park / unpark 原語\n  ════════════════════════════════════════════════════════\n　\n  執行緒狀態轉換：\n　\n  Thread T
n2=&gt;operation:   ─────────────────────────────────────────────────────\n  RUNNABLE\n      │\n      │ LockSupport.park()\n      ▼\n  WAITING ← 執行緒掛起，不消耗 CPU
n3=&gt;operation:   （操作系統層面：futex/pthread_cond_wait）\n      │\n      │ LockSupport.unpark(T)  ← 任意執行緒可呼叫\n      ▼\n  RUNNABLE ← 繼續執行 park() 之後的程式碼\n　
n4=&gt;operation:   park / unpark 特殊語義（permit 模型）：\n  ┌────────────────────────────────────────────────────────────────┐\n  │  每個執行緒有一個「permit」（0 或 1）                                       │\n  │                                                                │\n  │  unpark(T)：                                                    │\n  │  • 若 T 在等待 → 立即喚醒 T，permit 保持 0                                │
n5=&gt;operation:   │  • 若 T 未等待 → permit 設為 1（預存）                                   │\n  │                                                                │\n  │  park()：                                                       │\n  │  • 若 permit = 1 → 立即返回（消耗 permit 設為 0）                         │\n  │  • 若 permit = 0 → 掛起等待                                         │\n  │                                                                │
n6=&gt;operation:   │  結果：unpark 可以在 park 之前呼叫，不會丟失喚醒信號                              │\n  └────────────────────────────────────────────────────────────────┘\n　\n  與 wait/notify 對比：\n  ┌───────────────────┬─────────────────┬──────────────────────────┐\n  │ 特性                │ wait/notify     │ park/unpark              │
n7=&gt;operation:   ├───────────────────┼─────────────────┼──────────────────────────┤\n  │ 需要鎖               │ 是（必須在          │ 否（任何地方                    │\n  │                   │ synchronized 中）│ 都可呼叫）                     │\n  │ 喚醒特定執行緒           │ 否（notify 隨機）   │ 是（指定 T）                   │\n  │ 先喚醒後等待            │ 信號丟失           │ permit 保存                 │\n  │ 虛假喚醒              │ 需要 while 迴圈    │ 也需要檢查                     │
n8=&gt;operation:   └───────────────────┴─────────────────┴──────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>底層掛起/喚醒原語。</p>
<h2 id="示意圖-8"><a class="header" href="#示意圖-8">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 讀寫鎖:\nReaders: R1 R2 R3 可同時進\nWriter : W 需要獨占，等所有 Reader 離開
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-8"><a class="header" href="#跨語言完整範例-8">跨語言完整範例</a></h2>
<p>主題：讀寫鎖保護 map（3 個 reader 並發讀，1 個 writer 定期寫）</p>
<h3 id="cpthread_rwlock"><a class="header" href="#cpthread_rwlock">C（pthread_rwlock）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch09_c ch09.c
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define READERS 3

static int shared_data = 0;
static pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

void *reader(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i &lt; 3; i++) {
        pthread_rwlock_rdlock(&amp;rwlock);       // 讀鎖（多讀者可並發）
        printf("reader %d: data = %d\n", id, shared_data);
        usleep(20000);
        pthread_rwlock_unlock(&amp;rwlock);
        usleep(10000);
    }
    return NULL;
}

void *writer(void *arg) {
    for (int i = 1; i &lt;= 3; i++) {
        usleep(30000);
        pthread_rwlock_wrlock(&amp;rwlock);       // 寫鎖（獨占）
        shared_data = i * 10;
        printf("writer: data set to %d\n", shared_data);
        pthread_rwlock_unlock(&amp;rwlock);
    }
    return NULL;
}

int main(void) {
    pthread_t readers[READERS], wr;
    int ids[READERS];
    for (int i = 0; i &lt; READERS; i++) {
        ids[i] = i;
        pthread_create(&amp;readers[i], NULL, reader, &amp;ids[i]);
    }
    pthread_create(&amp;wr, NULL, writer, NULL);
    for (int i = 0; i &lt; READERS; i++) pthread_join(readers[i], NULL);
    pthread_join(wr, NULL);
    pthread_rwlock_destroy(&amp;rwlock);
    return 0;
}
</code></pre>
<h3 id="cstdshared_mutex"><a class="header" href="#cstdshared_mutex">C++（std::shared_mutex）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch09_cpp ch09.cpp
#include &lt;shared_mutex&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

static int shared_data = 0;
static std::shared_mutex rw;

void reader(int id) {
    for (int i = 0; i &lt; 3; i++) {
        std::shared_lock lock(rw);            // 共享讀鎖
        std::cout &lt;&lt; "reader " &lt;&lt; id &lt;&lt; ": data = " &lt;&lt; shared_data &lt;&lt; "\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(20));
    }
}

void writer() {
    for (int i = 1; i &lt;= 3; i++) {
        std::this_thread::sleep_for(std::chrono::milliseconds(30));
        std::unique_lock lock(rw);            // 獨占寫鎖
        shared_data = i * 10;
        std::cout &lt;&lt; "writer: data set to " &lt;&lt; shared_data &lt;&lt; "\n";
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 3; i++)
        threads.emplace_back(reader, i);
    threads.emplace_back(writer);
    for (auto &amp;t : threads) t.join();
}
</code></pre>
<h3 id="rustrwlock"><a class="header" href="#rustrwlock">Rust（RwLock<i32>）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch09.rs &amp;&amp; ./ch09
use std::sync::{Arc, RwLock};
use std::thread;
use std::time::Duration;

fn main() {
    let data = Arc::new(RwLock::new(0i32));
    let mut handles = Vec::new();

    // 3 個讀者
    for id in 0..3 {
        let data = Arc::clone(&amp;data);
        handles.push(thread::spawn(move || {
            for _ in 0..3 {
                let val = data.read().unwrap();  // 共享讀鎖
                println!("reader {}: data = {}", id, *val);
                drop(val);
                thread::sleep(Duration::from_millis(10));
            }
        }));
    }

    // 1 個寫者
    let data = Arc::clone(&amp;data);
    handles.push(thread::spawn(move || {
        for i in 1..=3 {
            thread::sleep(Duration::from_millis(30));
            *data.write().unwrap() = i * 10;    // 獨占寫鎖
            println!("writer: data set to {}", i * 10);
        }
    }));

    for h in handles { h.join().unwrap(); }
}</code></pre></pre>
<h3 id="gosyncrwmutex"><a class="header" href="#gosyncrwmutex">Go（sync.RWMutex）</a></h3>
<pre><code class="language-go">// 執行：go run ch09.go
package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	sharedData int
	rw         sync.RWMutex
)

func reader(id int, wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 0; i &lt; 3; i++ {
		rw.RLock()                              // 共享讀鎖
		fmt.Printf("reader %d: data = %d\n", id, sharedData)
		time.Sleep(20 * time.Millisecond)
		rw.RUnlock()
		time.Sleep(10 * time.Millisecond)
	}
}

func writer(wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 1; i &lt;= 3; i++ {
		time.Sleep(30 * time.Millisecond)
		rw.Lock()                               // 獨占寫鎖
		sharedData = i * 10
		fmt.Printf("writer: data set to %d\n", sharedData)
		rw.Unlock()
	}
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i &lt; 3; i++ {
		wg.Add(1)
		go reader(i, &amp;wg)
	}
	wg.Add(1)
	go writer(&amp;wg)
	wg.Wait()
}
</code></pre>
<h3 id="pythonthreadingrlock--手動讀寫鎖"><a class="header" href="#pythonthreadingrlock--手動讀寫鎖">Python（threading.RLock + 手動讀寫鎖）</a></h3>
<pre><code class="language-python"># 執行：python3 ch09.py
import threading
import time

shared_data = 0
rw = threading.Lock()          # 寫者用
read_count = 0
read_count_lock = threading.Lock()

def reader(reader_id):
    global read_count
    for _ in range(3):
        with read_count_lock:
            read_count += 1
            if read_count == 1:
                rw.acquire()   # 第一個讀者鎖定寫者
        print(f"reader {reader_id}: data = {shared_data}")
        time.sleep(0.02)
        with read_count_lock:
            read_count -= 1
            if read_count == 0:
                rw.release()   # 最後一個讀者釋放寫者鎖

def writer():
    global shared_data
    for i in range(1, 4):
        time.sleep(0.03)
        with rw:               # 獨占寫鎖
            shared_data = i * 10
            print(f"writer: data set to {shared_data}")

if __name__ == "__main__":
    ts = [threading.Thread(target=reader, args=(i,)) for i in range(3)]
    ts.append(threading.Thread(target=writer))
    for t in ts: t.start()
    for t in ts: t.join()
</code></pre>
<h2 id="完整專案級範例python-8"><a class="header" href="#完整專案級範例python-8">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch09.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch09.py
</code></pre>
<pre><code class="language-python">"""Chapter 09: lock family (Lock/RLock/Condition)."""
import threading

rlock = threading.RLock()
cond = threading.Condition(rlock)
ready = False


def producer():
    global ready
    with rlock:
        ready = True
        cond.notify_all()


def consumer():
    with rlock:
        while not ready:
            cond.wait()
        print("consumer got signal")


if __name__ == "__main__":
    t1 = threading.Thread(target=consumer)
    t2 = threading.Thread(target=producer)
    t1.start(); t2.start(); t1.join(); t2.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第10章-cas"><a class="header" href="#第10章-cas">第10章 CAS</a></h1>
<h2 id="101-cas-基本模型"><a class="header" href="#101-cas-基本模型">10.1 CAS 基本模型</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-40"><a class="header" href="#本小節示意圖-40">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   CAS（Compare-And-Swap）基本模型\n  ════════════════════════════════════════════════════════\n　\n  函數語義：\n  ┌──────────────────────────────────────────────────────────────────────────────────────────┐\n  │  bool CAS(addr, expected, new_val) {                                                     │
n2=&gt;operation:   │      if (*addr == expected) {                                                            │\n  │          *addr = new_val;                                                                │\n  │          return true;    // 交換成功                                                         │\n  │      } else {                                                                            │\n  │          return false;   // 交換失敗（值已被改）                                                   │\n  │      }                                                                                   │
n3=&gt;operation:   │  }                                                                                       │\n  │  ⚠ 上面的 if-then 是原子執行，不可被打斷                                                               │\n  └──────────────────────────────────────────────────────────────────────────────────────────┘\n　\n  執行流程示意：\n  ┌──────────────────────────────────────────────────────────────────────────────────────────┐
n4=&gt;operation:   │                                                                                          │\n  │  記憶體位址 addr                                                                              │\n  │  ┌──────────┐                                                                            │\n  │  │  *addr                                      │ = 10（當前值）                               │\n  │  └──────────┘                                                                            │\n  │       │                                                                                  │
n5=&gt;operation:   │       │ CAS(addr, expected=10, new_val=20)                                               │\n  │       ▼                                                                                  │\n  │  ┌─────────────────────────────────────────────┐                                         │\n  │  │  原子比較：*addr(10) == expected(10) ?           │                                         │\n  │  │  ├─ 是（成功路徑）                                 │                                         │\n  │  │  │   *addr = 20                             │                                         │
n6=&gt;operation:   │  │  │   return true ✅                          │                                         │\n  │  │  │   ┌──────────┐                           │                                         │\n  │  │  │   │  *addr   │ = 20                      │                                         │\n  │  │  │   └──────────┘                           │                                         │\n  │  │  │                                          │                                         │\n  │  │  └─ 否（失敗路徑，*addr 已被其他執行緒改為 15）                                                        │
n7=&gt;operation:   │  │      return false ❌                         │                                         │\n  │  │      呼叫者需要重新讀取並重試                           │                                         │\n  │  └─────────────────────────────────────────────┘                                         │\n  │                                                                                          │\n  │  硬體層：CMPXCHG 指令（x86）                                                                     │\n  │  ┌─────────────────────────────────────────────┐                                         │
n8=&gt;operation:   │  │  LOCK CMPXCHG [mem], reg                    │                                         │\n  │  │  ├─ LOCK 前綴：鎖定快取行/記憶體匯流排                    │                                         │\n  │  │  ├─ 比較 EAX 與 [mem]                          │                                         │\n  │  │  ├─ 相等 → [mem] = reg（ZF=1）                  │                                         │\n  │  │  └─ 不等 → EAX = [mem]（ZF=0，讓呼叫者重試）           │                                         │\n  │  └─────────────────────────────────────────────┘                                         │
n9=&gt;operation:   └──────────────────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>Compare-And-Swap：比較並交換。</p>
<h2 id="102-底層支持對應-10211022"><a class="header" href="#102-底層支持對應-10211022">10.2 底層支持（對應 10.2.1~10.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-41"><a class="header" href="#本小節示意圖-41">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   Intel x86 LOCK CMPXCHG vs ARM LL/SC\n  ════════════════════════════════════════════════════════\n　\n  Intel x86 — LOCK CMPXCHG（單條原子指令）\n  ┌──────────────────────────────────────────────────────────────────────────┐\n  │                                                                          │
n2=&gt;operation:   │  CPU 執行 LOCK CMPXCHG                                                     │\n  │       │                                                                  │\n  │       ▼                                                                  │\n  │  ┌──────────────────────────────────────────────┐                        │\n  │  │  Step 1：LOCK 前綴                               │                       │\n  │  │  鎖定對應快取行（Cache Line Lock）                     │                       │
n3=&gt;operation:   │  │  或在多 CPU 系統鎖定記憶體匯流排                           │                       │\n  │  └─────────────────────┬────────────────────────┘                        │\n  │                         │                                                │\n  │                         ▼                                                │\n  │  ┌──────────────────────────────────────────────┐                        │\n  │  │  Step 2：原子比較                                  │                       │
n4=&gt;operation:   │  │  compare EAX（expected）with [mem]              │                       │\n  │  │  ├─ 相等 → exchange [mem] = new_reg             │                       │\n  │  │  │         ZF = 1（表示成功）                │                              │\n  │  │  └─ 不等 → EAX = [mem]（取回現值）                    │                       │\n  │  │            ZF = 0（表示失敗）                       │                       │\n  │  └─────────────────────┬────────────────────────┘                        │
n5=&gt;operation:   │                         │                                                │\n  │                         ▼                                                │\n  │  ┌──────────────────────────────────────────────┐                        │\n  │  │  Step 3：UNLOCK                                │                       │\n  │  │  釋放快取行/匯流排鎖                                   │                       │\n  │  └──────────────────────────────────────────────┘                        │
n6=&gt;operation:   │  整個過程不可中斷，其他 CPU 必須等待             │                                      │\n  └──────────────────────────────────────────────────────────────────────────┘\n　\n  ARM — LL/SC（Load-Link / Store-Conditional，可能重試）\n  ┌──────────────────────────────────────────────────────────────────────────┐\n  │                                                                          │
n7=&gt;operation:   │  retry:                                                                  │\n  │       │                                                                  │\n  │       ▼                                                                  │\n  │  ┌──────────────────────────────────────────────┐                        │\n  │  │  LDREX r0, [addr]  ← Load-Link                │                       │\n  │  │  記錄 addr 的「獨占監視器」標記                           │                       │
n8=&gt;operation:   │  │  r0 = *addr（讀取當前值）                            │                       │\n  │  └─────────────────────┬────────────────────────┘                        │\n  │                         │                                                │\n  │                         ▼ 計算新值                                           │\n  │                    r1 = r0 + 1                                           │\n  │                         │                                                │
n9=&gt;operation:   │                         ▼                                                │\n  │  ┌──────────────────────────────────────────────┐                        │\n  │  │  STREX result, r1, [addr]  ← Store-Conditional│                       │\n  │  │  若獨占監視器標記仍有效（無其他寫入）                           │                       │\n  │  │  ├─ 寫入成功：*addr = r1，result = 0                │                       │\n  │  │  └─ 寫入失敗：result = 1（有其他 CPU 寫入）               │                       │
n10=&gt;operation:   │  └─────────────────────┬────────────────────────┘                        │\n  │                         │                                                │\n  │             ┌───────────┴───────────┐                                    │\n  │             ▼                       ▼                                    │\n  │        result == 0             result == 1                               │\n  │        成功，完成              失敗，回到 retry                                    │
n11=&gt;operation:   │                                ────────────────►                         │\n  │  LL/SC 通過重試避免總線鎖，對多核效能更友好        │                                       │\n  └──────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
n10-&gt;n11
</code></pre>
<p>依賴 CPU 原子指令；Java <code>Unsafe/VarHandle</code>、C++ <code>atomic</code>、Rust <code>Atomic*</code>、Go <code>sync/atomic</code>。</p>
<h2 id="103-cas-實作計數器對應-10311033"><a class="header" href="#103-cas-實作計數器對應-10311033">10.3 CAS 實作計數器（對應 10.3.1~10.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-42"><a class="header" href="#本小節示意圖-42">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   CAS 自旋計數器流程\n  ════════════════════════════════════════════════════════\n　\n  單次遞增流程（樂觀自旋）：\n  ┌───────────────────────────────────────────────────────────────────┐\n  │                                                                   │
n2=&gt;operation:   │  ┌─────────────────────────────────────────────┐                  │\n  │  │  Step 1：load old = *counter                │                   │\n  │  │  讀取當前值（此時 counter = 5）                     │                   │\n  │  └────────────────────────┬────────────────────┘                  │\n  │                            │ old = 5                              │\n  │                            ▼                                      │
n3=&gt;operation:   │  ┌─────────────────────────────────────────────┐                  │\n  │  │  Step 2：new = old + 1 = 6                  │                   │\n  │  │  計算新值（純粹計算，無競爭）                            │                   │\n  │  └────────────────────────┬────────────────────┘                  │\n  │                            │                                      │\n  │                            ▼                                      │
n4=&gt;operation:   │  ┌─────────────────────────────────────────────┐                  │\n  │  │  Step 3：CAS(*counter, old=5, new=6)        │                   │\n  │  │  ├─ *counter 仍為 5 → 交換成功，counter=6         │                   │\n  │  │  │   ✅ done                                │                   │\n  │  │  └─ *counter 已改（別的執行緒改為 6）                 │                   │\n  │  │      ❌ 失敗 → 回到 Step 1 重試                   │                   │
n5=&gt;operation:   │  └─────────────────────────────────────────────┘                  │\n  │                                                                   │\n  │  高競爭下的問題：                                                         │\n  │  ┌─────────────────────────────────────────────┐                  │\n  │  │  T1 讀 old=5 ─────────────────────────────► │                   │\n  │  │  T2 讀 old=5 → CAS 成功(5→6)                  │                   │
n6=&gt;operation:   │  │  T3 讀 old=5 → CAS 失敗，重試                    │                   │\n  │  │  T4 讀 old=5 → CAS 失敗，重試                    │                   │\n  │  │  T1      → CAS 失敗，重試                       │                   │\n  │  │  ...N 個執行緒競爭，每輪只有 1 個成功                    │                   │\n  │  │  自旋 CPU 浪費 ∝ 執行緒數量                         │                   │\n  │  └─────────────────────────────────────────────┘                  │
n7=&gt;operation:   │  解法：LongAdder（分段計數，減少競爭）                                          │\n  └───────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: do {\n  old = load(x)\n  new = old + 1\n} while (!CAS(x, old, new))
st-&gt;n1
</code></pre>
<h2 id="104-aba-問題對應-10411043"><a class="header" href="#104-aba-問題對應-10411043">10.4 ABA 問題（對應 10.4.1~10.4.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-43"><a class="header" href="#本小節示意圖-43">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   ABA 問題時間軸與帶版本號解法\n  ════════════════════════════════════════════════════════\n　\n  問題：CAS 只比較值，不感知中間的變化\n　\n  Thread T1                   Thread T2
n2=&gt;operation:   ─────────────────           ─────────────────────────\n  read: *addr = A             （暫停）\n  （準備 CAS A → B）\n        │\n        │                     read: *addr = A\n        │                     CAS(*addr, A, B) → 成功
n3=&gt;operation:         │                     *addr = B\n        │\n        │                     read: *addr = B\n        │                     CAS(*addr, B, A) → 成功\n        │                     *addr = A  ← 改回 A\n        │
n4=&gt;operation:         ▼\n  CAS(*addr, A, B)            （T1 繼續執行）\n  ← *addr 仍為 A，CAS 成功！\n  但 A 其實已經歷了 A→B→A 的變化\n  ⚠ T1 誤以為「什麼都沒發生」，中間的 B 被忽略\n　
n5=&gt;operation:   ABA 問題的後果：\n  ┌────────────────────────────────────────────────────────┐\n  │  無鎖棧場景（stack pop + push）：                              │\n  │  T1 準備 pop A（讀到 head=A, next=B）                        │\n  │  T2 pop A, pop B, push A（棧頂還是A，但B丟失）                   │\n  │  T1 CAS(head, A, B) 成功，但 B 已經不在棧裡！                     │
n6=&gt;operation:   │  → 棧結構損壞                                               │\n  └────────────────────────────────────────────────────────┘\n　\n  解法：帶版本號的 CAS（Double-CAS / Stamped Reference）\n　\n  時間軸（帶版本號）：
n7=&gt;operation:   ┌────────────────────────────────────────────────────────┐\n  │                                                        │\n  │  初始：(value=A, version=v1)                              │\n  │                                                        │\n  │  Thread T1                   Thread T2                 │\n  │  ─────────────────           ────────────────────      │
n8=&gt;operation:   │  read: (A, v1)               read: (A, v1)             │\n  │  （準備 CAS）                                              │\n  │                              CAS((A,v1),(B,v2))→成功     │\n  │                              state: (B, v2)            │\n  │                                                        │\n  │                              CAS((B,v2),(A,v3))→成功     │
n9=&gt;operation:   │                              state: (A, v3)  ← 版本不同    │\n  │                                                        │\n  │  CAS((A,v1),(B,v2))                                    │\n  │  當前: (A, v3) ≠ expected: (A, v1)                       │\n  │  → CAS 失敗！❌                                            │\n  │  → T1 重新讀取，感知到 ABA 變化                                  │
n10=&gt;operation:   │                                                        │\n  │  版本號每次修改單調遞增，即使值迴圈也能區分                                 │\n  │  (A,v1) → (B,v2) → (A,v3)   v3 ≠ v1                    │\n  └────────────────────────────────────────────────────────┘\n　\n  各語言帶版本號的實現：
n11=&gt;operation:   ┌────────────────────────────────────────────────────────┐\n  │  Java:  AtomicStampedReference&lt;V&gt;                      │\n  │         compareAndSet(expect, update, stamp, newStamp) │\n  │                                                        │\n  │  C++:   std::atomic&lt;std::pair&lt;T,int&gt;&gt;（128-bit CAS）     │\n  │         或自訂 tagged pointer                             │
n12=&gt;operation:   │                                                        │\n  │  Rust:  AtomicU64（將 value 和 version 打包）                │\n  │                                                        │\n  │  Go:    sync/atomic.CompareAndSwapUint64（打包）           │\n  └────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
n10-&gt;n11
n11-&gt;n12
</code></pre>
<p>A-&gt;B-&gt;A 會讓 CAS 誤判「沒變過」。</p>
<p>解法：加版本號（stamp/tagged pointer）。</p>
<h2 id="示意圖-9"><a class="header" href="#示意圖-9">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: loop:\n  old = load\n  new = f(old)\n  if CAS(old,new) 成功 → done\n  else → retry
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-9"><a class="header" href="#跨語言完整範例-9">跨語言完整範例</a></h2>
<p>主題：CAS 計數器（多執行緒自旋遞增，對比 mutex 版本）</p>
<h3 id="cc11-atomiccas-自旋"><a class="header" href="#cc11-atomiccas-自旋">C（C11 atomic，CAS 自旋）</a></h3>
<pre><code class="language-c">// 編譯：gcc -std=c11 -pthread -o ch10_c ch10.c
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;

#define THREADS 4
#define INCREMENTS 10000

static atomic_int counter = ATOMIC_VAR_INIT(0);

void *cas_worker(void *arg) {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        int old, new_val;
        do {
            old = atomic_load_explicit(&amp;counter, memory_order_relaxed);
            new_val = old + 1;
        } while (!atomic_compare_exchange_weak_explicit(
                     &amp;counter, &amp;old, new_val,
                     memory_order_relaxed, memory_order_relaxed));
    }
    return NULL;
}

int main(void) {
    pthread_t threads[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;threads[i], NULL, cas_worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(threads[i], NULL);
    printf("counter = %d (expected %d)\n",
           atomic_load(&amp;counter), THREADS * INCREMENTS);
    return 0;
}
</code></pre>
<h3 id="cstdatomic-compare_exchange_weak-1"><a class="header" href="#cstdatomic-compare_exchange_weak-1">C++（std::atomic compare_exchange_weak）</a></h3>
<pre><code class="language-cpp">// 編譯：g++ -std=c++17 -pthread -o ch10_cpp ch10.cpp
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

constexpr int THREADS = 4;
constexpr int INCREMENTS = 10000;

static std::atomic&lt;int&gt; counter{0};

void cas_worker() {
    for (int i = 0; i &lt; INCREMENTS; i++) {
        int old = counter.load(std::memory_order_relaxed);
        while (!counter.compare_exchange_weak(
                   old, old + 1,
                   std::memory_order_relaxed)) {
            // old 自動被 compare_exchange_weak 更新為當前值
        }
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; THREADS; i++)
        threads.emplace_back(cas_worker);
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; THREADS * INCREMENTS &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rustatomici32-fetch_add-vs-compare_exchange"><a class="header" href="#rustatomici32-fetch_add-vs-compare_exchange">Rust（AtomicI32 fetch_add vs compare_exchange）</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行：cargo run 或 rustc ch10.rs &amp;&amp; ./ch10
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use std::thread;

const THREADS: usize = 4;
const INCREMENTS: usize = 10_000;

fn main() {
    let counter = Arc::new(AtomicI32::new(0));
    let mut handles = Vec::new();

    for _ in 0..THREADS {
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..INCREMENTS {
                // CAS 自旋遞增
                let mut old = counter.load(Ordering::Relaxed);
                loop {
                    match counter.compare_exchange_weak(
                        old, old + 1,
                        Ordering::Relaxed, Ordering::Relaxed)
                    {
                        Ok(_) =&gt; break,
                        Err(cur) =&gt; old = cur, // 更新 old 後重試
                    }
                }
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected {})",
             counter.load(Ordering::SeqCst),
             THREADS * INCREMENTS);
}</code></pre></pre>
<h3 id="gosyncatomic-compareandswap-1"><a class="header" href="#gosyncatomic-compareandswap-1">Go（sync/atomic CompareAndSwap）</a></h3>
<pre><code class="language-go">// 執行：go run ch10.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

const (
	threads    = 4
	increments = 10000
)

func main() {
	var counter int64
	var wg sync.WaitGroup

	for i := 0; i &lt; threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j &lt; increments; j++ {
				// CAS 自旋遞增
				for {
					old := atomic.LoadInt64(&amp;counter)
					if atomic.CompareAndSwapInt64(&amp;counter, old, old+1) {
						break // CAS 成功退出
					}
					// 失敗則重試（old 在下次 Load 時更新）
				}
			}
		}()
	}
	wg.Wait()
	fmt.Printf("counter = %d (expected %d)\n", counter, threads*increments)
}
</code></pre>
<h3 id="python模擬-caslock-保護原子性"><a class="header" href="#python模擬-caslock-保護原子性">Python（模擬 CAS，Lock 保護原子性）</a></h3>
<pre><code class="language-python"># 執行：python3 ch10.py
import threading

THREADS = 4
INCREMENTS = 10000

class AtomicInt:
    def __init__(self, initial=0):
        self._val = initial
        self._lock = threading.Lock()

    def load(self):
        return self._val

    def compare_and_swap(self, expected, new_val):
        with self._lock:
            if self._val == expected:
                self._val = new_val
                return True
            return False

counter = AtomicInt(0)

def cas_worker():
    for _ in range(INCREMENTS):
        while True:
            old = counter.load()
            if counter.compare_and_swap(old, old + 1):
                break  # CAS 成功

if __name__ == "__main__":
    ts = [threading.Thread(target=cas_worker) for _ in range(THREADS)]
    for t in ts: t.start()
    for t in ts: t.join()
    print(f"counter = {counter.load()} (expected {THREADS * INCREMENTS})")
</code></pre>
<h2 id="完整專案級範例python-9"><a class="header" href="#完整專案級範例python-9">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch10.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch10.py
</code></pre>
<pre><code class="language-python">"""Chapter 10: CAS increment loop."""
import threading


class AtomicInt:
    def __init__(self):
        self.v = 0
        self.m = threading.Lock()

    def cas(self, expect: int, new: int) -&gt; bool:
        with self.m:
            if self.v == expect:
                self.v = new
                return True
            return False


if __name__ == "__main__":
    a = AtomicInt()
    for _ in range(5):
        while True:
            old = a.v
            if a.cas(old, old + 1):
                break
    print("value=", a.v)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第11章-死鎖"><a class="header" href="#第11章-死鎖">第11章 死鎖</a></h1>
<h2 id="111-死鎖定義"><a class="header" href="#111-死鎖定義">11.1 死鎖定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-44"><a class="header" href="#本小節示意圖-44">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   資源分配圖：循環等待形成死鎖\n　\n  ┌─────────────┐         ┌─────────────┐\n  │  Thread T1  │         │  Thread T2  │\n  └──────┬──────┘         └──────┬──────┘\n         │ 持有(hold)              │ 持有(hold)
n2=&gt;operation:          ▼                        ▼\n  ┌─────────────┐         ┌─────────────┐\n  │  Resource A │         │  Resource B │\n  └─────────────┘         └─────────────┘\n         ▲                        ▲\n         │ 等待(wait)              │ 等待(wait)
n3=&gt;operation:   ┌──────┴──────┐         ┌──────┴──────┐\n  │  Thread T2  │         │  Thread T1  │\n  └─────────────┘         └─────────────┘\n　\n  T1 → 持有 A，等待 B\n  T2 → 持有 B，等待 A
n4=&gt;operation:   ↔ 形成有向循環 ⇒ 永遠無法推進 ⇒ 死鎖
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
</code></pre>
<p>兩個或以上執行緒互相等待對方釋放資源，永遠走不下去。</p>
<p>死鎖（Deadlock）是指一組執行緒陷入永久等待的狀態：每個執行緒都在等待另一個執行緒持有的資源，而那個執行緒也在等待更多資源，形成一個閉合的等待環。作業系統無法自動解除這種僵局，程式將永久掛起。</p>
<h2 id="112-演化過程對應-11211123"><a class="header" href="#112-演化過程對應-11211123">11.2 演化過程（對應 11.2.1~11.2.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-45"><a class="header" href="#本小節示意圖-45">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   時間軸：安全狀態 → 不安全狀態 → 死鎖\n　\n  時間點   Thread T1              Thread T2            系統狀態\n  ──────   ──────────────────     ──────────────────   ────────────\n   t0      (就緒)                 (就緒)               ✅ 安全\n　
n2=&gt;operation:    t1      lock(A) ✓              lock(B) ✓            ⚠️  危險\n           [持有 A]               [持有 B]\n　\n   t2      try lock(B) → 阻塞     try lock(A) → 阻塞   🔴 不安全\n           [持有 A，等 B]         [持有 B，等 A]\n           ╔══════════╗           ╔══════════╗
n3=&gt;operation:            ║  WAITING ║           ║  WAITING ║\n           ╚══════════╝           ╚══════════╝\n　\n   t3      ████████████           ████████████         💀 死鎖\n           (永遠等待)              (永遠等待)\n           CPU 佔用 0%，但無法繼續
n4=&gt;operation: 　\n  ──────────────────────────────────────────────────────\n  關鍵轉折：t1→t2 時，兩個執行緒都已「持有資源並等待」\n  一旦形成循環，無外部干預則永不解除
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
</code></pre>
<p>不安全排程 + 資源競用，逐步滑向死鎖。</p>
<p>死鎖的形成通常是逐步的：系統從安全狀態出發，隨著執行緒依序取得部分資源，進入不安全狀態，最終當所有執行緒都在等待對方持有的資源時，死鎖完成。</p>
<h2 id="113-四必要條件"><a class="header" href="#113-四必要條件">11.3 四必要條件</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-46"><a class="header" href="#本小節示意圖-46">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   死鎖四必要條件（缺一不可）\n　\n  ┌──────────────────────────────────────────────────────────────────────────────────────────────┐\n  │  條件一：互斥（Mutual Exclusion）                                                                    │\n  │                                                                                              │\n  │  ┌────────┐    只能一人使用    ┌────────────┐                                                      │
n2=&gt;operation:   │  │ T1佔用 │ ────────────────► │   廁所     │ ◄── T2 被擋在外                                         │\n  │  └────────┘                   │（互斥資源）│                                                       │\n  │                               └────────────┘                                                 │\n  │  白話：廁所同時只能一個人用，資源不能共享                                                                        │\n  └──────────────────────────────────────────────────────────────────────────────────────────────┘\n　
n3=&gt;operation:   ┌──────────────────────────────────────────────────────────────────────────────────────────────┐\n  │  條件二：持有且等待（Hold and Wait）                                                                    │\n  │                                                                                              │\n  │  ┌──────────────────────────┐                                                                │\n  │                               │ T1 手握 Lock A           │                                     │\n  │                               │      └→ 還要申請 Lock B  │  ← 不先放 A，直接等 B                        │
n4=&gt;operation:   │  └──────────────────────────┘                                                                │\n  │  白話：手拿叉子，還要等筷子，但不肯放叉子                                                                        │\n  └──────────────────────────────────────────────────────────────────────────────────────────────┘\n　\n  ┌──────────────────────────────────────────────────────────────────────────────────────────────┐\n  │  條件三：不可剝奪（No Preemption）                                                                     │
n5=&gt;operation:   │                                                                                              │\n  │  OS/排程器 ─✗→ 強制搶走 T1 的 Lock A                                                                 │\n  │                                                                                              │\n  │  只有 T1 自己 release() 才能釋放，外力無法強取                                                              │\n  │  白話：手裡的漢堡不能被別人硬搶走                                                                            │\n  └──────────────────────────────────────────────────────────────────────────────────────────────┘
n6=&gt;operation: 　\n  ┌──────────────────────────────────────────────────────────────────────────────────────────────┐\n  │  條件四：循環等待（Circular Wait）                                                                     │\n  │                                                                                              │\n  │       T1 ──等待──► Lock B (被 T2 持有)                                                            │\n  │        ▲                    │                                                                │
n7=&gt;operation:   │        │                    ▼                                                                │\n  │       Lock A ◄──等待── T2                                                                      │\n  │  (被 T1 持有)                                                                                   │\n  │                                                                                              │\n  │  白話：A 等 B，B 等 A，繞成一個圈                                                                        │\n  └──────────────────────────────────────────────────────────────────────────────────────────────┘
n8=&gt;operation: 　\n  ⚡ 破壞任一條件即可預防死鎖！
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>死鎖的四個必要條件：</p>
<ul>
<li><strong>互斥</strong>：資源在某時刻只能被一個執行緒佔用</li>
<li><strong>持有且等待</strong>：執行緒持有至少一個資源，同時等待獲取其他執行緒持有的資源</li>
<li><strong>不可剝奪</strong>：已分配的資源不能被強制奪走，只能由持有者主動釋放</li>
<li><strong>循環等待</strong>：存在一個執行緒等待鏈，形成閉合迴路</li>
</ul>
<p>四個條件缺一不可，破壞其中任何一個即可預防死鎖。</p>
<h2 id="114-預防與處理"><a class="header" href="#114-預防與處理">11.4 預防與處理</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-47"><a class="header" href="#本小節示意圖-47">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   三種策略對比\n　\n  ┌──────────────────┬───────────────────────────┬─────────────────────────────────────────┐\n  │     策略           │        做法                 │   代價 / 適用場景                             │\n  ├──────────────────┼───────────────────────────┼─────────────────────────────────────────┤\n  │ 固定加鎖順序           │ 所有執行緒按相同順序加鎖              │ 代價：需全局規劃順序                              │
n2=&gt;operation:   │                  │                           │ 適用：鎖數量固定、                               │\n  │ T1: lock(A→B)    │  ┌──┐    ┌──┐             │       關係清晰                              │\n  │ T2: lock(A→B)    │  │A │───►│B       │            │                                    │\n  │ (不再交叉)           │  └──┘    └──┘             │ ✅ 最可靠                                   │\n  ├──────────────────┼───────────────────────────┼─────────────────────────────────────────┤\n  │ tryLock + 逾時     │ 嘗試加鎖，超過期限就放棄              │ 代價：需處理失敗重試                              │
n3=&gt;operation:   │                  │                           │ 適用：鎖等待時間可                               │\n  │ if tryLock(B,    │  ┌───────────────┐        │       預期、業務允                            │\n  │   100ms):        │  │嘗試 100ms 後  │        │       許重試                                  │\n  │   use B          │  │放棄，釋放 A     │        │                                            │\n  │ else:            │  └───────────────┘        │ ⚠️  可能活鎖                                │\n  │   release A      │                           │                                         │
n4=&gt;operation:   ├──────────────────┼───────────────────────────┼─────────────────────────────────────────┤\n  │ 縮小持鎖範圍           │ 盡量縮短持鎖時間                  │ 代價：需重新設計邏輯                              │\n  │                  │                           │ 適用：業務邏輯可拆                               │\n  │ 只在讀寫共享           │  ┌──────────────────────┐ │       分、IO操作多                           │\n  │ 資料時持鎖，           │  │lock │ op │ unlock    │ │                                         │\n  │ IO 等慢操作移出        │  └──────────────────────┘ │ ✅ 提升整體吞吐量                               │
n5=&gt;operation:   │ 臨界區外             │   短   短   短               │                                         │\n  └──────────────────┴───────────────────────────┴─────────────────────────────────────────┘\n　\n  死鎖偵測與恢復（補救手段）：\n  ┌────────────────────────────────────────────────────────────────────────────────────────┐\n  │  偵測：定期掃描資源分配圖，尋找循環                                                                     │
n6=&gt;operation:   │  恢復：選擇犧牲者（victim）→ 強制回滾或終止，釋放其資源                                                       │\n  │  適用：資料庫系統（如 MySQL 死鎖偵測）                                                                │\n  └────────────────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>三種主流預防策略：</p>
<ul>
<li><strong>固定鎖順序</strong>：所有執行緒按相同的全局排序依序加鎖，確保不存在循環等待</li>
<li><strong><code>tryLock</code> + timeout</strong>：嘗試加鎖，超時後放棄並釋放已持有的鎖，待稍後重試</li>
<li><strong>減少持鎖時間</strong>：將不需要持鎖的操作（如 I/O、計算）移到臨界區外，降低衝突視窗</li>
</ul>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: T1: lock(A) → wait(B)\nT2: lock(B) → wait(A)\n⇒ deadlock\n　\n修正後（固定順序）:\nT1: lock(A) → lock(B) → unlock(B) → unlock(A)
n2=&gt;operation: T2: lock(A) → lock(B) → unlock(B) → unlock(A)\n⇒ 不再有循環，死鎖不可能發生
st-&gt;n1
n1-&gt;n2
</code></pre>
<h2 id="跨語言完整範例-10"><a class="header" href="#跨語言完整範例-10">跨語言完整範例</a></h2>
<p>固定加鎖順序避免死鎖：兩把鎖按 id 排序後加鎖，無論執行緒以何種順序呼叫，都不會形成循環等待。</p>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch11_c ch11.c &amp;&amp; ./ch11_c */
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

typedef struct { int id; pthread_mutex_t mu; } Lock;

/* 按 id 排序後加鎖，破壞循環等待條件 */
void lock_ordered(Lock *a, Lock *b) {
    if (a-&gt;id &lt; b-&gt;id) {
        pthread_mutex_lock(&amp;a-&gt;mu);
        pthread_mutex_lock(&amp;b-&gt;mu);
    } else {
        pthread_mutex_lock(&amp;b-&gt;mu);
        pthread_mutex_lock(&amp;a-&gt;mu);
    }
}

void unlock_ordered(Lock *a, Lock *b) {
    pthread_mutex_unlock(&amp;a-&gt;mu);
    pthread_mutex_unlock(&amp;b-&gt;mu);
}

Lock res_a = {0, PTHREAD_MUTEX_INITIALIZER};
Lock res_b = {1, PTHREAD_MUTEX_INITIALIZER};
int shared = 0;

void *thread_fn(void *arg) {
    int id = *(int *)arg;
    for (int i = 0; i &lt; 5; i++) {
        lock_ordered(&amp;res_a, &amp;res_b);
        shared++;
        printf("Thread %d: shared = %d\n", id, shared);
        unlock_ordered(&amp;res_a, &amp;res_b);
        usleep(1000);
    }
    return NULL;
}

int main(void) {
    pthread_t t1, t2;
    int id1 = 1, id2 = 2;
    pthread_create(&amp;t1, NULL, thread_fn, &amp;id1);
    pthread_create(&amp;t2, NULL, thread_fn, &amp;id2);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Final shared = %d\n", shared);
    return 0;
}
</code></pre>
<h3 id="c-1"><a class="header" href="#c-1">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch11_cpp ch11.cpp &amp;&amp; ./ch11_cpp
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

struct OrderedLock {
    int id;
    std::mutex mu;
};

// std::scoped_lock 內部用 std::lock() 實作死鎖安全加鎖
void transfer(OrderedLock &amp;from, OrderedLock &amp;to, int &amp;counter) {
    std::scoped_lock lk(from.mu, to.mu);   // 同時安全地鎖兩把
    counter++;
    std::cout &lt;&lt; "transferred, counter=" &lt;&lt; counter &lt;&lt; "\n";
}

int main() {
    OrderedLock account_a{0, {}};
    OrderedLock account_b{1, {}};
    int counter = 0;
    std::mutex cout_mu;

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++) {
        // 奇偶執行緒使用不同方向，但 scoped_lock 保證不死鎖
        if (i % 2 == 0)
            threads.emplace_back(transfer, std::ref(account_a),
                                 std::ref(account_b), std::ref(counter));
        else
            threads.emplace_back(transfer, std::ref(account_b),
                                 std::ref(account_a), std::ref(counter));
    }
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "Final counter=" &lt;&lt; counter &lt;&lt; "\n";
    return 0;
}
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch11.rs &amp;&amp; ./ch11
use std::sync::{Arc, Mutex};
use std::thread;

struct Resource {
    id: u32,
    data: Mutex&lt;i32&gt;,
}

// 按 id 排序後取鎖，確保全局順序
fn locked_update(a: &amp;Resource, b: &amp;Resource) {
    let (first, second) = if a.id &lt; b.id { (a, b) } else { (b, a) };
    let mut g1 = first.data.lock().unwrap();
    let mut g2 = second.data.lock().unwrap();
    *g1 += 1;
    *g2 += 1;
    println!("updated: res[{}]={}, res[{}]={}", first.id, *g1, second.id, *g2);
}

fn main() {
    let res_a = Arc::new(Resource { id: 0, data: Mutex::new(0) });
    let res_b = Arc::new(Resource { id: 1, data: Mutex::new(0) });

    let handles: Vec&lt;_&gt; = (0..4).map(|i| {
        let (a, b) = (Arc::clone(&amp;res_a), Arc::clone(&amp;res_b));
        thread::spawn(move || {
            // 一半執行緒傳 (a,b)，另一半傳 (b,a)，但排序保證安全
            if i % 2 == 0 { locked_update(&amp;a, &amp;b); }
            else           { locked_update(&amp;b, &amp;a); }
        })
    }).collect();

    for h in handles { h.join().unwrap(); }
    println!("Done, no deadlock.");
}</code></pre></pre>
<h3 id="go"><a class="header" href="#go">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch11.go
package main

import (
	"fmt"
	"sync"
)

type Resource struct {
	id int
	mu sync.Mutex
}

// 按 id 排序加鎖，破壞循環等待
func lockedTransfer(a, b *Resource, counter *int, mu *sync.Mutex) {
	first, second := a, b
	if a.id &gt; b.id {
		first, second = b, a
	}
	first.mu.Lock()
	second.mu.Lock()
	defer first.mu.Unlock()
	defer second.mu.Unlock()

	mu.Lock()
	*counter++
	fmt.Printf("transfer done, counter=%d\n", *counter)
	mu.Unlock()
}

func main() {
	resA := &amp;Resource{id: 0}
	resB := &amp;Resource{id: 1}
	counter := 0
	var printMu sync.Mutex
	var wg sync.WaitGroup

	for i := 0; i &lt; 8; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			if i%2 == 0 {
				lockedTransfer(resA, resB, &amp;counter, &amp;printMu)
			} else {
				lockedTransfer(resB, resA, &amp;counter, &amp;printMu)
			}
		}(i)
	}
	wg.Wait()
	fmt.Printf("Final counter=%d, no deadlock!\n", counter)
}
</code></pre>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch11.py
import threading
import time


class OrderedLock:
    def __init__(self, lock_id: int):
        self.id = lock_id
        self.mu = threading.Lock()


def locked_transfer(a: OrderedLock, b: OrderedLock, counter: list):
    """按 id 排序後加鎖，確保不形成循環等待。"""
    first, second = (a, b) if a.id &lt; b.id else (b, a)
    with first.mu:
        time.sleep(0.001)          # 模擬工作，增加競爭機會
        with second.mu:
            counter[0] += 1
            print(f"Thread {threading.current_thread().name}: "
                  f"counter={counter[0]}")


if __name__ == "__main__":
    res_a = OrderedLock(0)
    res_b = OrderedLock(1)
    counter = [0]

    threads = []
    for i in range(8):
        # 奇偶執行緒傳入順序相反，但 ordered lock 保證安全
        if i % 2 == 0:
            t = threading.Thread(target=locked_transfer,
                                 args=(res_a, res_b, counter), name=f"T{i}")
        else:
            t = threading.Thread(target=locked_transfer,
                                 args=(res_b, res_a, counter), name=f"T{i}")
        threads.append(t)
        t.start()

    for t in threads:
        t.join()
    print(f"Final counter={counter[0]}, no deadlock!")
</code></pre>
<h2 id="完整專案級範例python-10"><a class="header" href="#完整專案級範例python-10">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch11.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch11.py
</code></pre>
<pre><code class="language-python">"""Chapter 11: deadlock avoidance via timeout and ordered locking."""
import threading
import time

A = threading.Lock()
B = threading.Lock()


def worker1():
    """持有 A 後嘗試取 B，超時則主動放棄避免死鎖。"""
    with A:
        time.sleep(0.05)
        if B.acquire(timeout=0.1):
            print("w1 got B")
            B.release()
        else:
            print("w1 timeout on B — 避免死鎖，稍後重試")


def worker2():
    """持有 B 後嘗試取 A，超時則主動放棄避免死鎖。"""
    with B:
        time.sleep(0.05)
        if A.acquire(timeout=0.1):
            print("w2 got A")
            A.release()
        else:
            print("w2 timeout on A — 避免死鎖，稍後重試")


if __name__ == "__main__":
    t1 = threading.Thread(target=worker1)
    t2 = threading.Thread(target=worker2)
    t1.start(); t2.start(); t1.join(); t2.join()
    print("程式正常結束，無死鎖")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第12章-鎖優化"><a class="header" href="#第12章-鎖優化">第12章 鎖優化</a></h1>
<h2 id="121123-縮小鎖粒度"><a class="header" href="#121123-縮小鎖粒度">12.1~12.3 縮小鎖粒度</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-48"><a class="header" href="#本小節示意圖-48">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   縮小鎖粒度：粗鎖 vs 細鎖\n　\n  ╔══════════════════════════════════════════════════════════════╗\n  ║  BEFORE：一把大鎖保護整個 Map                                ║\n  ╚══════════════════════════════════════════════════════════════╝\n　
n2=&gt;operation:   Thread A (讀 k1)  ──┐\n  Thread B (寫 k7)  ──┤──► 爭搶同一把 GlobalLock ──► Map\n  Thread C (讀 k3)  ──┤\n  Thread D (寫 k9)  ──┘\n         │\n         ▼
n3=&gt;operation:   衝突概率 = P(任意兩個操作重疊) ≈ 很高\n  同一時刻只有 1 個執行緒能進入 Map\n　\n  ╔══════════════════════════════════════════════════════════════╗\n  ║  AFTER：每個 bucket 一把鎖                                   ║\n  ╚══════════════════════════════════════════════════════════════╝
n4=&gt;operation: 　\n  Thread A (讀 k1) ──► Lock[bucket_0] ──► bucket[0]: {k1,k2,...}\n  Thread B (寫 k7) ──► Lock[bucket_1] ──► bucket[1]: {k7,k8,...}\n  Thread C (讀 k3) ──► Lock[bucket_0] ──► bucket[0]: {k3,...}\n  Thread D (寫 k9) ──► Lock[bucket_2] ──► bucket[2]: {k9,...}\n         │
n5=&gt;operation:          ▼\n  A 和 C 競爭 bucket_0（才衝突）\n  B 和 D 各用不同 bucket（完全並行）\n　\n  衝突概率 = P(兩操作落在同一 bucket) ≈ 1/N（N 為 bucket 數）\n  並發度從 1 提升到接近 bucket 數量
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>粗鎖改細鎖，減少不必要互斥。</p>
<p>鎖粒度（Lock Granularity）指的是一把鎖所保護的資料範圍。粗粒度鎖（如保護整個 Map）易於實作但並發度低；細粒度鎖（如每個 bucket 一把鎖）提升並發，但設計複雜度也上升。核心原則：<strong>只鎖真正需要保護的最小資料範圍</strong>。</p>
<h2 id="124126-分段與分離"><a class="header" href="#124126-分段與分離">12.4~12.6 分段與分離</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-49"><a class="header" href="#本小節示意圖-49">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   分段鎖（Sharded Lock）：key hash % 16 → shard[i]\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │                    Sharded Map（16 個分片）                        │\n  ├───────────────────────────────────────────────────────────────┤\n  │                                                               │
n2=&gt;operation:   │  key ──► hash(key) % 16 ──► 選擇分片                              │\n  │                                                               │\n  │   Shard[0]  ┌──────────┐  Lock[0]  ← Thread A                 │\n  │             │ {k0,...} │                                      │\n  │   Shard[1]  ├──────────┤  Lock[1]  ← Thread B (同時並行)          │\n  │             │ {k1,...} │                                      │
n3=&gt;operation:   │   Shard[2]  ├──────────┤  Lock[2]  ← Thread C (同時並行)          │\n  │             │ {k2,...} │                                      │\n  │      ⋮      │    ⋮     │    ⋮                                 │\n  │   Shard[15] ├──────────┤  Lock[15] ← Thread P (同時並行)          │\n  │             │ {k15,..} │                                      │\n  │             └──────────┘                                      │
n4=&gt;operation:   │                                                               │\n  │  並發度：最多 16 個執行緒同時操作不同分片（互不阻塞）                                 │\n  │  衝突只發生在：兩個 key 的 hash%16 值相同時                                 │\n  │                                                               │\n  │  對比單一全域鎖：並發度提升 ≈ 16 倍（理論上限）                                   │\n  └───────────────────────────────────────────────────────────────┘
n5=&gt;operation: 　\n  白話例子：\n  超商單一結帳櫃台 → 16 個自助結帳機\n  顧客分散到不同機台，排隊時間大幅縮短
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>把一把全域鎖拆成多段（striped/sharded lock）。</p>
<p>分段鎖是縮小鎖粒度的極致應用：將資料結構按某種規則（通常是 key 的 hash 值）切分為多個 shard，每個 shard 有獨立的鎖。操作時只鎖對應的 shard，其他 shard 的操作完全不受影響，理論並發度為 shard 數量。</p>
<h2 id="127129-其他策略"><a class="header" href="#127129-其他策略">12.7~12.9 其他策略</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-50"><a class="header" href="#本小節示意圖-50">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   鎖策略決策樹\n　\n  開始評估並發策略\n         │\n         ▼\n  讀操作遠多於寫操作？
n2=&gt;operation:   ├── 是 ──► 使用讀寫鎖（RWLock / shared_mutex）\n  │          多個讀者同時進入，只有寫者互斥\n  │          適用：配置讀取、快取查詢\n  │\n  └── 否 ──► 操作是否無衝突（CAS 能完成）？\n             ├── 是 ──► 樂觀鎖 / 原子 CAS（lock-free）
n3=&gt;operation:              │          適用：計數器、狀態機、無競爭更新\n             │\n             └── 否 ──► 高吞吐量場景？\n                        ├── 是 ──► 分段鎖（Sharded Lock）\n                        │          適用：並發 Map、並發計數器\n                        │
n4=&gt;operation:                         └── 否 ──► 需要公平性（FIFO 順序）？\n                                   ├── 是 ──► 公平鎖（Fair Lock）\n                                   │          避免飢餓，代價：吞吐略低\n                                   │\n                                   └── 否 ──► 執行緒本地資料夠用？\n                                              ├── 是 ──► ThreadLocal
n5=&gt;operation:                                               │          完全消除鎖競爭\n                                              └── 否 ──► 普通互斥鎖\n                                                         + 縮小持鎖範圍
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>其他常見鎖優化策略：</p>
<ul>
<li><strong>降低持鎖時間</strong>：將 I/O、複雜計算移到臨界區外，只在真正需要保護的最小程式碼段持鎖</li>
<li><strong>熱點隔離</strong>：高頻訪問的共享計數器可用 per-CPU 計數器或 LongAdder 模式，最後再匯總</li>
<li><strong>讀寫分離</strong>：讀多寫少場景用 <code>RWMutex</code>，允許多個讀者並行，只有寫者獨佔</li>
<li><strong>優先無鎖結構</strong>：原子操作（CAS）、無鎖佇列在低競爭場景下比鎖更快</li>
</ul>
<p>白話例子：超商單一結帳櫃台改 16 個櫃台，隊伍自然變短。</p>
<h2 id="跨語言完整範例-11"><a class="header" href="#跨語言完整範例-11">跨語言完整範例</a></h2>
<p>分段鎖 Map：SHARDS=8，按 key hash 選鎖，多執行緒並發寫入，對比全域鎖展示吞吐量差異。</p>
<h3 id="c-2"><a class="header" href="#c-2">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch12_c ch12.c &amp;&amp; ./ch12_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define SHARDS   8
#define ITERS    100000
#define THREADS  4

typedef struct { long count; pthread_mutex_t mu; } Shard;

Shard shards[SHARDS];

static unsigned int hash_key(int key) {
    return (unsigned int)key * 2654435761u;
}

void shard_inc(int key) {
    int idx = hash_key(key) % SHARDS;
    pthread_mutex_lock(&amp;shards[idx].mu);
    shards[idx].count++;
    pthread_mutex_unlock(&amp;shards[idx].mu);
}

void *worker(void *arg) {
    int base = *(int *)arg;
    for (int i = 0; i &lt; ITERS; i++)
        shard_inc(base * ITERS + i);
    return NULL;
}

int main(void) {
    for (int i = 0; i &lt; SHARDS; i++)
        pthread_mutex_init(&amp;shards[i].mu, NULL);

    pthread_t ts[THREADS];
    int ids[THREADS];
    struct timespec t0, t1;
    clock_gettime(CLOCK_MONOTONIC, &amp;t0);

    for (int i = 0; i &lt; THREADS; i++) {
        ids[i] = i;
        pthread_create(&amp;ts[i], NULL, worker, &amp;ids[i]);
    }
    for (int i = 0; i &lt; THREADS; i++) pthread_join(ts[i], NULL);

    clock_gettime(CLOCK_MONOTONIC, &amp;t1);
    long total = 0;
    for (int i = 0; i &lt; SHARDS; i++) total += shards[i].count;

    long ms = (t1.tv_sec - t0.tv_sec) * 1000 +
              (t1.tv_nsec - t0.tv_nsec) / 1000000;
    printf("total=%ld (expected %d), elapsed=%ldms\n",
           total, THREADS * ITERS, ms);
    return 0;
}
</code></pre>
<h3 id="c-3"><a class="header" href="#c-3">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch12_cpp ch12.cpp &amp;&amp; ./ch12_cpp
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

constexpr int SHARDS  = 8;
constexpr int ITERS   = 100000;
constexpr int THREADS = 4;

struct Shard {
    long count = 0;
    std::mutex mu;
};

Shard shards[SHARDS];

void shard_inc(int key) {
    int idx = std::hash&lt;int&gt;{}(key) % SHARDS;
    std::lock_guard lk(shards[idx].mu);
    shards[idx].count++;
}

int main() {
    std::vector&lt;std::thread&gt; ts;
    for (int i = 0; i &lt; THREADS; i++) {
        ts.emplace_back([i] {
            for (int j = 0; j &lt; ITERS; j++)
                shard_inc(i * ITERS + j);
        });
    }
    for (auto &amp;t : ts) t.join();

    long total = 0;
    for (auto &amp;s : shards) total += s.count;
    std::cout &lt;&lt; "total=" &lt;&lt; total
              &lt;&lt; " (expected=" &lt;&lt; THREADS * ITERS &lt;&lt; ")\n";
    return 0;
}
</code></pre>
<h3 id="rust-1"><a class="header" href="#rust-1">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch12.rs -o ch12 &amp;&amp; ./ch12
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

const SHARDS: usize = 8;
const ITERS: usize = 25000;
const THREADS: usize = 4;

fn hash_shard(key: i32) -&gt; usize {
    let mut h = DefaultHasher::new();
    key.hash(&amp;mut h);
    (h.finish() as usize) % SHARDS
}

fn main() {
    // Arc&lt;Vec&lt;Mutex&lt;i64&gt;&gt;&gt;：共享的分段計數器
    let shards: Arc&lt;Vec&lt;Mutex&lt;i64&gt;&gt;&gt; =
        Arc::new((0..SHARDS).map(|_| Mutex::new(0)).collect());

    let handles: Vec&lt;_&gt; = (0..THREADS).map(|i| {
        let shards = Arc::clone(&amp;shards);
        thread::spawn(move || {
            for j in 0..ITERS {
                let key = (i * ITERS + j) as i32;
                let idx = hash_shard(key);
                *shards[idx].lock().unwrap() += 1;
            }
        })
    }).collect();

    for h in handles { h.join().unwrap(); }

    let total: i64 = shards.iter().map(|s| *s.lock().unwrap()).sum();
    println!("total={} (expected={})", total, THREADS * ITERS);
}</code></pre></pre>
<h3 id="go-1"><a class="header" href="#go-1">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch12.go
package main

import (
	"fmt"
	"hash/fnv"
	"sync"
	"sync/atomic"
)

const shards = 8
const iters = 25000
const workers = 4

type Shard struct {
	mu    sync.Mutex
	count int64
}

var shardMap [shards]Shard

func hashShard(key int) int {
	h := fnv.New32a()
	b := [4]byte{byte(key), byte(key &gt;&gt; 8), byte(key &gt;&gt; 16), byte(key &gt;&gt; 24)}
	h.Write(b[:])
	return int(h.Sum32()) % shards
}

func shardInc(key int) {
	idx := hashShard(key)
	shardMap[idx].mu.Lock()
	shardMap[idx].count++
	shardMap[idx].mu.Unlock()
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i &lt; workers; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			for j := 0; j &lt; iters; j++ {
				shardInc(i*iters + j)
			}
		}(i)
	}
	wg.Wait()

	var total int64
	for i := range shardMap {
		total += atomic.LoadInt64(&amp;shardMap[i].count)
	}
	fmt.Printf("total=%d (expected=%d)\n", total, workers*iters)
}
</code></pre>
<h3 id="python-1"><a class="header" href="#python-1">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch12.py
import threading
import hashlib

SHARDS  = 8
ITERS   = 10000
WORKERS = 4


class ShardedCounter:
    def __init__(self, n_shards: int):
        self.counts = [0] * n_shards
        self.locks  = [threading.Lock() for _ in range(n_shards)]
        self.n      = n_shards

    def increment(self, key: int):
        idx = key % self.n          # 簡單取模作為 hash 函數
        with self.locks[idx]:
            self.counts[idx] += 1

    def total(self) -&gt; int:
        return sum(self.counts)


counter = ShardedCounter(SHARDS)


def worker(worker_id: int):
    for j in range(ITERS):
        counter.increment(worker_id * ITERS + j)


if __name__ == "__main__":
    threads = [threading.Thread(target=worker, args=(i,)) for i in range(WORKERS)]
    for t in threads: t.start()
    for t in threads: t.join()
    print(f"total={counter.total()} (expected={WORKERS * ITERS})")
    print(f"分片分佈: {counter.counts}")
</code></pre>
<h2 id="完整專案級範例python-11"><a class="header" href="#完整專案級範例python-11">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch12.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch12.py
</code></pre>
<pre><code class="language-python">"""Chapter 12: lock sharding — 分段鎖實作與對比。"""
import threading
import time

SHARDS = 8
locks = [threading.Lock() for _ in range(SHARDS)]
data = [0] * SHARDS


def update(key: int):
    """按 key % SHARDS 選擇對應分片的鎖，只鎖該分片。"""
    idx = key % SHARDS
    with locks[idx]:
        data[idx] += 1


if __name__ == "__main__":
    start = time.time()
    ts = [threading.Thread(target=update, args=(i,)) for i in range(10_000)]
    for t in ts: t.start()
    for t in ts: t.join()
    elapsed = time.time() - start
    print(f"sum={sum(data)}, elapsed={elapsed:.3f}s")
    print(f"分片分佈: {data}")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第13章-線程池"><a class="header" href="#第13章-線程池">第13章 線程池</a></h1>
<h2 id="131-狀態與生命週期對應-13111312"><a class="header" href="#131-狀態與生命週期對應-13111312">13.1 狀態與生命週期（對應 13.1.1~13.1.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-51"><a class="header" href="#本小節示意圖-51">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   線程池狀態機\n　\n                    ┌─────────────┐\n               ──►  │   RUNNING   │  ◄── 正常接受任務並處理\n                    └──────┬──────┘\n                           │
n2=&gt;operation:                ┌───────────┴──────────────┐\n               │ shutdown()               │ shutdownNow()\n               ▼                          ▼\n        ┌─────────────┐            ┌────────────────────┐\n        │  SHUTDOWN   │            │    STOP            │\n        │（不收新任務)      │            │（立即中斷）              │
n3=&gt;operation:         │  繼續排隊中      │            │  返回未執行             │\n        │  的舊任務       │            │  任務列表              │\n        └──────┬──────┘            └──────┬─────────────┘\n               │ 佇列清空                  │ workers 停止\n               │ workers 歸零               │\n               └───────────┬──────────────┘
n4=&gt;operation:                             ▼\n                    ┌─────────────┐\n                    │   TIDYING   │  ← 所有任務已完成\n                    │ worker=0    │    呼叫 terminated() hook\n                    └──────┬──────┘\n                            │ terminated() 完成
n5=&gt;operation:                             ▼\n                    ┌─────────────┐\n                    │ TERMINATED  │  ← 最終狀態，資源全部釋放\n                    └─────────────┘\n　\n  注意：狀態只能單向推進，不可逆轉
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>管理執行緒建立、運作、關閉，避免每次任務都開新執行緒。</p>
<p>線程池維護一組預先建立的執行緒，持續從任務佇列取出任務執行。這樣避免了頻繁建立/銷毀執行緒的開銷（每次建立約耗費數十微秒），並提供統一的資源上限，防止系統因過多執行緒而耗盡記憶體。</p>
<h2 id="132-建立方式對應-13211324"><a class="header" href="#132-建立方式對應-13211324">13.2 建立方式（對應 13.2.1~13.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-52"><a class="header" href="#本小節示意圖-52">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   四種線程池類型對比\n　\n  ┌─────────────┬──────────────────┬─────────────────┬──────────────────────────────┐\n  │    類型        │    執行緒數量         │    任務佇列         │    適用場景                     │\n  ├─────────────┼──────────────────┼─────────────────┼──────────────────────────────┤\n  │ Fixed        │ 固定 N 個           │ 無界佇列            │ CPU 密集計算                    │
n2=&gt;operation:   │ Thread Pool  │ 永遠存在             │ LinkedBlocking  │ 任務量穩定                       │\n  │              │                  │ Queue           │ Web 後端服務                    │\n  │              │  [T][T][T][T]    │  [Q─Q─Q─Q─…]    │                             │\n  ├─────────────┼──────────────────┼─────────────────┼──────────────────────────────┤\n  │ Cached       │ 彈性 0~MAX         │ SynchronousQueue│ 短暫突發流量                      │\n  │ Thread Pool  │ 閒置 60s 後回收       │ (容量=0，直接        │ 任務量不可預測                     │
n3=&gt;operation:   │              │                  │  handoff)       │ 但單個任務快                      │\n  │              │  [T]?[T]?[T]?    │  [直接交付]         │                             │\n  ├─────────────┼──────────────────┼─────────────────┼──────────────────────────────┤\n  │ Scheduled    │ 固定核心 N 個         │ DelayedQueue    │ 定時任務排程                      │\n  │ Thread Pool  │ 支援延遲/週期          │ (按時間排序)         │ Cron 類工作                    │\n  │              │                  │                 │ 心跳、清理任務                     │
n4=&gt;operation:   │              │  [T][T] (定時)     │  [t=10s][t=30s] │                             │\n  ├─────────────┼──────────────────┼─────────────────┼──────────────────────────────┤\n  │ ForkJoin     │ N ≈ CPU 核數       │ 每執行緒私有          │ 分治演算法                       │\n  │ Pool         │ 工作竊取（steal)      │ Deque           │ 遞迴並行處理                      │\n  │              │                  │ (可從別人尾部         │ Stream parallel             │\n  │              │  [T]←steal─[T]   │  偷任務)           │                             │
n5=&gt;operation:   └─────────────┴──────────────────┴─────────────────┴──────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>固定池、快取池、排程池、分治池各有適用場景。選錯類型可能導致記憶體耗盡（Cached pool 在爆發流量下無限建執行緒）或效能低下（Fixed pool 在 I/O 密集時執行緒閒置）。</p>
<h2 id="133-提交流程與拒絕策略對應-13311332"><a class="header" href="#133-提交流程與拒絕策略對應-13311332">13.3 提交流程與拒絕策略（對應 13.3.1~13.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-53"><a class="header" href="#本小節示意圖-53">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   submit(task) 完整決策流程\n　\n  submit(task)\n       │\n       ▼\n  ┌─────────────────────────────────────────────┐
n2=&gt;operation:   │ 核心執行緒數 &lt; corePoolSize?                      │\n  └──────────────┬──────────────────────────────┘\n       是 │               │ 否\n          ▼               ▼\n  ┌───────────────┐  ┌──────────────────────────┐\n  │ 新建 Worker   │  │ 任務佇列 queue 未滿？             │
n3=&gt;operation:   │ 執行此任務    │  └────────────┬────────────┘\n  └───────────────┘       是 │            │ 否\n                             ▼            ▼\n                    ┌─────────────┐  ┌──────────────────────────┐\n                    │ 入佇列等待  │  │ 執行緒數 &lt; maxPoolSize?           │\n                    └─────────────┘  └────────────┬─────────────┘
n4=&gt;operation:                                           是 │             │ 否\n                                             ▼             ▼\n                                    ┌──────────────┐  ┌─────────────────────┐\n                                    │ 新建非核心   │  │      拒絕策略                │\n                                    │ Worker 執行  │  ├─────────────────────┤\n                                    └──────────────┘  │ AbortPolicy:拋例外  │
n5=&gt;operation:                                                        │ CallerRunsPolicy:   │\n                                                       │   呼叫者自己跑            │\n                                                       │ DiscardPolicy:靜默    │\n                                                       │ DiscardOldest:丟最    │\n                                                       │   舊的任務              │\n                                                       └─────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>核心是「任務佇列 + 工作執行緒 + 飽和策略」。</p>
<p>任務提交時，線程池按優先級嘗試：先用核心執行緒，再入佇列，再擴展到最大執行緒數，最後觸發拒絕策略。理解這個流程對調參（corePoolSize、maxPoolSize、queueCapacity）至關重要。</p>
<h2 id="134-關閉對應-13411342"><a class="header" href="#134-關閉對應-13411342">13.4 關閉（對應 13.4.1~13.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-54"><a class="header" href="#本小節示意圖-54">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   兩種關閉方式對比\n　\n  ┌────────────────────────────────────────────────────────────────────────────────────┐\n  │  shutdown()：優雅關閉                                                                   │\n  │                                                                                    │\n  │  1. 標記狀態為 SHUTDOWN                                                                 │
n2=&gt;operation:   │  2. 不再接受新的 submit() 呼叫                                                             │\n  │  3. 已在佇列中的任務 ✅ 繼續執行完畢                                                              │\n  │  4. 所有 worker 完成後進入 TERMINATED                                                     │\n  │                                                                                    │\n  │  Timeline:                                                                         │\n  │  ──┬──────────────────────────────────────┬──► 結束                                  │
n3=&gt;operation:   │    │ shutdown()                            │                                       │\n  │    │←── 不接受新任務 ──►│←── 排空佇列 ──►│                                                   │\n  │    │  [Q任務1][Q任務2]  →  執行完畢                │                                       │\n  └────────────────────────────────────────────────────────────────────────────────────┘\n　\n  ┌────────────────────────────────────────────────────────────────────────────────────┐
n4=&gt;operation:   │  shutdownNow()：立即關閉                                                                │\n  │                                                                                    │\n  │  1. 標記狀態為 STOP                                                                     │\n  │  2. 對所有 worker 送出 interrupt() 訊號                                                   │\n  │  3. 佇列中 ❌ 未執行的任務以 List 形式返回給呼叫者                                                    │\n  │  4. 正在執行的任務若響應中斷則提前結束                                                              │
n5=&gt;operation:   │                                                                                    │\n  │  Timeline:                                                                         │\n  │  ──┬────────────────────┬──► 結束                                                    │\n  │    │ shutdownNow()                         │                                       │\n  │    │←── 中斷 workers ──►                     │  返回未執行任務列表                            │\n  │    │  [Q任務1][Q任務2]  ← 取出並返回，不執行                                                    │
n6=&gt;operation:   └────────────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<ul>
<li>優雅關閉（<code>shutdown</code>）：不收新任務，處理完已接收的任務後關閉。</li>
<li>立即關閉（<code>shutdownNow</code>）：嘗試中斷執行中的任務，返回未執行的任務列表。</li>
</ul>
<p>實務上應搭配 <code>awaitTermination(timeout)</code> 等待關閉完成，避免主程式提前退出導致任務被截斷。</p>
<h2 id="135-參數調優對應-13511352"><a class="header" href="#135-參數調優對應-13511352">13.5 參數調優（對應 13.5.1~13.5.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-55"><a class="header" href="#本小節示意圖-55">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   線程數調優公式\n　\n  ┌──────────────────────────────────────────────────────────────┐\n  │  符號定義                                                        │\n  │  N  = CPU 核心數（Runtime.getRuntime().availableProcessors）      │\n  │  WT = 平均等待時間（Wait Time，例如 I/O 等待 900ms）                      │
n2=&gt;operation:   │  ST = 平均服務時間（Service Time，例如 CPU 計算 100ms）                   │\n  └──────────────────────────────────────────────────────────────┘\n　\n  ┌──────────────────────────────────────────────────────────────┐\n  │  CPU 密集型任務（幾乎不等待 I/O）                                        │\n  │                                                              │
n3=&gt;operation:   │  最佳執行緒數 = N + 1                                              │\n  │                                                              │\n  │  +1 的原因：當某執行緒因缺頁中斷等短暫暫停時，                                    │\n  │            額外一個執行緒可立即接手 CPU，避免浪費                             │\n  │                                                              │\n  │  範例：N=8 核 → 推薦 9 個執行緒                                        │
n4=&gt;operation:   └──────────────────────────────────────────────────────────────┘\n　\n  ┌──────────────────────────────────────────────────────────────┐\n  │  I/O 密集型任務（大量等待磁碟/網路）                                        │\n  │                                                              │\n  │  最佳執行緒數 = N × (1 + WT/ST)                                    │
n5=&gt;operation:   │                                                              │\n  │  直覺：執行緒等待 I/O 時 CPU 是閒置的，                                    │\n  │        可讓更多執行緒同時在 CPU 上運行                                    │\n  │                                                              │\n  │  範例：N=8，WT=900ms，ST=100ms                                    │\n  │        = 8 × (1 + 900/100)                                   │
n6=&gt;operation:   │        = 8 × 10 = 80 個執行緒                                    │\n  │                                                              │\n  │  ⚠️  上限受記憶體限制，每個 Java 執行緒預設 256KB~1MB 棧                      │\n  └──────────────────────────────────────────────────────────────┘\n　\n  實務建議：先用公式估算，再透過壓測（吞吐量、延遲）調整
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>CPU 密集：執行緒數接近核心數（N+1）。
I/O 密集：可高於核心數，按 N×(1+WT/ST) 估算。</p>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Producer → Queue → Worker x N → Result
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-12"><a class="header" href="#跨語言完整範例-12">跨語言完整範例</a></h2>
<p>執行緒池處理批次任務：固定 4 個 worker，處理 20 個任務，顯示並發執行效果。</p>
<h3 id="c-4"><a class="header" href="#c-4">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch13_c ch13.c &amp;&amp; ./ch13_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

#define WORKERS 4
#define TASKS   20
#define QUEUE_CAP 64

typedef void (*task_fn)(int);

typedef struct {
    task_fn  fn;
    int      arg;
} Task;

typedef struct {
    Task      queue[QUEUE_CAP];
    int       head, tail, size;
    pthread_mutex_t mu;
    pthread_cond_t  not_empty;
    int       done;           /* 1 = shutdown */
} Pool;

Pool pool = {.head=0, .tail=0, .size=0, .done=0,
             .mu=PTHREAD_MUTEX_INITIALIZER,
             .not_empty=PTHREAD_COND_INITIALIZER};

void pool_submit(task_fn fn, int arg) {
    pthread_mutex_lock(&amp;pool.mu);
    pool.queue[pool.tail] = (Task){fn, arg};
    pool.tail = (pool.tail + 1) % QUEUE_CAP;
    pool.size++;
    pthread_cond_signal(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);
}

void *worker_loop(void *arg) {
    int id = *(int *)arg;
    for (;;) {
        pthread_mutex_lock(&amp;pool.mu);
        while (pool.size == 0 &amp;&amp; !pool.done)
            pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
        if (pool.size == 0 &amp;&amp; pool.done) {
            pthread_mutex_unlock(&amp;pool.mu);
            break;
        }
        Task t = pool.queue[pool.head];
        pool.head = (pool.head + 1) % QUEUE_CAP;
        pool.size--;
        pthread_mutex_unlock(&amp;pool.mu);
        t.fn(t.arg);
    }
    printf("Worker %d exiting\n", id);
    return NULL;
}

void process_task(int task_id) {
    printf("Task %2d running on thread %lu\n",
           task_id, pthread_self() % 10000);
    usleep(50000);  /* 模擬 50ms 工作 */
}

int main(void) {
    pthread_t threads[WORKERS];
    int ids[WORKERS];
    for (int i = 0; i &lt; WORKERS; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker_loop, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASKS; i++)
        pool_submit(process_task, i);

    /* 等佇列排空後關閉 */
    pthread_mutex_lock(&amp;pool.mu);
    while (pool.size &gt; 0)
        pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
    pool.done = 1;
    pthread_cond_broadcast(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);

    for (int i = 0; i &lt; WORKERS; i++) pthread_join(threads[i], NULL);
    printf("All %d tasks completed.\n", TASKS);
    return 0;
}
</code></pre>
<h3 id="c-5"><a class="header" href="#c-5">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch13_cpp ch13.cpp &amp;&amp; ./ch13_cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;queue&gt;
#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;vector&gt;

class ThreadPool {
    std::vector&lt;std::thread&gt; workers;
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::mutex mu;
    std::condition_variable cv;
    bool stop = false;
public:
    explicit ThreadPool(int n) {
        for (int i = 0; i &lt; n; i++)
            workers.emplace_back([this] {
                for (;;) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock lk(mu);
                        cv.wait(lk, [this]{ return stop || !tasks.empty(); });
                        if (stop &amp;&amp; tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
    }
    void submit(std::function&lt;void()&gt; f) {
        { std::lock_guard lk(mu); tasks.push(std::move(f)); }
        cv.notify_one();
    }
    ~ThreadPool() {
        { std::lock_guard lk(mu); stop = true; }
        cv.notify_all();
        for (auto &amp;t : workers) t.join();
    }
};

int main() {
    ThreadPool pool(4);
    std::mutex print_mu;
    for (int i = 0; i &lt; 20; i++) {
        pool.submit([i, &amp;print_mu] {
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            std::lock_guard lk(print_mu);
            std::cout &lt;&lt; "Task " &lt;&lt; i &lt;&lt; " done by thread "
                      &lt;&lt; std::this_thread::get_id() &lt;&lt; "\n";
        });
    }
    /* ThreadPool 解構時自動等待所有任務完成 */
    std::cout &lt;&lt; "All tasks submitted, waiting...\n";
    return 0;
}
</code></pre>
<h3 id="rust-2"><a class="header" href="#rust-2">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch13.rs -o ch13 &amp;&amp; ./ch13
use std::sync::{Arc, Mutex};
use std::sync::mpsc;
use std::thread;

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

struct ThreadPool {
    _workers: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
    sender: mpsc::Sender&lt;Option&lt;Job&gt;&gt;,
}

impl ThreadPool {
    fn new(size: usize) -&gt; Self {
        let (sender, receiver) = mpsc::channel::&lt;Option&lt;Job&gt;&gt;();
        let receiver = Arc::new(Mutex::new(receiver));
        let workers = (0..size).map(|_| {
            let rx = Arc::clone(&amp;receiver);
            thread::spawn(move || loop {
                let msg = rx.lock().unwrap().recv().unwrap();
                match msg {
                    Some(job) =&gt; job(),
                    None =&gt; break,
                }
            })
        }).collect();
        ThreadPool { _workers: workers, sender }
    }

    fn submit&lt;F: FnOnce() + Send + 'static&gt;(&amp;self, f: F) {
        self.sender.send(Some(Box::new(f))).unwrap();
    }

    fn shutdown(self) {
        for _ in &amp;self._workers {
            self.sender.send(None).unwrap();
        }
        for w in self._workers { w.join().unwrap(); }
    }
}

fn main() {
    let pool = ThreadPool::new(4);
    let counter = Arc::new(Mutex::new(0));

    for i in 0..20 {
        let c = Arc::clone(&amp;counter);
        pool.submit(move || {
            thread::sleep(std::time::Duration::from_millis(50));
            let mut n = c.lock().unwrap();
            *n += 1;
            println!("Task {:2} done, completed so far: {}", i, *n);
        });
    }
    pool.shutdown();
    println!("All tasks completed.");
}</code></pre></pre>
<h3 id="go-2"><a class="header" href="#go-2">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch13.go
package main

import (
	"fmt"
	"sync"
	"time"
)

func newWorkerPool(workers int, queueSize int) chan&lt;- func() {
	jobs := make(chan func(), queueSize)
	for i := 0; i &lt; workers; i++ {
		workerID := i
		go func() {
			for job := range jobs {
				fmt.Printf("  Worker %d picked up job\n", workerID)
				job()
			}
		}()
	}
	return jobs
}

func main() {
	const numWorkers = 4
	const numTasks   = 20

	pool := newWorkerPool(numWorkers, 64)
	var wg sync.WaitGroup

	for i := 0; i &lt; numTasks; i++ {
		taskID := i
		wg.Add(1)
		pool &lt;- func() {
			defer wg.Done()
			time.Sleep(50 * time.Millisecond)
			fmt.Printf("Task %2d completed\n", taskID)
		}
	}

	wg.Wait()
	close(pool)
	fmt.Printf("All %d tasks completed.\n", numTasks)
}
</code></pre>
<h3 id="python-2"><a class="header" href="#python-2">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch13.py
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed


def process_task(task_id: int) -&gt; str:
    """模擬一個需要 50ms 的工作任務。"""
    time.sleep(0.05)
    thread_name = threading.current_thread().name
    return f"Task {task_id:2d} done by {thread_name}"


if __name__ == "__main__":
    num_tasks   = 20
    num_workers = 4

    start = time.time()
    with ThreadPoolExecutor(max_workers=num_workers,
                            thread_name_prefix="Worker") as pool:
        futures = [pool.submit(process_task, i) for i in range(num_tasks)]
        for future in as_completed(futures):
            print(future.result())

    elapsed = time.time() - start
    # 序列需 20×0.05=1.0s，4 個 worker 並行約 0.25s
    print(f"\n完成 {num_tasks} 個任務，耗時 {elapsed:.2f}s "
          f"（序列估計 {num_tasks * 0.05:.2f}s）")
</code></pre>
<h2 id="完整專案級範例python-12"><a class="header" href="#完整專案級範例python-12">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch13.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch13.py
</code></pre>
<pre><code class="language-python">"""Chapter 13: thread pool — 使用 ThreadPoolExecutor 並行處理批次任務。"""
import time
from concurrent.futures import ThreadPoolExecutor


def square(x: int) -&gt; int:
    """模擬 CPU 計算：計算平方值。"""
    time.sleep(0.01)  # 模擬少量計算時間
    return x * x


if __name__ == "__main__":
    inputs = list(range(16))
    start = time.time()

    with ThreadPoolExecutor(max_workers=4) as ex:
        results = list(ex.map(square, inputs))

    elapsed = time.time() - start
    print(f"結果: {results}")
    print(f"耗時: {elapsed:.2f}s（4 個 worker 並行）")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第14章-threadlocal"><a class="header" href="#第14章-threadlocal">第14章 ThreadLocal</a></h1>
<h2 id="141143-存取機制對應-1411434"><a class="header" href="#141143-存取機制對應-1411434">14.1~14.3 存取機制（對應 14.1~14.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-56"><a class="header" href="#本小節示意圖-56">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   ThreadLocal 存取機制：Thread 內部結構圖\n　\n  ┌─────────────────────────────────────────────────────────────────────────┐\n  │  Thread A                                                               │\n  │  ┌─────────────────────────────────────────────────────────┐            │\n  │  │  threadLocals: ThreadLocalMap                           │            │
n2=&gt;operation:   │  │  ┌──────────────────────────────────────────────────┐   │            │\n  │  │  │  Entry[]（開放定址雜湊表）                                │  │             │\n  │  │  │  ┌────────────────────┬───────────────────────┐  │  │             │\n  │  │  │  │ key = WeakRef(TL1) │ value = "user_42"    │  │  │              │\n  │  │  │  ├────────────────────┼───────────────────────┤  │  │             │\n  │  │  │  │ key = WeakRef(TL2) │ value = conn_obj_A   │  │  │              │
n3=&gt;operation:   │  │  │  ├────────────────────┼───────────────────────┤  │  │             │\n  │  │  │  │      (空槽)          │                       │  │  │             │\n  │  │  │  └────────────────────┴───────────────────────┘  │  │             │\n  │  │  └──────────────────────────────────────────────────┘   │            │\n  │  └─────────────────────────────────────────────────────────┘            │\n  └─────────────────────────────────────────────────────────────────────────┘
n4=&gt;operation: 　\n  查找路徑：\n  threadLocal.get()\n       │\n       ▼\n  Thread.currentThread()          ← 取得當前執行緒
n5=&gt;operation:        │\n       ▼\n  thread.threadLocals             ← 取得 ThreadLocalMap\n       │\n       ▼\n  map.get(this)                   ← this = ThreadLocal 實例，作為 key
n6=&gt;operation:        │\n       ▼\n  entry.value                     ← 返回使用者儲存的值\n　\n  ⚠️  記憶體洩漏風險：\n  ┌─────────────────────────────────────────────────────────────────────────┐
n7=&gt;operation:   │  ThreadLocal 實例被 GC（key 變 null）                                         │\n  │  → Entry 的 key = null，但 value 仍被強引用                                     │\n  │  → value 無法被 GC 回收 ← 洩漏！                                                │\n  │                                                                         │\n  │  防範：使用完畢後務必呼叫 threadLocal.remove()                                      │\n  └─────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>每個執行緒持有自己的本地變數副本，互不干擾。</p>
<p>ThreadLocal 的核心不是「一個全局變數有多份副本」，而是「每個 Thread 物件內部有一個 <code>ThreadLocalMap</code>」。<code>get()/set()</code> 實際上是在當前執行緒的 Map 中查找/寫入，以 ThreadLocal 實例本身作為 key。</p>
<p>關鍵細節：Map 中的 key 是弱引用（WeakReference），若 ThreadLocal 實例沒有外部強引用而被 GC 回收，key 就會變成 null，但 value 仍被 Entry 強引用，造成洩漏。執行緒池中的執行緒長期存活，此問題尤為危險。</p>
<h2 id="144-不繼承性"><a class="header" href="#144-不繼承性">14.4 不繼承性</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-57"><a class="header" href="#本小節示意圖-57">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   父執行緒 vs 子執行緒的 ThreadLocal 隔離\n　\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  父執行緒（Parent Thread）                                             │\n  │  threadLocals: { TL_user_id → 42, TL_request → "req-001" }       │\n  └────────────────────────────┬─────────────────────────────────────┘
n2=&gt;operation:                                │ new Thread(...)  或  pool.submit(...)\n                               │ 建立子執行緒\n                               ▼\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  子執行緒（Child Thread）                                              │\n  │  threadLocals: { }   ← 空 Map！                                    │
n3=&gt;operation:   │                                                                  │\n  │  child.get(TL_user_id)  → null（或 initialValue()）                 │\n  │  child.get(TL_request)  → null（或 initialValue()）                 │\n  └──────────────────────────────────────────────────────────────────┘\n　\n  ⚠️  常見問題：
n4=&gt;operation:   父執行緒設定了 user_id=42（用於追蹤請求）\n  提交任務到執行緒池後，子執行緒讀到 null\n  → 日誌無法關聯到正確的請求 ID\n  → 解決方案：改用 InheritableThreadLocal（見 14.5）\n              或手動在 submit 時捕獲並傳遞值
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
</code></pre>
<p>子執行緒預設看不到父執行緒 ThreadLocal。</p>
<p>這個設計是有意的：ThreadLocal 的語義是「執行緒私有」，若自動繼承反而破壞隔離性。但在請求追蹤（Trace ID）等場景確實需要傳遞上下文，此時應使用 InheritableThreadLocal 或顯式傳遞。</p>
<h2 id="145146-可繼承變體"><a class="header" href="#145146-可繼承變體">14.5~14.6 可繼承變體</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-58"><a class="header" href="#本小節示意圖-58">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   InheritableThreadLocal：建立子執行緒時複製快照\n　\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  父執行緒                                                            │\n  │  inheritableThreadLocals: { ITL_user → 42, ITL_locale → "zh" }   │\n  └────────────────────────────┬─────────────────────────────────────┘
n2=&gt;operation:                                │ new Thread() 時，JVM 自動複製快照\n                               ▼\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  子執行緒（建立時複製）                                                     │\n  │  inheritableThreadLocals: { ITL_user → 42, ITL_locale → "zh" }   │\n  │                           ↑ 獨立副本，修改互不影響                          │
n3=&gt;operation:   └──────────────────────────────────────────────────────────────────┘\n　\n  child.set(ITL_user, 99)  → 只影響子執行緒，父執行緒仍是 42\n　\n  ⚠️  執行緒池問題：\n  Pool 中的執行緒在建立時已複製，之後複用時不會再複製
n4=&gt;operation:   父執行緒後續修改的值，Pool Worker 看不到\n　\n  ─────────────────────────────────────────────────────────────────\n　\n  設計哲學對比：Java vs Go\n　
n5=&gt;operation:   Java：隱式攜帶（InheritableThreadLocal）\n  ┌──────────────────────────────────────────────────────────────────┐\n  │ 上下文隱藏在執行緒內部                                                      │\n  │ 優點：呼叫方不需要傳參                                                      │\n  │ 缺點：隱式依賴，難以追蹤                                                     │\n  └──────────────────────────────────────────────────────────────────┘
n6=&gt;operation: 　\n  Go：顯式傳遞（context.Context）\n  ┌──────────────────────────────────────────────────────────────────┐\n  │ func process(ctx context.Context) {                              │\n  │     userID := ctx.Value("user_id")                               │\n  │     child(ctx)  ← 顯式傳遞                                           │
n7=&gt;operation:   │ }                                                                │\n  │ 優點：資料流向清晰，易於測試                                                   │\n  │ 缺點：所有函式都需要加 ctx 參數                                               │\n  └──────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>InheritableThreadLocal 可在建立子執行緒時複製上下文。</p>
<p>跨語言對比：</p>
<ul>
<li>C/C++: <code>thread_local</code> — 關鍵字宣告，編譯器自動為每個執行緒分配獨立儲存</li>
<li>Rust: <code>thread_local!</code> — 宏定義，支援懶初始化</li>
<li>Go: 常用 <code>context.Context</code> 顯式傳遞，不鼓勵隱式 thread local；這反映了 Go 「明確優於隱式」的設計哲學</li>
</ul>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Thread A: user_id=42\nThread B: user_id=? (預設拿不到 A 的值)
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-13"><a class="header" href="#跨語言完整範例-13">跨語言完整範例</a></h2>
<p>執行緒本地儲存：每個執行緒有自己的 user_id，互不干擾，演示隔離性。</p>
<h3 id="c-6"><a class="header" href="#c-6">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch14_c ch14.c &amp;&amp; ./ch14_c */
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

/* thread_local 在 C11 中為 _Thread_local，gcc 支援 __thread */
static __thread int user_id = 0;

typedef struct { int set_id; const char *name; } Args;

void *thread_fn(void *arg) {
    Args *a = (Args *)arg;
    user_id = a-&gt;set_id;                  /* 只影響當前執行緒 */
    usleep(10000);                         /* 讓其他執行緒也設定自己的值 */
    printf("%-10s user_id=%d\n", a-&gt;name, user_id);
    return NULL;
}

int main(void) {
    Args args[] = {{42, "Thread-A"}, {7, "Thread-B"}, {100, "Thread-C"}};
    pthread_t threads[3];

    for (int i = 0; i &lt; 3; i++)
        pthread_create(&amp;threads[i], NULL, thread_fn, &amp;args[i]);
    for (int i = 0; i &lt; 3; i++)
        pthread_join(threads[i], NULL);

    printf("Main thread user_id=%d (never set, remains 0)\n", user_id);
    return 0;
}
</code></pre>
<h3 id="c-7"><a class="header" href="#c-7">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch14_cpp ch14.cpp &amp;&amp; ./ch14_cpp
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;

thread_local int user_id = 0;          // 每個執行緒各自的 user_id
thread_local std::string request_id;   // 每個執行緒各自的 request_id

void handle_request(int uid, const std::string &amp;rid) {
    user_id    = uid;
    request_id = rid;
    std::this_thread::sleep_for(std::chrono::milliseconds(10));

    // 讀回自己的值，不受其他執行緒影響
    std::cout &lt;&lt; "Thread " &lt;&lt; std::this_thread::get_id()
              &lt;&lt; " user_id=" &lt;&lt; user_id
              &lt;&lt; " request_id=" &lt;&lt; request_id &lt;&lt; "\n";
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    threads.emplace_back(handle_request, 42,  "req-001");
    threads.emplace_back(handle_request, 7,   "req-002");
    threads.emplace_back(handle_request, 100, "req-003");
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "main thread: user_id=" &lt;&lt; user_id
              &lt;&lt; " (0，從未設定)\n";
    return 0;
}
</code></pre>
<h3 id="rust-3"><a class="header" href="#rust-3">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch14.rs -o ch14 &amp;&amp; ./ch14
use std::cell::RefCell;
use std::thread;

thread_local! {
    static USER_ID:    RefCell&lt;i32&gt;     = RefCell::new(0);
    static REQUEST_ID: RefCell&lt;String&gt;  = RefCell::new(String::new());
}

fn handle_request(uid: i32, rid: &amp;'static str) {
    USER_ID.with(|u| *u.borrow_mut() = uid);
    REQUEST_ID.with(|r| *r.borrow_mut() = rid.to_string());

    thread::sleep(std::time::Duration::from_millis(10));

    USER_ID.with(|u| {
        REQUEST_ID.with(|r| {
            println!("thread {:?}: user_id={}, request_id={}",
                     thread::current().id(), u.borrow(), r.borrow());
        });
    });
}

fn main() {
    let handles: Vec&lt;_&gt; = vec![
        (42,  "req-001"),
        (7,   "req-002"),
        (100, "req-003"),
    ].into_iter().map(|(uid, rid)| {
        thread::spawn(move || handle_request(uid, rid))
    }).collect();

    for h in handles { h.join().unwrap(); }
    USER_ID.with(|u| println!("main: user_id={} (0，從未設定)", u.borrow()));
}</code></pre></pre>
<h3 id="go-3"><a class="header" href="#go-3">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch14.go
// Go 不推薦隱式 thread-local，改用 context.Context 顯式傳遞
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

type contextKey string

const keyUserID    contextKey = "user_id"
const keyRequestID contextKey = "request_id"

// handleRequest 接收 context，從中讀取執行緒「本地」資料
// 這是 Go 的慣用做法：顯式傳遞，不依賴隱式 goroutine-local
func handleRequest(ctx context.Context, wg *sync.WaitGroup) {
	defer wg.Done()
	time.Sleep(10 * time.Millisecond)

	uid := ctx.Value(keyUserID)
	rid := ctx.Value(keyRequestID)
	fmt.Printf("goroutine: user_id=%v, request_id=%v\n", uid, rid)
}

func main() {
	var wg sync.WaitGroup
	requests := []struct {
		userID    int
		requestID string
	}{
		{42, "req-001"},
		{7, "req-002"},
		{100, "req-003"},
	}

	for _, req := range requests {
		ctx := context.WithValue(context.Background(), keyUserID, req.userID)
		ctx = context.WithValue(ctx, keyRequestID, req.requestID)
		wg.Add(1)
		go handleRequest(ctx, &amp;wg)
	}
	wg.Wait()
	fmt.Println("Done — Go 使用 context 顯式傳遞，語意清晰")
}
</code></pre>
<h3 id="python-3"><a class="header" href="#python-3">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch14.py
import threading
import time


# threading.local() 為每個執行緒提供獨立的命名空間
local_storage = threading.local()


def handle_request(user_id: int, request_id: str):
    """每個執行緒設定自己的 local 變數，互不干擾。"""
    local_storage.user_id    = user_id
    local_storage.request_id = request_id
    time.sleep(0.01)   # 讓其他執行緒也在設定自己的值

    # 讀回自己設定的值
    print(f"{threading.current_thread().name}: "
          f"user_id={local_storage.user_id}, "
          f"request_id={local_storage.request_id}")


if __name__ == "__main__":
    requests = [(42, "req-001"), (7, "req-002"), (100, "req-003")]
    threads = [
        threading.Thread(target=handle_request, args=(uid, rid),
                         name=f"Thread-{i}")
        for i, (uid, rid) in enumerate(requests)
    ]
    for t in threads: t.start()
    for t in threads: t.join()

    # 主執行緒從未設定，讀取會拋出 AttributeError
    try:
        print(f"main: user_id={local_storage.user_id}")
    except AttributeError:
        print("main: user_id 未設定（符合預期，各執行緒隔離）")
</code></pre>
<h2 id="完整專案級範例python-13"><a class="header" href="#完整專案級範例python-13">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch14.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch14.py
</code></pre>
<pre><code class="language-python">"""Chapter 14: thread local — 執行緒本地儲存，每個執行緒持有獨立副本。"""
import threading

local = threading.local()


def run(name: str, uid: int):
    """設定執行緒本地的 user_id，讀回時只看到自己設定的值。"""
    local.user_id = uid
    # 即使其他執行緒同時修改各自的 user_id，這裡讀到的仍是自己的值
    print(f"{name} user_id={local.user_id}")


if __name__ == "__main__":
    t1 = threading.Thread(target=run, args=("T1", 42))
    t2 = threading.Thread(target=run, args=("T2", 7))
    t1.start(); t2.start(); t1.join(); t2.join()
    # 主執行緒從未設定，驗證隔離性
    try:
        print(f"main user_id={local.user_id}")
    except AttributeError:
        print("main: user_id 不存在（各執行緒完全隔離）")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第15章-手寫線程池實戰"><a class="header" href="#第15章-手寫線程池實戰">第15章 手寫線程池實戰</a></h1>
<h2 id="151-結構設計"><a class="header" href="#151-結構設計">15.1 結構設計</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-59"><a class="header" href="#本小節示意圖-59">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   ThreadPool 核心組件圖\n　\n  ┌──────────────────────────────────────────────────────────────────────────────────────────┐\n  │                        ThreadPool                                                        │\n  │                                                                                          │\n  │  ┌─────────────────────────────────────────────────────────┐                             │
n2=&gt;operation:   │                          │  state: AtomicInteger                                   │     │\n  │                          │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────┐ │       │\n  │  │  │ RUNNING  │→ │SHUTDOWN  │→ │  STOP    │→ │TERMINATED│ │                             │\n  │                          │  └──────────┘  └──────────┘  └──────────┘  └────────┘ │       │\n  │  └─────────────────────────────────────────────────────────┘                             │\n  │                              │ 控制                                                        │
n3=&gt;operation:   │  ┌──────────────────┐        │        ┌──────────────────┐                               │\n  │  │  task_queue      │        │        │  workers         │                               │\n  │  │  BlockingQueue   │◄───────┴───────►│  Set&lt;Thread&gt;     │                               │\n  │  │                  │    協作           │                  │                               │\n  │  │  [Task][Task]    │  ─poll()─►      │  [W1][W2][W3][W4]│                               │\n  │  │  [Task][Task]    │                 │   ↑執行任務↑         │                               │
n4=&gt;operation:   │  └──────────────────┘                 └──────────────────┘                               │\n  │          ▲ submit()                                                                      │\n  │          │                   飽和時觸發                                                       │\n  │  ┌───────┴──────┐        ┌──────────────────────────────┐                                │\n  │  │   外部呼叫方          │                 │  reject_policy               │                   │\n  │  │  (Producer)      │                 │  RejectedExecutionHandler    │                   │
n5=&gt;operation:   │  └──────────────┘        │  Abort / CallerRuns / Discard   │                             │\n  │                           └──────────────────────────────┘                               │\n  │                                                                                          │\n  │  組件職責：                                                                                   │\n  │  • task_queue：緩衝待執行任務，解耦生產者與消費者                                                          │\n  │  • workers：實際執行任務的執行緒集合，數量在 [core, max] 間調整                                              │
n6=&gt;operation:   │  • state：協調關閉流程，防止競態                                                                     │\n  │  • reject_policy：佇列+執行緒都滿時的降級策略                                                          │\n  └──────────────────────────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>需要的核心欄位：</p>
<ul>
<li><strong>任務佇列（task_queue）</strong>：BlockingQueue，生產者 submit 入佇，worker 出佇執行</li>
<li><strong>worker 集合（workers）</strong>：追蹤所有活躍執行緒，用於關閉時中斷</li>
<li><strong>運行狀態（state）</strong>：AtomicInteger，防止在關閉中繼續接受任務</li>
<li><strong>拒絕策略（reject_policy）</strong>：飽和時的處理方式，預設拋出例外</li>
</ul>
<h2 id="152-worker-邏輯"><a class="header" href="#152-worker-邏輯">15.2 Worker 邏輯</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-60"><a class="header" href="#本小節示意圖-60">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   Worker 主循環流程圖\n　\n  Worker 執行緒啟動\n        │\n        ▼\n  ┌───────────────────────────────────────────────────────┐
n2=&gt;operation:   │  loop（主循環）      │ ◄────────────────────────────┐\n  └──────────┬──────────┘                               │\n             │                                          │\n             ▼                                          │\n  ┌─────────────────────────────────────┐               │\n  │  task = queue.poll(keepAliveTime)   │                 │
n3=&gt;operation:   │  （等待最多 keepAliveTime 超時）     │                        │\n  └──────────────┬──────────────────────┘               │\n                 │                                       │\n        task != null?                                    │\n        ┌────────┴────────┐                             │\n        │是               │否（等待超時）                                     │
n4=&gt;operation:         ▼                 ▼                             │\n  ┌───────────┐   是否為核心執行緒？                     │\n  │ execute() │   ┌────────┴────────┐                     │\n  │  task     │   │是               │否（非核心）                │\n  └─────┬─────┘   ▼                 ▼                   │\n        │   繼續等待，        workers.size &gt; core?                         │
n5=&gt;operation:         │   不退出            ┌────────┴────────┐                        │\n        │                    │是               │否                      │\n        │                    ▼                 ▼                      │\n        │             ┌─────────────┐    繼續等待                         │\n        │                    │ 退出 loop        │    不退出 ─────────►     │\n        │             │ workers.                                      │
n6=&gt;operation:         │             │ remove(this)                                  │\n        └─────────────►            │ ←──────────── shutdown?\n                      └─────────────┘                   ▲\n                                                        │\n                               pool.state == SHUTDOWN  ─┘\n                               且 queue 已空 → 退出
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>worker 持續從佇列取任務執行，遇到關閉訊號退出。</p>
<p>Worker 的關鍵設計點：</p>
<ol>
<li><strong>keepAlive 超時</strong>：非核心執行緒等待超過 keepAliveTime 後縮容退出，避免資源浪費</li>
<li><strong>中斷響應</strong>：<code>shutdownNow()</code> 時送出中斷，worker 的 <code>poll()</code> 會拋出 <code>InterruptedException</code> 並退出</li>
<li><strong>退出清理</strong>：worker 退出前從 <code>workers</code> 集合中移除自己，並在必要時判斷是否需要觸發 <code>TERMINATED</code> 狀態</li>
</ol>
<h2 id="153-提交與關閉對應-15311536"><a class="header" href="#153-提交與關閉對應-15311536">15.3 提交與關閉（對應 15.3.1~15.3.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-61"><a class="header" href="#本小節示意圖-61">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   submit(task) 流程圖\n　\n  submit(task)\n       │\n       ▼\n  ┌─────────────────────────────────────────────────┐
n2=&gt;operation:   │ state == RUNNING ?                              │\n  └──────────┬──────────────────────────────────────┘\n       是 │           │ 否（SHUTDOWN/STOP）\n          ▼           ▼\n  ┌──────────────┐  ┌───────────────────────────────┐\n  │ queue.offer  │  │ reject(task)                  │
n3=&gt;operation:   │ (task) 成功?   │  │ RejectedExecution             │\n  └──────┬───────┘  └───────────────────────────────┘\n    是 │     │ 否（佇列滿）\n       ▼     ▼\n  ┌──────┐  ┌───────────────────────────────────────┐\n  │ 返回           │  │ workers.size &lt; maxPoolSize?   │
n4=&gt;operation:   └──────┘  └────────────┬──────────────────────────┘\n                  是 │           │ 否\n                     ▼           ▼\n             ┌──────────────┐  ┌─────────────────────────┐\n             │ 新建 Worker  │  │ reject(task)              │\n             │ 執行此任務      │  │（飽和拒絕）                     │
n5=&gt;operation:              └──────────────┘  └─────────────────────────┘\n　\n  ─────────────────────────────────────────────────────────────────\n　\n  shutdown() 流程圖\n　
n6=&gt;operation:   shutdown()\n       │\n       ├─► 1. 原子設定 state = SHUTDOWN\n       │\n       ├─► 2. 中斷所有閒置 workers（喚醒正在 poll() 等待的執行緒）\n       │
n7=&gt;operation:        ├─► 3. 不再接受新的 submit()\n       │\n       └─► 4. 等待佇列排空 + workers 歸零 → 轉入 TERMINATED\n            （可用 awaitTermination() 阻塞等待）
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<ul>
<li><strong>submit</strong>：放入佇列或觸發拒絕</li>
<li><strong>shutdown</strong>：停止收新任務，排空後結束</li>
</ul>
<p>關閉的正確姿勢是先呼叫 <code>shutdown()</code>，再以迴圈呼叫 <code>awaitTermination()</code> 直到返回 <code>true</code> 或超時強制中斷（<code>shutdownNow()</code>）。</p>
<h2 id="154-測試"><a class="header" href="#154-測試">15.4 測試</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-62"><a class="header" href="#本小節示意圖-62">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation:   測試場景清單與期望行為\n　\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  場景 1：正常提交                                                       │\n  │  操作：提交 N 個任務（N ≤ queue capacity）                                 │\n  │  期望：所有任務按完成，無例外，result 集合 size == N                              │
n2=&gt;operation:   ├──────────────────────────────────────────────────────────────────┤\n  │  場景 2：飽和拒絕                                                       │\n  │  操作：workers 全忙 + 佇列滿時繼續提交                                        │\n  │  期望：觸發 RejectedExecutionException（或自定義策略動作）                      │\n  │  驗證：已進入佇列的任務仍能正常完成                                               │\n  ├──────────────────────────────────────────────────────────────────┤
n3=&gt;operation:   │  場景 3：優雅關閉（shutdown）                                             │\n  │  操作：提交 N 個任務後立即 shutdown()                                       │\n  │  期望：所有已提交任務執行完畢，awaitTermination 返回 true                         │\n  │  禁止：shutdown 後再 submit 拋出 RejectedExecutionException             │\n  ├──────────────────────────────────────────────────────────────────┤\n  │  場景 4：強制中斷（shutdownNow）                                          │
n4=&gt;operation:   │  操作：任務執行中呼叫 shutdownNow()                                        │\n  │  期望：返回未執行任務列表，正在執行的任務收到中斷訊號                                      │\n  │  驗證：list.size == 未執行任務數量                                         │\n  ├──────────────────────────────────────────────────────────────────┤\n  │  場景 5：keepAlive 縮容                                               │\n  │  操作：高峰期超過 coreSize，低峰期閒置超過 keepAliveTime                         │
n5=&gt;operation:   │  期望：非核心執行緒自動退出，workers.size 降回 coreSize                          │\n  │  驗證：等待 keepAliveTime + buffer 後檢查 activeCount                    │\n  └──────────────────────────────────────────────────────────────────┘\n　\n  壓測指標：\n  ┌─────────────┬────────────────────────────────────────────────────┐
n6=&gt;operation:   │  吞吐量     │ tasks/second，對比序列執行的加速比                               │\n  │  延遲 P99   │ 第 99 百分位任務完成時間，反映長尾效能                                │\n  │  拒絕比例   │ rejected / total，評估參數設定是否合理                            │\n  │  佇列水位   │ queue.size() 峰值，評估是否需要擴容                               │\n  └─────────────┴────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>壓測觀察吞吐、延遲、拒絕比例。</p>
<p>測試線程池時需涵蓋正常路徑和各種邊界情況。特別注意關閉時的競態：<code>shutdown()</code> 和最後一個任務完成之間存在時間視窗，測試需等待 <code>awaitTermination()</code> 返回 <code>true</code> 才能斷言結果。</p>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: while (running) {\n  task = queue.pop()\n  run(task)\n}
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-14"><a class="header" href="#跨語言完整範例-14">跨語言完整範例</a></h2>
<p>最簡執行緒池：channel 做佇列，N 個 goroutine/thread 做 worker，展示核心機制。</p>
<h3 id="c-8"><a class="header" href="#c-8">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch15_c ch15.c &amp;&amp; ./ch15_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdatomic.h&gt;

#define WORKERS   4
#define TASKS     20
#define QCAP      64

typedef struct { int id; } Task;

/* 環形緩衝佇列 */
typedef struct {
    Task        buf[QCAP];
    int         head, tail, size;
    pthread_mutex_t mu;
    pthread_cond_t  not_empty;
    atomic_int  shutdown;
    atomic_int  completed;
} Pool;

static Pool pool;

static void pool_init(void) {
    pool.head = pool.tail = pool.size = 0;
    atomic_store(&amp;pool.shutdown, 0);
    atomic_store(&amp;pool.completed, 0);
    pthread_mutex_init(&amp;pool.mu, NULL);
    pthread_cond_init(&amp;pool.not_empty, NULL);
}

static void pool_submit(int task_id) {
    pthread_mutex_lock(&amp;pool.mu);
    pool.buf[pool.tail] = (Task){task_id};
    pool.tail = (pool.tail + 1) % QCAP;
    pool.size++;
    pthread_cond_signal(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);
}

static void *worker_loop(void *arg) {
    int wid = *(int *)arg;
    for (;;) {
        pthread_mutex_lock(&amp;pool.mu);
        while (pool.size == 0 &amp;&amp; !atomic_load(&amp;pool.shutdown))
            pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
        if (pool.size == 0) {           /* shutdown + 空佇列 */
            pthread_mutex_unlock(&amp;pool.mu);
            break;
        }
        Task t = pool.buf[pool.head];
        pool.head = (pool.head + 1) % QCAP;
        pool.size--;
        pthread_mutex_unlock(&amp;pool.mu);

        usleep(20000);                  /* 模擬 20ms 工作 */
        int done = atomic_fetch_add(&amp;pool.completed, 1) + 1;
        printf("Worker%d finished task %2d (total done: %d)\n",
               wid, t.id, done);
    }
    return NULL;
}

int main(void) {
    pool_init();
    pthread_t threads[WORKERS];
    int ids[WORKERS];
    for (int i = 0; i &lt; WORKERS; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker_loop, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASKS; i++) {
        pool_submit(i);
    }
    /* 等佇列排空後再 shutdown */
    pthread_mutex_lock(&amp;pool.mu);
    while (pool.size &gt; 0)
        pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
    atomic_store(&amp;pool.shutdown, 1);
    pthread_cond_broadcast(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);

    for (int i = 0; i &lt; WORKERS; i++) pthread_join(threads[i], NULL);
    printf("All %d tasks done.\n", atomic_load(&amp;pool.completed));
    return 0;
}
</code></pre>
<h3 id="c-9"><a class="header" href="#c-9">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch15_cpp ch15.cpp &amp;&amp; ./ch15_cpp
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;atomic&gt;

class SimpleThreadPool {
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::vector&lt;std::thread&gt; workers;
    std::mutex mu;
    std::condition_variable cv;
    bool stopped = false;
    std::atomic&lt;int&gt; completed{0};

public:
    explicit SimpleThreadPool(int n) {
        for (int i = 0; i &lt; n; i++) {
            workers.emplace_back([this, i] {
                for (;;) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock lk(mu);
                        cv.wait(lk, [this]{ return stopped || !tasks.empty(); });
                        if (stopped &amp;&amp; tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                    completed++;
                }
            });
        }
    }

    void submit(std::function&lt;void()&gt; f) {
        { std::lock_guard lk(mu); tasks.push(std::move(f)); }
        cv.notify_one();
    }

    int done_count() const { return completed.load(); }

    void shutdown() {
        { std::lock_guard lk(mu); stopped = true; }
        cv.notify_all();
        for (auto &amp;t : workers) t.join();
    }
};

int main() {
    SimpleThreadPool pool(4);
    std::mutex print_mu;

    for (int i = 0; i &lt; 20; i++) {
        pool.submit([i, &amp;print_mu, &amp;pool] {
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
            std::lock_guard lk(print_mu);
            std::cout &lt;&lt; "Task " &lt;&lt; std::setw(2) &lt;&lt; i
                      &lt;&lt; " done, total=" &lt;&lt; pool.done_count() + 1 &lt;&lt; "\n";
        });
    }
    pool.shutdown();
    std::cout &lt;&lt; "All tasks completed, total=" &lt;&lt; pool.done_count() &lt;&lt; "\n";
    return 0;
}
</code></pre>
<h3 id="rust-4"><a class="header" href="#rust-4">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch15.rs -o ch15 &amp;&amp; ./ch15
use std::sync::{Arc, Mutex, Condvar};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;
use std::collections::VecDeque;

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

struct SimplePool {
    queue:     Mutex&lt;VecDeque&lt;Option&lt;Job&gt;&gt;&gt;,
    cv:        Condvar,
    completed: AtomicUsize,
}

impl SimplePool {
    fn new() -&gt; Arc&lt;Self&gt; {
        Arc::new(SimplePool {
            queue:     Mutex::new(VecDeque::new()),
            cv:        Condvar::new(),
            completed: AtomicUsize::new(0),
        })
    }

    fn submit(self: &amp;Arc&lt;Self&gt;, f: impl FnOnce() + Send + 'static) {
        self.queue.lock().unwrap().push_back(Some(Box::new(f)));
        self.cv.notify_one();
    }

    fn spawn_workers(self: &amp;Arc&lt;Self&gt;, n: usize) -&gt; Vec&lt;thread::JoinHandle&lt;()&gt;&gt; {
        (0..n).map(|_| {
            let pool = Arc::clone(self);
            thread::spawn(move || loop {
                let job = {
                    let mut q = pool.cv
                        .wait_while(pool.queue.lock().unwrap(), |q| q.is_empty())
                        .unwrap();
                    q.pop_front().unwrap()
                };
                match job {
                    Some(f) =&gt; { f(); pool.completed.fetch_add(1, Ordering::Relaxed); }
                    None    =&gt; break,
                }
            })
        }).collect()
    }

    fn shutdown(self: &amp;Arc&lt;Self&gt;, handles: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;, n: usize) {
        for _ in 0..n {
            self.queue.lock().unwrap().push_back(None);
            self.cv.notify_one();
        }
        for h in handles { h.join().unwrap(); }
    }
}

fn main() {
    const WORKERS: usize = 4;
    const TASKS:   usize = 20;

    let pool = SimplePool::new();
    let handles = pool.spawn_workers(WORKERS);

    for i in 0..TASKS {
        let p = Arc::clone(&amp;pool);
        pool.submit(move || {
            thread::sleep(std::time::Duration::from_millis(20));
            let done = p.completed.load(Ordering::Relaxed) + 1;
            println!("Task {:2} done, completed so far: {}", i, done);
        });
    }
    pool.shutdown(handles, WORKERS);
    println!("Total completed: {}", pool.completed.load(Ordering::Relaxed));
}</code></pre></pre>
<h3 id="go-4"><a class="header" href="#go-4">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch15.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

// SimplePool：channel 作為任務佇列，goroutine 作為 worker
type SimplePool struct {
	jobs      chan func()
	wg        sync.WaitGroup
	completed int64
}

func NewPool(workers, queueSize int) *SimplePool {
	p := &amp;SimplePool{jobs: make(chan func(), queueSize)}
	for i := 0; i &lt; workers; i++ {
		workerID := i
		go func() {
			for job := range p.jobs {
				job()
				atomic.AddInt64(&amp;p.completed, 1)
				fmt.Printf("  Worker%d: task done (total=%d)\n",
					workerID, atomic.LoadInt64(&amp;p.completed))
			}
		}()
	}
	return p
}

func (p *SimplePool) Submit(f func()) {
	p.wg.Add(1)
	p.jobs &lt;- func() {
		defer p.wg.Done()
		f()
	}
}

func (p *SimplePool) Shutdown() {
	p.wg.Wait()
	close(p.jobs)
}

func main() {
	const numWorkers = 4
	const numTasks   = 20

	pool := NewPool(numWorkers, 64)
	for i := 0; i &lt; numTasks; i++ {
		taskID := i
		pool.Submit(func() {
			time.Sleep(20 * time.Millisecond)
			_ = taskID
		})
	}
	pool.Shutdown()
	fmt.Printf("All done, completed=%d\n", atomic.LoadInt64(&amp;pool.completed))
}
</code></pre>
<h3 id="python-4"><a class="header" href="#python-4">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch15.py
import queue
import threading
import time
from typing import Callable


class SimpleThreadPool:
    """最簡執行緒池：queue 做佇列，Thread 做 worker。"""

    def __init__(self, num_workers: int, queue_size: int = 64):
        self._queue = queue.Queue(maxsize=queue_size)
        self._completed = 0
        self._lock = threading.Lock()
        self._workers = [
            threading.Thread(target=self._worker_loop, name=f"Worker-{i}",
                             daemon=True)
            for i in range(num_workers)
        ]
        for w in self._workers:
            w.start()

    def _worker_loop(self):
        """Worker 主循環：不斷從佇列取任務並執行。"""
        while True:
            task = self._queue.get()
            if task is None:        # None 作為關閉訊號
                self._queue.task_done()
                break
            try:
                task()
                with self._lock:
                    self._completed += 1
                    print(f"{threading.current_thread().name}: "
                          f"task done (total={self._completed})")
            finally:
                self._queue.task_done()

    def submit(self, fn: Callable):
        self._queue.put(fn)

    def shutdown(self):
        """等待所有任務完成後關閉。"""
        self._queue.join()          # 等佇列排空
        for _ in self._workers:
            self._queue.put(None)   # 每個 worker 一個停止訊號
        for w in self._workers:
            w.join()
        return self._completed


if __name__ == "__main__":
    pool = SimpleThreadPool(num_workers=4, queue_size=64)

    for i in range(20):
        def make_task(task_id):
            def task():
                time.sleep(0.02)
                _ = task_id     # 實際工作
            return task
        pool.submit(make_task(i))

    total = pool.shutdown()
    print(f"All tasks completed, total={total}")
</code></pre>
<h2 id="完整專案級範例python-14"><a class="header" href="#完整專案級範例python-14">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch15.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch15.py
</code></pre>
<pre><code class="language-python">"""Chapter 15: custom thread pool — 手動實作執行緒池的核心機制。"""
import queue
import threading

q = queue.Queue()
stop = object()              # 哨兵值，用來通知 worker 退出


def worker():
    """Worker 主循環：取任務執行，遇到 stop 哨兵則退出。"""
    while True:
        task = q.get()
        if task is stop:
            q.task_done()
            return
        try:
            task()
        finally:
            q.task_done()


if __name__ == "__main__":
    num_workers = 3
    workers = [threading.Thread(target=worker, daemon=True)
               for _ in range(num_workers)]
    for w in workers: w.start()

    # 提交 5 個任務
    for i in range(5):
        task_id = i
        q.put(lambda tid=task_id: print(f"task {tid} on {threading.current_thread().name}"))

    # 等所有任務完成，再送停止訊號
    q.join()
    for _ in workers: q.put(stop)
    for w in workers: w.join()
    print("pool shutdown complete")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第16章-cas-自旋鎖實戰"><a class="header" href="#第16章-cas-自旋鎖實戰">第16章 CAS 自旋鎖實戰</a></h1>
<h2 id="161-目標"><a class="header" href="#161-目標">16.1 目標</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-63"><a class="header" href="#本小節示意圖-63">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 三種鎖模式對比\n　\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                       鎖模式適用場景比較                                             │\n├───────────────┬───────────────┬─────────────────────────────────────────────┤\n│  Lock-free    │   Spin Lock   │          OS Mutex                           │
n2=&gt;operation: │     CAS       │               │                                             │\n├───────────────┼───────────────┼─────────────────────────────────────────────┤\n│  無阻塞          │  短臨界區         │  長臨界區                                       │\n│  全自旋          │  適合高頻鎖        │  適合 I/O、DB 等耗時操作                            │\n│               │               │                                             │\n│  CPU 一直轉      │  等待期間         │  等待時讓出 CPU                                  │
n3=&gt;operation: │  不切換執行緒       │  CPU 仍在燃燒     │  有上下文切換開銷                                   │\n├───────────────┼───────────────┼─────────────────────────────────────────────┤\n│  臨界區極短        │  臨界區 &lt; 幾      │  臨界區 &gt; 幾微秒                                  │\n│  衝突極低         │  微秒，低衝突       │  衝突較高                                       │\n│  適合計數器        │  適合 cache     │  適合資料庫操作                                    │\n├───────────────┼───────────────┼─────────────────────────────────────────────┤
n4=&gt;operation: │               │               │                                             │\n│  ●●●●●        │  ●●●○○        │  ●○○○○                                      │\n│  CPU 效率       │  CPU 效率       │  CPU 效率                                     │\n│  (高衝突時差)      │  (中度場景佳)      │  (等待時釋放CPU)                                 │\n└───────────────┴───────────────┴─────────────────────────────────────────────┘\n　
n5=&gt;operation: 適用場景判斷流程：\n　\n  臨界區有多長？\n       │\n       ├─── &lt; 1 微秒 ──→ CAS / Lock-free（無鎖化）\n       │
n6=&gt;operation:        ├─── 1~10 微秒 ──→ Spin Lock（自旋）\n       │\n       └─── &gt; 10 微秒 ──→ OS Mutex（阻塞等待）
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
</code></pre>
<p>用最少原語實作可用鎖，理解 lock-free 與 spin 的邊界。</p>
<h2 id="162-核心做法"><a class="header" href="#162-核心做法">16.2 核心做法</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-64"><a class="header" href="#本小節示意圖-64">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 自旋鎖 CAS 流程圖\n　\n  flag = 0（free）  flag = 1（held）\n　\n  ┌──────────────────────────────────────────────────────────────────────────────┐\n  │  atomic_flag / AtomicBool                                                    │
n2=&gt;operation:   │                                                                              │\n  │   初始值 = 0（free）                                                              │\n  └──────────────────────────────────────────────────────────────────────────────┘\n　\n  lock() 流程：\n  ┌──────────────────────────────────────────────────────────────────────────────┐
n3=&gt;operation:   │                                                                              │\n  │  ┌──────────┐    CAS(0→1)     ┌──────────┐                                   │\n  │  │  Thread  │ ─── 成功 ──────►  │  進入                │                         │\n  │  │  嘗試鎖     │                 │  臨界區               │                         │\n  │  └──────────┘                 └──────────┘                                   │\n  │       │                                                                      │
n4=&gt;operation:   │       │ CAS(0→1) 失敗                                                          │\n  │       ▼                                                                      │\n  │  ┌──────────────────────────────────────┐                                    │\n  │  │         自旋等待迴圈                       │                                    │\n  │  │                                      │ memory_order_                      │\n  │  │  while (flag != 0) {                 │ acquire ←──────                    │
n5=&gt;operation:   │  │      [pause / yield]  ←── CPU 提示     │ 確保後續讀到                             │\n  │  │  }                                   │ 最新資料                               │\n  │  │  再試 CAS(0→1)                         │                                    │\n  │  └──────────────────────────────────────┘                                    │\n  │                                                                              │\n  └──────────────────────────────────────────────────────────────────────────────┘
n6=&gt;operation: 　\n  unlock() 流程：\n  ┌──────────────────────────────────────────────────────────────────────────────┐\n  │                                                                              │\n  │  ┌──────────┐   store(0)      ┌──────────────────────┐                       │\n  │  │  Thread  │ ──────────────► │  flag = 0（free）    │                         │
n7=&gt;operation:   │  │  持有者     │  memory_order_  │  其他執行緒可競爭          │                         │\n  │  └──────────┘  release ────►  └──────────────────────┘                       │\n  │                 確保前面寫入                                                       │\n  │                 對其他執行緒可見                                                     │\n  └──────────────────────────────────────────────────────────────────────────────┘\n　
n8=&gt;operation:   memory_order 位置：\n  ┌────────────────┬─────────────────────────────────────────────────────────────┐\n  │  lock()        │  acquire  → 防止後方讀寫被提前到 lock 前                               │\n  │  unlock()      │  release  → 防止前方寫入被延遲到 unlock 後                             │\n  └────────────────┴─────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>用 <code>atomic_flag</code> 或 CAS 標記鎖是否被占用。</p>
<h2 id="163-自旋成本"><a class="header" href="#163-自旋成本">16.3 自旋成本</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-65"><a class="header" href="#本小節示意圖-65">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 低衝突 vs 高衝突時間軸\n　\n  ─── 低衝突場景（臨界區極短）───────────────────────────────────\n　\n  時間 ──────────────────────────────────────────────────────────►\n        T+0      T+1us    T+2us    T+3us    T+4us
n2=&gt;operation: 　\n  T1   [鎖][工作][解鎖]\n  T2                   [鎖][工作][解鎖]\n  T3                                    [鎖][工作][解鎖]\n  T4                                              [鎖][工作]...\n　
n3=&gt;operation:   CPU  ████░░░░░████░░░░░████░░░░░████\n       有效   空閒   有效   空閒\n  → 效率高，自旋時間幾乎為零\n　\n  ─── 高衝突場景（多核競爭同一鎖）──────────────────────────────\n　
n4=&gt;operation:   時間 ──────────────────────────────────────────────────────────►\n        T+0      T+10us   T+20us   T+30us   T+40us\n　\n  T1   [鎖────────────────────────工作──────────────────][解鎖]\n  T2   [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥][鎖──────工作──────][解]\n  T3   [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥][鎖──]
n5=&gt;operation:   T4   [自旋🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥]\n　\n  Core 使用率：\n  Core1 ████████████████████ 100%（T1 真正工作）\n  Core2 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T2 白燒自旋）\n  Core3 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T3 白燒自旋）
n6=&gt;operation:   Core4 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 100%（T4 白燒自旋）\n        ↑\n        CPU 使用率 100% 但 75% 是無效功！\n　\n  ┌──────────────────────────────────────────────────────────┐\n  │  高衝突下 Spin Lock 的問題：                                     │
n7=&gt;operation:   │  ・多個 Core 同時在旋轉 → 浪費電力與 CPU 時間                           │\n  │  ・Cache coherence 流量激增 → 總線飽和                            │\n  │  ・其他任務無法使用被佔用的 Core                                      │\n  └──────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>低衝突很快；高衝突會燒 CPU。</p>
<h2 id="164-工程補強"><a class="header" href="#164-工程補強">16.4 工程補強</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-66"><a class="header" href="#本小節示意圖-66">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 自旋退避策略演進圖\n　\n  自旋失敗次數\n  0        1        2        4        8       16      閾值\n  │        │        │        │        │        │        │\n  ▼        ▼        ▼        ▼        ▼        ▼        ▼
n2=&gt;operation:   ┌─────────────────────────────────────────────────────┐\n  │ Plain  │ → 立即重試 CAS\n  │  Spin  │   延遲 = 0\n  └─────────────────────────────────────────────────────┘\n       │ 失敗\n       ▼
n3=&gt;operation:   ┌─────────────────────────────────────────────────────┐\n  │ yield()│ → 讓出 CPU 時間片，讓持鎖者跑\n  │        │   延遲 ≈ 1 排程週期（~100us）\n  └─────────────────────────────────────────────────────┘\n       │ 仍失敗\n       ▼
n4=&gt;operation:   ┌─────────────────────────────────────────────────────┐\n  │  Exponential Backoff                                │\n  │                                                     │\n  │  delay = min(1ms × 2^n,                             │\n  │              max_delay)                             │\n  │                                                     │
n5=&gt;operation:   │  retry 1: sleep 1ms                                 │\n  │  retry 2: sleep 2ms                                 │\n  │  retry 3: sleep 4ms                                 │\n  │  retry 4: sleep 8ms  ──────►│ 抖動 (jitter) 避免\n  │  retry 5: sleep 16ms        │ 所有執行緒同時重試\n  └─────────────────────────────────────────────────────┘
n6=&gt;operation:        │ 超過閾值（例如 64ms）\n       ▼\n  ┌─────────────────────────────────────────────────────┐\n  │  park() / futex_wait()                              │\n  │                                                     │\n  │  執行緒進入睡眠                                            │
n7=&gt;operation:   │  OS 排程器管理                                           │\n  │  鎖釋放時 unpark() 喚醒                                   │\n  │  CPU 完全釋放 → 零燒耗                                     │\n  └─────────────────────────────────────────────────────┘\n　\n  自旋次數 vs 退避延遲關係：
n8=&gt;operation: 　\n  延遲\n  (ms)\n  64 │                              ┌──────── park 阻塞\n  32 │                          ────┘\n  16 │                      ────
n9=&gt;operation:    8 │                  ────\n   4 │              ────\n   2 │          ────\n   1 │      ────\n   0 │──────  yield\n     └──────────────────────────── 自旋次數
n10=&gt;operation:       0   2   4   8  16  32  閾值
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<ul>
<li>指數退避（backoff）</li>
<li>達到閾值後改阻塞</li>
</ul>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: try CAS(lock, 0, 1)\nfail → pause → retry
st-&gt;n1
</code></pre>
<h2 id="示意圖-10"><a class="header" href="#示意圖-10">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: lock flag=0\nT1 CAS(0→1) success 進入\nT2 CAS(0→1) fail 自旋等待
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-15"><a class="header" href="#跨語言完整範例-15">跨語言完整範例</a></h2>
<h3 id="c--atomic_flag-自旋鎖4-執行緒並發測試"><a class="header" href="#c--atomic_flag-自旋鎖4-執行緒並發測試">C — atomic_flag 自旋鎖，4 執行緒並發測試</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;

#define THREADS 4
#define ITERS   50000

atomic_flag spin_lock = ATOMIC_FLAG_INIT;
long counter = 0;

void lock(void) {
    while (atomic_flag_test_and_set_explicit(&amp;spin_lock, memory_order_acquire))
        ;  /* spin */
}

void unlock(void) {
    atomic_flag_clear_explicit(&amp;spin_lock, memory_order_release);
}

void *worker(void *arg) {
    (void)arg;
    for (int i = 0; i &lt; ITERS; i++) {
        lock();
        counter++;
        unlock();
    }
    return NULL;
}

int main(void) {
    pthread_t tids[THREADS];
    for (int i = 0; i &lt; THREADS; i++)
        pthread_create(&amp;tids[i], NULL, worker, NULL);
    for (int i = 0; i &lt; THREADS; i++)
        pthread_join(tids[i], NULL);
    printf("counter = %ld (expected %d)\n", counter, THREADS * ITERS);
    return 0;
}
</code></pre>
<h3 id="c--stdatomic_flag-自旋鎖封裝"><a class="header" href="#c--stdatomic_flag-自旋鎖封裝">C++ — std::atomic_flag 自旋鎖封裝</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

class SpinLock {
    std::atomic_flag flag_ = ATOMIC_FLAG_INIT;
public:
    void lock() {
        while (flag_.test_and_set(std::memory_order_acquire))
            ;  /* spin */
    }
    void unlock() {
        flag_.clear(std::memory_order_release);
    }
};

int main() {
    SpinLock spin;
    long counter = 0;
    const int iters = 50000;
    auto task = [&amp;]() {
        for (int i = 0; i &lt; iters; i++) {
            spin.lock();
            counter++;
            spin.unlock();
        }
    };
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++)
        threads.emplace_back(task);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "counter = " &lt;&lt; counter
              &lt;&lt; " (expected " &lt;&lt; 4 * iters &lt;&lt; ")\n";
}
</code></pre>
<h3 id="rust--atomicbool-cas-自旋鎖"><a class="header" href="#rust--atomicbool-cas-自旋鎖">Rust — AtomicBool CAS 自旋鎖</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;

struct SpinLock(AtomicBool);

impl SpinLock {
    fn new() -&gt; Self { SpinLock(AtomicBool::new(false)) }
    fn lock(&amp;self) {
        while self.0
            .compare_exchange_weak(false, true, Ordering::Acquire, Ordering::Relaxed)
            .is_err()
        {
            std::hint::spin_loop();
        }
    }
    fn unlock(&amp;self) {
        self.0.store(false, Ordering::Release);
    }
}

fn main() {
    let spin = Arc::new(SpinLock::new());
    let counter = Arc::new(std::sync::atomic::AtomicI64::new(0));
    let mut handles = vec![];
    for _ in 0..4 {
        let spin = Arc::clone(&amp;spin);
        let counter = Arc::clone(&amp;counter);
        handles.push(thread::spawn(move || {
            for _ in 0..50_000 {
                spin.lock();
                counter.fetch_add(1, Ordering::Relaxed);
                spin.unlock();
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("counter = {} (expected 200000)", counter.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--atomicbool-cas-自旋鎖"><a class="header" href="#go--atomicbool-cas-自旋鎖">Go — atomic.Bool CAS 自旋鎖</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

type SpinLock struct{ held atomic.Bool }

func (s *SpinLock) Lock() {
    for !s.held.CompareAndSwap(false, true) {
        // spin
    }
}

func (s *SpinLock) Unlock() {
    s.held.Store(false)
}

func main() {
    var spin SpinLock
    var counter int64
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j &lt; 50_000; j++ {
                spin.Lock()
                counter++
                spin.Unlock()
            }
        }()
    }
    wg.Wait()
    fmt.Printf("counter = %d (expected 200000)\n", counter)
}
</code></pre>
<h3 id="python--ctypes-atomic-模擬-cas-自旋鎖"><a class="header" href="#python--ctypes-atomic-模擬-cas-自旋鎖">Python — ctypes atomic 模擬 CAS 自旋鎖</a></h3>
<pre><code class="language-python">"""Chapter 16: CAS spin lock — 4 threads, atomic counter verification."""
import threading
import time


class SpinLock:
    """用 threading.Lock 模擬 CAS atomic_flag 語意。"""

    def __init__(self):
        self._held = False
        self._internal = threading.Lock()

    def lock(self):
        while True:
            with self._internal:
                if not self._held:
                    self._held = True
                    return
            time.sleep(0)  # yield

    def unlock(self):
        with self._internal:
            self._held = False


def main():
    spin = SpinLock()
    counter = [0]
    iters = 50_000

    def worker():
        for _ in range(iters):
            spin.lock()
            counter[0] += 1
            spin.unlock()

    threads = [threading.Thread(target=worker) for _ in range(4)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    expected = 4 * iters
    print(f"counter = {counter[0]} (expected {expected})")
    assert counter[0] == expected, "競態條件！CAS 保護失效"
    print("通過：自旋鎖保護臨界區正確")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-15"><a class="header" href="#完整專案級範例python-15">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch16.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch16.py
</code></pre>
<pre><code class="language-python">"""Chapter 16: spin lock with exponential backoff."""
import threading
import time


class SpinLockWithBackoff:
    """帶指數退避的自旋鎖，高衝突時自動降低 CPU 浪費。"""

    MAX_BACKOFF_MS = 64

    def __init__(self):
        self._flag = False
        self._guard = threading.Lock()

    def lock(self):
        delay_ms = 1
        while True:
            with self._guard:
                if not self._flag:
                    self._flag = True
                    return
            # 指數退避：避免所有執行緒同時重試
            time.sleep(delay_ms / 1000)
            delay_ms = min(delay_ms * 2, self.MAX_BACKOFF_MS)

    def unlock(self):
        with self._guard:
            self._flag = False


if __name__ == "__main__":
    lk = SpinLockWithBackoff()
    state = {"x": 0}

    def work():
        for _ in range(5000):
            lk.lock()
            state["x"] += 1
            lk.unlock()

    ts = [threading.Thread(target=work) for _ in range(4)]
    for t in ts:
        t.start()
    for t in ts:
        t.join()
    print("x=", state["x"])
    assert state["x"] == 20000
    print("通過：指數退避自旋鎖保護正確")
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第17章-讀寫鎖快取實戰"><a class="header" href="#第17章-讀寫鎖快取實戰">第17章 讀寫鎖快取實戰</a></h1>
<h2 id="171-場景"><a class="header" href="#171-場景">17.1 場景</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-67"><a class="header" href="#本小節示意圖-67">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 讀寫比例與並發度對比\n　\n  典型快取存取分布：\n  ┌────────────────────────────────────────────────────────┐\n  │  操作比例                                                  │\n  │                                                        │
n2=&gt;operation:   │  Read  ████████████████████████████████████░  95%      │\n  │  Write ██░                                    5%       │\n  │                                                        │\n  └────────────────────────────────────────────────────────┘\n　\n  ─── 使用 Mutex（排他鎖）─────────────────────────────────────
n3=&gt;operation: 　\n  時間 ──────────────────────────────────────────────────────►\n  R1   [讀─]\n  R2       [等][讀─]\n  R3             [等──][讀─]\n  R4                       [等─────][讀─]
n4=&gt;operation:        ↑每次只有一個讀操作，其餘全部等待，嚴重浪費\n　\n  並發度：1 個同時（無論讀寫）\n　\n  ─── 使用 RWMutex（讀寫鎖）──────────────────────────────────\n　
n5=&gt;operation:   時間 ──────────────────────────────────────────────────────►\n  R1   [讀────────────────]\n  R2   [讀────────────────]  ← 多個讀可以同時進行\n  R3   [讀────────────────]\n  R4   [讀────────────────]\n  W1                      [等─][寫─][寫完，讀者可再進]
n6=&gt;operation: 　\n  並發度：讀者無限並發，寫者獨占\n　\n  ┌────────────────────────────────────────────────────────┐\n  │  RWMutex 帶來的效益（95% 讀場景）：                               │\n  │  ・讀吞吐量提升 ~20x（從串行讀 → 並發讀）                              │
n7=&gt;operation:   │  ・寫操作仍然安全（獨占）                                          │\n  │  ・適合：設定快取、查詢快取、計算結果快取等                                 │\n  └────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>讀多寫少的快取查詢。</p>
<h2 id="172-基本模式"><a class="header" href="#172-基本模式">17.2 基本模式</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-68"><a class="header" href="#本小節示意圖-68">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Cache 查找完整流程（含雙重檢查）\n　\n  客戶端請求 key\n       │\n       ▼\n  ┌───────────────────────────────────────────────────────────┐
n2=&gt;operation:   │  read_lock()  │  ← 允許多個讀者同時進入\n  └───────┬───────────────────────────────────────────────────┘\n          │\n          ▼\n  ┌───────────────┐    命中\n  │  cache[key]   │ ──────────────────────────────────►  return value
n3=&gt;operation:   │  存在？                                                      │\n  └───────┬───────────────────────────────────────────────────┘\n          │ 未命中（miss）\n          ▼\n  ┌───────────────────────────────────────────────────────────┐\n  │  read_unlock()  │  ← 必須先釋放讀鎖，否則無法升級為寫鎖
n4=&gt;operation:   └───────┬───────────────────────────────────────────────────┘\n          │\n          ▼\n  ┌───────────────────────────────────────────────────────────┐\n  │  write_lock() │  ← 等待所有讀者退出，獲得排他鎖\n  └───────┬───────────────────────────────────────────────────┘
n5=&gt;operation:           │\n          ▼\n  ┌───────────────────────────────────────────────────────────┐\n  │  Double-Check: cache[key] 存在？   │  ← 二次確認！\n  │                                    │    防止並發 miss 重複載入\n  └───────┬───────────────────────────────────────────────────┘
n6=&gt;operation:           │                    │\n          │ 已有（其他執行緒   │ 仍無\n          │ 搶先載入了）             │\n          ▼                    ▼\n     return value        ┌──────────────┐\n                         │  load from      │
n7=&gt;operation:                          │  DB / Source    │\n                         └──────┬──────────┘\n                                │\n                                ▼\n                         ┌─────────────────┐\n                         │  cache[key]     │
n8=&gt;operation:                          │    = value      │\n                         └──────┬──────────┘\n                                │\n                                ▼\n                         ┌─────────────────┐\n                         │  write_unlock() │
n9=&gt;operation:                          └──────┬──────────┘\n                                │\n                                ▼\n                            return value\n　\n  ┌───────────────────────────────────────────────────────────┐
n10=&gt;operation:   │  為何需要雙重檢查（Double-Check）？                                  │\n  │                                                           │\n  │  T1: miss → 釋放讀鎖 ─────────────────► 拿寫鎖 → load            │\n  │  T2: miss → 釋放讀鎖 → 等待寫鎖 ─────► 拿寫鎖 → ???                  │\n  │                                                           │\n  │  若無二次檢查：T1 load 後 T2 又 load → 重複查 DB！                     │
n11=&gt;operation:   │  加上二次檢查：T2 拿到鎖後發現已有 → 直接返回 ✓                              │\n  └───────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
n10-&gt;n11
</code></pre>
<ul>
<li>讀：拿讀鎖</li>
<li>未命中：升級流程（通常先釋放讀鎖，再拿寫鎖）</li>
<li>寫：更新後釋放寫鎖</li>
</ul>
<h2 id="173-結構設計對應-17311732"><a class="header" href="#173-結構設計對應-17311732">17.3 結構設計（對應 17.3.1~17.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-69"><a class="header" href="#本小節示意圖-69">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Cache 結構設計與 RWMutex 保護範圍\n　\n  ┌───────────────────────────────────────────────────────────────────────────────────┐\n  │                   Cache 結構體                                                       │\n  │                                                                                   │\n  │  ┌─────────────────┐   ┌─────────────────────────────┐                            │
n2=&gt;operation:   │  │  data: HashMap  │   │  RWMutex                     │                           │\n  │  │                 │   │                              │                           │\n  │  │  "user:1" → 42  │   │  RLock() / RUnlock()         │                           │\n  │  │  "user:2" → 18  │   │  ↑ 保護 data 的讀操作              │                           │\n  │  │  "user:3" → 99  │   │                              │                           │\n  │  │  ...            │   │  Lock() / Unlock()           │                           │
n3=&gt;operation:   │  └─────────────────┘   │  ↑ 保護 data 的寫操作               │                          │\n  │                         └─────────────────────────────┘                           │\n  │  ┌─────────────────────────────────────────────────────┐                          │\n  │                        │  loader: fn(key) → value                            │    │\n  │                        │  ↑ 當 cache miss 時，呼叫此函式載入資料             │                │\n  │  └─────────────────────────────────────────────────────┘                          │
n4=&gt;operation:   └───────────────────────────────────────────────────────────────────────────────────┘\n　\n  操作與鎖的對應關係：\n　\n  ┌──────────────────┬──────────────────┬─────────────────────────────────────────────┐\n  │     操作                 │    使用的鎖                       │     說明                   │
n5=&gt;operation:   ├──────────────────┼──────────────────┼─────────────────────────────────────────────┤\n  │  Get (hit)             │  RLock/RUnlock                │  多讀者並發安全                 │\n  │  Get (miss)            │  先 RUnlock                    │  釋放讀鎖後                   │\n  │                        │  再 Lock/Unlock                │  以寫鎖載入                   │\n  │  Set / Evict           │  Lock/Unlock                  │  寫者獨占                    │\n  │  Len / Keys            │  RLock/RUnlock                │  只讀統計資訊                  │
n6=&gt;operation:   └──────────────────┴──────────────────┴─────────────────────────────────────────────┘\n　\n  多讀者並發示意：\n　\n  Reader1 ──[RLock]──[讀 data]──[RUnlock]──\n  Reader2 ──[RLock]──[讀 data]──[RUnlock]──   ← 同時執行
n7=&gt;operation:   Reader3 ──[RLock]──[讀 data]──[RUnlock]──\n                                          │\n                                          ▼\n  Writer  ──────────────────────[Lock]──[寫 data]──[Unlock]──\n                                 ↑\n                           等所有 Reader 退出後才能進入
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>快取容器 + 讀寫鎖 + 載入函式。</p>
<h2 id="174-常見坑"><a class="header" href="#174-常見坑">17.4 常見坑</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-70"><a class="header" href="#本小節示意圖-70">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 坑一：鎖升級死鎖\n　\n  ┌───────────────────────────────────────────────────────────────────┐\n  │                    死鎖場景                                           │\n  │                                                                   │\n  │  Thread A                   RWMutex                               │
n2=&gt;operation:   │  ─────────────────────────────────────────────────────            │\n  │  RLock() ─────────────────► 讀鎖已獲得（readers=1）                      │\n  │  ... 處理中 ...                                                      │\n  │  Lock() ──────────────────► 等待！因為讀鎖還在                             │\n  │                             等所有讀者退出                               │\n  │          ↑                         ↓                              │
n3=&gt;operation:   │          └──── A 持有讀鎖 ─────── A 等寫鎖 ────► 死鎖！                     │\n  │                                                                   │\n  │  正確做法：                                                            │\n  │  RLock()  ─► 讀 ─► RUnlock() ─► Lock() ─► 寫 ─► Unlock()            │\n  │              ↑必須先釋放讀鎖，才能升級為寫鎖                                     │\n  └───────────────────────────────────────────────────────────────────┘
n4=&gt;operation: 　\n坑二：缺少二次檢查 → 重複載入 DB\n　\n  ┌───────────────────────────────────────────────────────────────────┐\n  │                 並發 Miss 場景                                        │\n  │                                                                   │
n5=&gt;operation:   │  時間 ──────────────────────────────────────────────────►           │\n  │                                                                   │\n  │  T1: [RLock][miss][RUnlock]         [Lock][load DB!][Unlock]      │\n  │  T2: [RLock][miss][RUnlock][等Lock─────────][load DB!][Unlock]     │\n  │  T3: [RLock][miss][RUnlock][等等Lock──────────────][load DB!]       │\n  │                                                                   │
n6=&gt;operation:   │  ↑ 沒有二次檢查 → 3 個執行緒都去 load DB → N 倍壓力！                             │\n  │                                                                   │\n  │  ───────────────────────────────────────────────────────          │\n  │                                                                   │\n  │  T1: [RLock][miss][RUnlock]         [Lock][load DB][Unlock]       │\n  │  T2: [RLock][miss][RUnlock][等Lock─────][二次檢查 hit! ][Unlock]       │
n7=&gt;operation:   │  T3: [RLock][miss][RUnlock][等等Lock──────][二次檢查 hit!][Unlock]      │\n  │                                                                   │\n  │  ↑ 有二次檢查 → 只有 T1 load DB，T2/T3 直接命中 ✓                             │\n  └───────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<ul>
<li>鎖升級死鎖</li>
<li>雙重檢查缺失造成重複載入</li>
</ul>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: read lock → miss → unlock read → lock write\n          → check again → load → write → unlock
st-&gt;n1
</code></pre>
<h2 id="示意圖-11"><a class="header" href="#示意圖-11">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: read lock → hit → return\nread lock → miss → unlock read → write lock → load → write → unlock
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-16"><a class="header" href="#跨語言完整範例-16">跨語言完整範例</a></h2>
<h3 id="c--pthread-讀寫鎖保護-map-快取"><a class="header" href="#c--pthread-讀寫鎖保護-map-快取">C — pthread 讀寫鎖保護 map 快取</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;

#define CACHE_SIZE 64

typedef struct { char key[32]; int value; int used; } Entry;

static Entry cache[CACHE_SIZE];
static pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;

static int db_load(const char *key) {
    return (int)strlen(key) * 7;  /* 模擬資料庫查詢 */
}

int get_or_load(const char *key) {
    pthread_rwlock_rdlock(&amp;rwlock);
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (cache[i].used &amp;&amp; strcmp(cache[i].key, key) == 0) {
            int v = cache[i].value;
            pthread_rwlock_unlock(&amp;rwlock);
            return v;
        }
    }
    pthread_rwlock_unlock(&amp;rwlock);

    pthread_rwlock_wrlock(&amp;rwlock);
    /* 雙重檢查 */
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (cache[i].used &amp;&amp; strcmp(cache[i].key, key) == 0) {
            int v = cache[i].value;
            pthread_rwlock_unlock(&amp;rwlock);
            return v;
        }
    }
    int val = db_load(key);
    for (int i = 0; i &lt; CACHE_SIZE; i++) {
        if (!cache[i].used) {
            strncpy(cache[i].key, key, 31);
            cache[i].value = val;
            cache[i].used = 1;
            break;
        }
    }
    pthread_rwlock_unlock(&amp;rwlock);
    return val;
}

int main(void) {
    printf("alpha = %d\n", get_or_load("alpha"));
    printf("alpha = %d (cached)\n", get_or_load("alpha"));
    printf("beta  = %d\n", get_or_load("beta"));
    return 0;
}
</code></pre>
<h3 id="c--shared_mutex-讀寫鎖快取"><a class="header" href="#c--shared_mutex-讀寫鎖快取">C++ — shared_mutex 讀寫鎖快取</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;shared_mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

class RWCache {
    std::unordered_map&lt;std::string, int&gt; data_;
    mutable std::shared_mutex mu_;

    int load_from_db(const std::string &amp;key) {
        return static_cast&lt;int&gt;(key.size()) * 7;
    }
public:
    int get(const std::string &amp;key) {
        {
            std::shared_lock r(mu_);
            auto it = data_.find(key);
            if (it != data_.end()) return it-&gt;second;
        }
        std::unique_lock w(mu_);
        auto it = data_.find(key);  /* double-check */
        if (it != data_.end()) return it-&gt;second;
        int val = load_from_db(key);
        data_[key] = val;
        return val;
    }
};

int main() {
    RWCache cache;
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++) {
        threads.emplace_back([&amp;cache, i]() {
            std::string key = "key" + std::to_string(i % 2);
            for (int j = 0; j &lt; 100; j++) {
                int v = cache.get(key);
                (void)v;
            }
        });
    }
    for (auto &amp;t : threads) t.join();
    std::cout &lt;&lt; "alpha=" &lt;&lt; cache.get("alpha") &lt;&lt; "\n";
    std::cout &lt;&lt; "完成：多讀者並發無競態\n";
}
</code></pre>
<h3 id="rust--rwlock-讀寫快取"><a class="header" href="#rust--rwlock-讀寫快取">Rust — RwLock<HashMap> 讀寫快取</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::thread;

struct RwCache {
    data: RwLock&lt;HashMap&lt;String, i32&gt;&gt;,
}

impl RwCache {
    fn new() -&gt; Self {
        RwCache { data: RwLock::new(HashMap::new()) }
    }
    fn get_or_load(&amp;self, key: &amp;str) -&gt; i32 {
        {
            let r = self.data.read().unwrap();
            if let Some(&amp;v) = r.get(key) { return v; }
        }
        let mut w = self.data.write().unwrap();
        if let Some(&amp;v) = w.get(key) { return v; }  /* double-check */
        let val = key.len() as i32 * 7;
        w.insert(key.to_string(), val);
        val
    }
}

fn main() {
    let cache = Arc::new(RwCache::new());
    let mut handles = vec![];
    for i in 0..4 {
        let c = Arc::clone(&amp;cache);
        handles.push(thread::spawn(move || {
            let key = format!("key{}", i % 2);
            for _ in 0..100 {
                let _ = c.get_or_load(&amp;key);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("alpha={}", cache.get_or_load("alpha"));
    println!("完成：Rust RwLock 快取正確");
}</code></pre></pre>
<h3 id="go--syncrwmutex-讀寫快取"><a class="header" href="#go--syncrwmutex-讀寫快取">Go — sync.RWMutex 讀寫快取</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

type RWCache struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewRWCache() *RWCache {
    return &amp;RWCache{data: make(map[string]int)}
}

func (c *RWCache) GetOrLoad(key string) int {
    c.mu.RLock()
    if v, ok := c.data[key]; ok {
        c.mu.RUnlock()
        return v
    }
    c.mu.RUnlock()

    c.mu.Lock()
    defer c.mu.Unlock()
    if v, ok := c.data[key]; ok { // double-check
        return v
    }
    val := len(key) * 7
    c.data[key] = val
    return val
}

func main() {
    cache := NewRWCache()
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id%2)
            for j := 0; j &lt; 100; j++ {
                cache.GetOrLoad(key)
            }
        }(i)
    }
    wg.Wait()
    fmt.Printf("alpha=%d\n", cache.GetOrLoad("alpha"))
    fmt.Println("完成：Go RWMutex 快取正確")
}
</code></pre>
<h3 id="python--threadingrlock-讀寫快取模擬"><a class="header" href="#python--threadingrlock-讀寫快取模擬">Python — threading.RLock 讀寫快取模擬</a></h3>
<pre><code class="language-python">"""Chapter 17: RW-lock cache — multi-reader concurrent, miss loads once."""
import threading
import time


class RWCache:
    def __init__(self, loader):
        self._data = {}
        self._lock = threading.Lock()
        self._readers = 0
        self._read_lock = threading.Lock()
        self._write_lock = threading.Lock()
        self._loader = loader

    def _rlock(self):
        with self._read_lock:
            self._readers += 1
            if self._readers == 1:
                self._write_lock.acquire()

    def _runlock(self):
        with self._read_lock:
            self._readers -= 1
            if self._readers == 0:
                self._write_lock.release()

    def get(self, key):
        self._rlock()
        val = self._data.get(key)
        self._runlock()
        if val is not None:
            return val
        with self._write_lock:
            if key in self._data:       # double-check
                return self._data[key]
            val = self._loader(key)
            self._data[key] = val
            return val


def main():
    load_count = [0]

    def db_load(key):
        load_count[0] += 1
        time.sleep(0.01)               # 模擬 DB 延遲
        return len(key) * 7

    cache = RWCache(db_load)
    results = []
    lock = threading.Lock()

    def reader(key):
        v = cache.get(key)
        with lock:
            results.append(v)

    threads = [threading.Thread(target=reader, args=("alpha",)) for _ in range(8)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    print(f"alpha 值: {results[0]}, 所有結果一致: {len(set(results)) == 1}")
    print(f"DB 實際載入次數: {load_count[0]} (應為 1，雙重檢查生效)")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-16"><a class="header" href="#完整專案級範例python-16">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch17.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch17.py
</code></pre>
<pre><code class="language-python">"""Chapter 17: rw-lock cache (simple)."""
import threading

cache = {}
lock = threading.RLock()


def get_or_load(k: str) -&gt; int:
    with lock:
        if k in cache:
            return cache[k]
    with lock:
        if k not in cache:
            cache[k] = len(k)
        return cache[k]


if __name__ == "__main__":
    print(get_or_load("alpha"))
    print(get_or_load("alpha"))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第18章-aqs-可重入鎖實戰"><a class="header" href="#第18章-aqs-可重入鎖實戰">第18章 AQS 可重入鎖實戰</a></h1>
<h2 id="181-目標"><a class="header" href="#181-目標">18.1 目標</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-71"><a class="header" href="#本小節示意圖-71">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 手寫鎖 vs OS Mutex 功能對比\n　\n  ┌──────────────────────┬──────────────────┬──────────────────────────────┐\n  │       功能             │   手寫可重入鎖     │     OS Mutex                     │\n  ├──────────────────────┼──────────────────┼──────────────────────────────┤\n  │  互斥保護                │  ✓               │  ✓                           │
n2=&gt;operation:   ├──────────────────────┼──────────────────┼──────────────────────────────┤\n  │  可重入                 │  ✓ 計數器追蹤     │  △ 依 OS/語言而定                     │\n  │  (同執行緒多次鎖)           │    state 欄位    │    pthread 預設不可                │\n  ├──────────────────────┼──────────────────┼──────────────────────────────┤\n  │  可阻塞等待               │  ✓ park/unpark   │  ✓                           │\n  ├──────────────────────┼──────────────────┼──────────────────────────────┤
n3=&gt;operation:   │  可喚醒                 │  ✓ unpark 精確   │  ✓                             │\n  │                      │    喚醒指定執行緒   │                                  │\n  ├──────────────────────┼──────────────────┼──────────────────────────────┤\n  │  可超時                 │  ✓ 需自行實作     │  △ 部分 OS 支援                      │\n  │  (tryLock + timeout) │    計時邏輯      │    timedwait                     │\n  ├──────────────────────┼──────────────────┼──────────────────────────────┤
n4=&gt;operation:   │  可中斷                 │  ✓ 需自行實作     │  △ 依實作而定                         │\n  │  (interrupt 喚醒)      │    中斷標記      │                                  │\n  ├──────────────────────┼──────────────────┼──────────────────────────────┤\n  │  公平性控制               │  ✓ 可選公平/     │  ✗ 通常 OS 決定                      │\n  │                      │    非公平佇列     │                                  │\n  ├──────────────────────┼──────────────────┼──────────────────────────────┤
n5=&gt;operation:   │  自訂條件變數數量            │  ✓ 多個 Condition│  △ 有限                          │\n  └──────────────────────┴──────────────────┴──────────────────────────────┘\n　\n  目標：自己做出「可重入 + 可阻塞等待 + 可喚醒」的鎖，\n        同時支援超時與中斷路徑。
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>自己做出「可重入 + 可阻塞等待 + 可喚醒」的鎖。</p>
<h2 id="182-狀態定義"><a class="header" href="#182-狀態定義">18.2 狀態定義</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-72"><a class="header" href="#本小節示意圖-72">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 可重入鎖的三個核心欄位\n　\n  ┌───────────────────────────────────────────────────────────────────────────┐\n  │                   ReentrantLock 結構                                        │\n  │                                                                           │\n  │  ┌──────────────────────────────────────────────────┐                     │
n2=&gt;operation:   │  │  state: AtomicInt                                │                     │\n  │  │                                                  │                     │\n  │  │   0    → 鎖空閒（free）                               │                     │\n  │  │   1    → 被持有一次                                   │                     │\n  │  │   2    → 同一執行緒重入兩次                               │                     │\n  │  │   n    → 同一執行緒重入 n 次                             │                     │
n3=&gt;operation:   │  │                                                  │                     │\n  │  │  作用：追蹤重入深度，state→0 才真正釋放鎖                        │                     │\n  │  └──────────────────────────────────────────────────┘                     │\n  │                                                                           │\n  │  ┌──────────────────────────────────────────────────┐                     │\n  │  │  owner: Thread (nullable)                        │                     │
n4=&gt;operation:   │  │                                                  │                     │\n  │  │   null     → 無人持有                                │                     │\n  │  │   Thread A → Thread A 持有                         │                     │\n  │  │                                                  │                     │\n  │  │  作用：判斷當前執行緒是否為持有者                                │                     │\n  │  │        若是 → state++（重入）                          │                     │
n5=&gt;operation:   │  │        若否 → 進入等待佇列                               │                     │\n  │  └──────────────────────────────────────────────────┘                     │\n  │                                                                           │\n  │  ┌──────────────────────────────────────────────────┐                     │\n  │  │  waiters: Queue&lt;Thread&gt;                          │                     │\n  │  │                                                  │                     │
n6=&gt;operation:   │  │   [Thread B] → [Thread C] → [Thread D] → null    │                     │\n  │  │                                                  │                     │\n  │  │  作用：FIFO 佇列儲存等待的執行緒                              │                     │\n  │  │        公平鎖：按入隊順序喚醒                               │                     │\n  │  │        非公平鎖：允許搶占                                 │                     │\n  │  └──────────────────────────────────────────────────┘                     │
n7=&gt;operation:   └───────────────────────────────────────────────────────────────────────────┘\n　\n  三個欄位的協作：\n　\n  owner=Thread A, state=2, waiters=[B, C]\n　
n8=&gt;operation:   Thread A 再次 lock() → owner==A → state=3（重入）\n  Thread B 呼叫 lock() → owner!=B → 入隊，park()
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<ul>
<li><code>state</code>: 重入次數</li>
<li><code>owner</code>: 持有者執行緒</li>
<li>queue: 等待節點</li>
</ul>
<h2 id="183-獲取與釋放對應-18311833"><a class="header" href="#183-獲取與釋放對應-18311833">18.3 獲取與釋放（對應 18.3.1~18.3.3）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-73"><a class="header" href="#本小節示意圖-73">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 可重入鎖狀態機\n　\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  lock() 流程                                                       │\n  └──────────────────────────────────────────────────────────────────┘\n　
n2=&gt;operation:   Thread 呼叫 lock()\n         │\n         ▼\n  ┌──────────────────┐   是    ┌──────────────────────────────────────┐\n  │ owner == current │ ──────► │  state++（重入）      │──► 返回\n  │ 執行緒？             │         │  state=1→2→3→...                    │
n3=&gt;operation:   └──────┬───────────┘         └─────────────────────────────────────┘\n         │ 否\n         ▼\n  ┌──────────────────┐   是    ┌──────────────────────────────────────┐\n  │  state == 0？     │ ──────► │  CAS(state, 0, 1)                   │\n  │  鎖空閒？            │         │  owner = current      │──► 進入臨界區
n4=&gt;operation:   └──────┬───────────┘         └─────────────────────────────────────┘\n         │ 否（鎖被他人持有）\n         ▼\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  入隊（enqueue）                                                     │\n  │  park()睡眠等待  │◄──────────────────────────────────┐
n5=&gt;operation:   └──────┬───────────┘                                   │\n         │ 被 unpark() 喚醒                                  │\n         ▼                                               │\n  ┌──────────────────┐   失敗（被搶占）                   │\n  │  retry: 重新嘗試 │ ─────────────────────────────────►┘\n  │  CAS(0→1)                                                        │
n6=&gt;operation:   └──────────────────────────────────────────────────────────────────┘\n　\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  unlock() 流程                                                     │\n  └──────────────────────────────────────────────────────────────────┘\n　
n7=&gt;operation:   Thread 呼叫 unlock()\n         │\n         ▼\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  assert owner == current（必須是持有者才能解鎖）                             │\n  └──────────────────────────────────────────────────────────────────┘
n8=&gt;operation:          │\n         ▼\n         state--\n         │\n         ├─── state &gt; 0 ──► 仍有重入層，繼續持有鎖，返回\n         │
n9=&gt;operation:          └─── state == 0 ──► 真正釋放\n                    │\n                    ▼\n             owner = null\n                    │\n                    ▼
n10=&gt;operation:          ┌────────────────────────────────────────────────┐\n         │  waiters 佇列有人？                                 │\n         └──────┬─────────────────────────────────────────┘\n                │ 有              │ 無\n                ▼                 ▼\n         取出隊首 Thread        鎖空閒
n11=&gt;operation:          unpark() 喚醒          等待下次競爭\n　\n  重入計數示意：\n  ┌──────────────────────────────────────────────────────────────────┐\n  │  outer() {          inner() {                                    │\n  │    lock()  state=1    lock()  state=2                            │
n12=&gt;operation:   │    inner()            ...                                        │\n  │    unlock() state=1   unlock() state=1                           │\n  │  }                  }                                            │\n  │                                                                  │\n  │  state: 1 ──► 2 ──► 1 ──► 0（真正釋放）                                │\n  └──────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
n10-&gt;n11
n11-&gt;n12
</code></pre>
<ul>
<li>owner 再次進入：<code>state++</code></li>
<li>其他執行緒：排隊等待</li>
<li>釋放：<code>state--</code> 到 0 才真正解鎖</li>
</ul>
<h2 id="184-測試面向"><a class="header" href="#184-測試面向">18.4 測試面向</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-74"><a class="header" href="#本小節示意圖-74">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 可重入鎖測試矩陣\n　\n  ┌─────────────────────┬────────────────────────┬──────────────────────────────────────┐\n  │     測試面向            │     測試方法                │     驗收標準                            │\n  ├─────────────────────┼────────────────────────┼──────────────────────────────────────┤\n  │  可重入正確性             │  同一執行緒連續 lock()         │  不死鎖                                │
n2=&gt;operation:   │                     │  N 次後 unlock() N 次      │  state 歸零後其他執行                      │\n  │                     │  驗證臨界區資料一致性             │  緒可正常獲得鎖                            │\n  ├─────────────────────┼────────────────────────┼──────────────────────────────────────┤\n  │  競爭公平性              │  M 個執行緒並發競爭             │  每個執行緒等待時間                          │\n  │                     │  記錄各自獲鎖時間               │  差異在合理範圍內                           │\n  │                     │  計算標準差                  │  （公平模式）                             │
n3=&gt;operation:   ├─────────────────────┼────────────────────────┼──────────────────────────────────────┤\n  │  中斷路徑               │  執行緒等待鎖時                │  中斷後執行緒正確退出                         │\n  │                     │  從另一執行緒發送中斷             │  不留殭屍                               │\n  │                     │  驗證等待執行緒退出              │  鎖狀態保持一致                            │\n  ├─────────────────────┼────────────────────────┼──────────────────────────────────────┤\n  │  超時路徑               │  tryLock(timeout=100ms) │  超時後返回 false                        │
n4=&gt;operation:   │                     │  持鎖者睡眠 200ms            │  不死鎖                                │\n  │                     │  等待者應超時返回               │  計時誤差 &lt; 10ms                        │\n  ├─────────────────────┼────────────────────────┼──────────────────────────────────────┤\n  │  多條件變數              │  producer/consumer 模型   │  signal 精確喚醒一個                      │\n  │                     │  condition.await()      │  signalAll 喚醒全部                     │\n  │                     │  condition.signal()     │  不丟失喚醒                              │
n5=&gt;operation:   ├─────────────────────┼────────────────────────┼──────────────────────────────────────┤\n  │  壓力測試               │  1000 執行緒 × 10000       │  計數器最終值正確                           │\n  │                     │  次 lock/unlock          │  無資料競態                              │\n  │                     │  原子計數器累加                │  無死鎖                                │\n  └─────────────────────┴────────────────────────┴──────────────────────────────────────┘\n　
n6=&gt;operation:   測試覆蓋路徑圖：\n　\n  lock()\n  ├─ owner == self ─► state++ ─► [可重入路徑] ✓\n  ├─ state == 0    ─► CAS 成功 ─► [首次獲取路徑] ✓\n  ├─ state == 0    ─► CAS 失敗 ─► retry ─► [競爭路徑] ✓
n7=&gt;operation:   ├─ state &gt; 0     ─► park() ─► unpark ─► [等待喚醒路徑] ✓\n  ├─ state &gt; 0     ─► park() ─► interrupt ─► [中斷路徑] ✓\n  └─ state &gt; 0     ─► tryLock + timeout ─► [超時路徑] ✓
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<ul>
<li>可重入正確性</li>
<li>競爭時公平性/吞吐</li>
<li>中斷與超時路徑</li>
</ul>
<h2 id="示意圖-12"><a class="header" href="#示意圖-12">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: owner=T1, state=2 (重入2次)\nT1 unlock → state=1\nT1 unlock → state=0 → 喚醒下一個
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-17"><a class="header" href="#跨語言完整範例-17">跨語言完整範例</a></h2>
<h3 id="c--pthread_mutex_t-遞迴鎖pthread_mutex_recursive"><a class="header" href="#c--pthread_mutex_t-遞迴鎖pthread_mutex_recursive">C — pthread_mutex_t 遞迴鎖（PTHREAD_MUTEX_RECURSIVE）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

static pthread_mutex_t mu;
static int shared_value = 0;

void inner_work(void) {
    pthread_mutex_lock(&amp;mu);      /* 重入：同執行緒第二次鎖 */
    shared_value += 10;
    printf("inner: shared_value = %d\n", shared_value);
    pthread_mutex_unlock(&amp;mu);
}

void outer_work(void) {
    pthread_mutex_lock(&amp;mu);      /* 第一次鎖 */
    shared_value += 1;
    printf("outer before inner: shared_value = %d\n", shared_value);
    inner_work();                 /* 呼叫 inner，不應死鎖 */
    printf("outer after inner: shared_value = %d\n", shared_value);
    pthread_mutex_unlock(&amp;mu);
}

int main(void) {
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&amp;attr);
    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&amp;mu, &amp;attr);
    pthread_mutexattr_destroy(&amp;attr);

    pthread_t t1, t2;
    pthread_create(&amp;t1, NULL, (void *(*)(void *))outer_work, NULL);
    pthread_create(&amp;t2, NULL, (void *(*)(void *))outer_work, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("最終 shared_value = %d (expected 22)\n", shared_value);
    pthread_mutex_destroy(&amp;mu);
    return 0;
}
</code></pre>
<h3 id="c--stdrecursive_mutex-可重入鎖"><a class="header" href="#c--stdrecursive_mutex-可重入鎖">C++ — std::recursive_mutex 可重入鎖</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

std::recursive_mutex rmu;
int shared_value = 0;

void inner_work() {
    std::lock_guard&lt;std::recursive_mutex&gt; lk(rmu);  /* 重入 */
    shared_value += 10;
    std::cout &lt;&lt; "inner: " &lt;&lt; shared_value &lt;&lt; "\n";
}

void outer_work() {
    std::lock_guard&lt;std::recursive_mutex&gt; lk(rmu);  /* 首次鎖 */
    shared_value += 1;
    inner_work();  /* 同執行緒再次鎖，不應死鎖 */
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; 4; i++)
        threads.emplace_back(outer_work);
    for (auto &amp;t : threads)
        t.join();
    std::cout &lt;&lt; "最終 shared_value = " &lt;&lt; shared_value
              &lt;&lt; " (expected 44)\n";
}
</code></pre>
<h3 id="rust--parking_lotreentrantmutex-可重入鎖"><a class="header" href="#rust--parking_lotreentrantmutex-可重入鎖">Rust — parking_lot::ReentrantMutex 可重入鎖</a></h3>
<pre><pre class="playground"><code class="language-rust">use parking_lot::ReentrantMutex;
use std::cell::Cell;
use std::sync::Arc;
use std::thread;

fn inner_work(lock: &amp;ReentrantMutex&lt;Cell&lt;i32&gt;&gt;) {
    let guard = lock.lock();          /* 重入：同執行緒第二次 */
    guard.set(guard.get() + 10);
    println!("inner: {}", guard.get());
}

fn outer_work(lock: Arc&lt;ReentrantMutex&lt;Cell&lt;i32&gt;&gt;&gt;) {
    let guard = lock.lock();          /* 首次鎖 */
    guard.set(guard.get() + 1);
    drop(guard);                      /* Rust 需手動 drop 才能重入 */
    inner_work(&amp;lock);
}

fn main() {
    let lock = Arc::new(ReentrantMutex::new(Cell::new(0)));
    let mut handles = vec![];
    for _ in 0..4 {
        let l = Arc::clone(&amp;lock);
        handles.push(thread::spawn(move || outer_work(l)));
    }
    for h in handles { h.join().unwrap(); }
    println!("最終值 = {}", lock.lock().get());
}</code></pre></pre>
<h3 id="go--syncmutex--輔助函式go-無原生-recursive-mutex用呼叫鏈迴避"><a class="header" href="#go--syncmutex--輔助函式go-無原生-recursive-mutex用呼叫鏈迴避">Go — sync.Mutex + 輔助函式（Go 無原生 recursive mutex，用呼叫鏈迴避）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
)

// Go 的 sync.Mutex 不可重入，正確做法是把鎖傳遞給子函式
// 而非在子函式重複 Lock 同一把鎖
type ReentrantGuard struct {
    mu    sync.Mutex
    owner int64
    depth int
    once  sync.Mutex
}

var mu sync.Mutex
var sharedValue int

// outer 持鎖後直接呼叫 inner（不再重複鎖）
func inner(val *int) {
    *val += 10
    fmt.Printf("inner: shared_value = %d\n", *val)
}

func outer() {
    mu.Lock()
    defer mu.Unlock()
    sharedValue += 1
    inner(&amp;sharedValue) // inner 不重複 Lock，由 outer 持有鎖
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 4; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            outer()
        }()
    }
    wg.Wait()
    fmt.Printf("最終 shared_value = %d (expected 44)\n", sharedValue)
}
</code></pre>
<h3 id="python--threadingrlock-可重入鎖"><a class="header" href="#python--threadingrlock-可重入鎖">Python — threading.RLock 可重入鎖</a></h3>
<pre><code class="language-python">"""Chapter 18: reentrant lock — outer calls inner, both lock same RLock."""
import threading

rlock = threading.RLock()
shared_value = 0


def inner_work():
    with rlock:           # RLock 允許同執行緒第二次進入
        global shared_value
        shared_value += 10
        print(f"inner: shared_value = {shared_value}")


def outer_work():
    with rlock:           # 首次獲得鎖
        global shared_value
        shared_value += 1
        inner_work()      # 同執行緒再次 with rlock，不應死鎖


def main():
    threads = [threading.Thread(target=outer_work) for _ in range(4)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    print(f"最終 shared_value = {shared_value} (expected 44)")
    assert shared_value == 44, "RLock 可重入失敗！"
    print("通過：RLock 可重入，outer 呼叫 inner 不死鎖")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-17"><a class="header" href="#完整專案級範例python-17">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch18.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch18.py
</code></pre>
<pre><code class="language-python">"""Chapter 18: reentrant lock."""
import threading

r = threading.RLock()


def outer():
    with r:
        inner()


def inner():
    with r:
        print("reentered")


if __name__ == "__main__":
    outer()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第19章-分散式鎖架構"><a class="header" href="#第19章-分散式鎖架構">第19章 分散式鎖架構</a></h1>
<h2 id="191-為什麼需要分散式鎖"><a class="header" href="#191-為什麼需要分散式鎖">19.1 為什麼需要分散式鎖</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-75"><a class="header" href="#本小節示意圖-75">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 單節點 vs 多節點鎖的邊界\n　\n  ─── 單節點（JVM Mutex 夠用）─────────────────────────────────\n　\n  ┌───────────────────────────────────────────────────────────┐\n  │           App Instance                                    │
n2=&gt;operation:   │                                                           │\n  │  Thread A ──┐                                             │\n  │             ├─► [JVM Mutex] ─► DB                         │\n  │  Thread B ──┘                                             │\n  │   (等待)                                                    │\n  └───────────────────────────────────────────────────────────┘
n3=&gt;operation:   ✓ 同一 JVM 內，mutex 可保護共享資源\n　\n  ─── 多節點（JVM Mutex 失效）────────────────────────────────\n　\n  ┌─────────────────────┐       ┌─────────────────────────────┐\n  │   App Instance 1    │       │   App Instance 2            │
n4=&gt;operation:   │                     │       │                             │\n  │  [JVM Lock A]       │       │  [JVM Lock B]               │\n  │  ↑ 只保護本 JVM         │       │  ↑ 只保護本 JVM                 │\n  └──────────┬──────────┘       └──────────┬──────────────────┘\n             │                              │\n             │ 都能同時存取                       │
n5=&gt;operation:              ▼                             ▼\n  ┌───────────────────────────────────────────────────────────┐\n  │              共享資源：DB / Redis / 文件                         │\n  │                                                           │\n  │  Lock A 和 Lock B 互不可見 → 兩個實例同時操作 → 競態                     │\n  └───────────────────────────────────────────────────────────┘
n6=&gt;operation: 　\n  ✗ 跨 JVM / 跨進程 / 跨機器 → 需要分散式鎖\n　\n  ─── 分散式鎖解法 ────────────────────────────────────────────\n　\n  ┌─────────────────────┐       ┌─────────────────────────────┐
n7=&gt;operation:   │   App Instance 1    │       │   App Instance 2            │\n  └──────────┬──────────┘       └──────────┬──────────────────┘\n             │                              │\n             │ 先搶鎖                       │ 搶鎖失敗，等待\n             ▼                             ▼\n  ┌───────────────────────────────────────────────────────────┐
n8=&gt;operation:   │           Redis / ZooKeeper（分散式鎖服務）                       │\n  │                                                           │\n  │   lock:order = "instance-1-uuid"  TTL=10s                 │\n  └───────────────────────────────────────────────────────────┘\n             │ 持有鎖\n             ▼
n9=&gt;operation:   ┌───────────────────────────────────────────────────────────┐\n  │                    共享資源：DB                                │\n  └───────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>單機鎖只能管單進程，服務多副本時會失效。</p>
<h2 id="192-超賣案例對應-19211922"><a class="header" href="#192-超賣案例對應-19211922">19.2 超賣案例（對應 19.2.1~19.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-76"><a class="header" href="#本小節示意圖-76">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: read-modify-write 競態導致超賣\n　\n  時間軸 ──────────────────────────────────────────────────────►\n           T+0      T+1      T+2      T+3      T+4      T+5\n　\n  App1    [讀 stock]                  [扣減]   [寫 stock=0]
n2=&gt;operation:            stock=1                    stock=1-1=0\n　\n  App2              [讀 stock]                  [扣減]   [寫 stock=-1]\n                     stock=1                    stock=1-1=0\n                     ↑ 讀到舊值！                ↑ 再次扣減 → 超賣！\n　
n3=&gt;operation:   ┌───────────────────────────────────────────────────────────┐\n  │  問題根源：Read-Modify-Write 非原子                               │\n  │                                                           │\n  │  Step 1: stock = DB.read("stock_001")   → stock = 1       │\n  │  Step 2: if stock &gt; 0: stock -= 1       → stock = 0       │\n  │  Step 3: DB.write("stock_001", stock)   → stock = 0       │
n4=&gt;operation:   │                                                           │\n  │  兩個 App 在 Step 1 和 Step 3 之間沒有互斥                          │\n  │  → 都讀到 stock=1 → 都認為可以扣減 → stock 變 -1                     │\n  └───────────────────────────────────────────────────────────┘\n　\n  正確做法：加分散式鎖後
n5=&gt;operation: 　\n  App1    [取鎖 ✓][讀 stock=1][扣減][寫 stock=0][釋放鎖]\n  App2    [等鎖─────────────────────────────][取鎖][讀 stock=0][售罄]\n　\n  結果：stock = 0（正確），不超賣
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
</code></pre>
<p>多節點同時扣庫存，若無跨節點互斥，庫存會變負數。</p>
<h2 id="193-jvm-本地鎖邊界對應-19311932"><a class="header" href="#193-jvm-本地鎖邊界對應-19311932">19.3 JVM 本地鎖邊界（對應 19.3.1~19.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-77"><a class="header" href="#本小節示意圖-77">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: JVM 本地鎖的可見範圍邊界\n　\n  ┌─────────────────────────────────────────────────────────────────────────────┐\n  │  機器 A                                                                       │\n  │  ┌────────────────────────────────────────────────────────┐                 │\n  │  │  App Instance 1 (JVM)                                  │                 │
n2=&gt;operation:   │  │                                                        │                 │\n  │  │  synchronized(lockObj) { ... }  ← JVM 鎖                │                 │\n  │  │  ┌──────────────────────────┐                          │                 │\n  │  │  │  Thread Pool             │                          │                 │\n  │  │  │  T1 ──┐                  │                          │                 │\n  │  │  │       ├─► [JVM Lock] ✓   │                          │                 │
n3=&gt;operation:   │  │  │  T2 ──┘                  │                          │                 │\n  │  │  └──────────────────────────┘                          │                 │\n  │  └────────────────────────────────────────────────────────┘                 │\n  └─────────────────────────────────────────────────────────────────────────────┘\n                      │ JVM Lock 邊界到此為止\n                      │ 鎖的狀態不會跨越這條線
n4=&gt;operation:   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─\n  網路                 │\n  ┌────────────────────▼────────────────────────────────────────────────────────┐\n  │  機器 B                                                                       │\n  │  ┌────────────────────────────────────────────────────────┐                 │\n  │  │  App Instance 2 (JVM)                                  │                 │
n5=&gt;operation:   │  │                                                        │                 │\n  │  │  synchronized(lockObj) { ... }  ← 完全獨立的 JVM 鎖          │                 │\n  │  │  ↑ 和機器A的鎖物件不同，互不可見                                     │                 │\n  │  └────────────────────────────────────────────────────────┘                 │\n  └─────────────────────────────────────────────────────────────────────────────┘\n                      │
n6=&gt;operation:                       ▼\n  ┌─────────────────────────────────────────────────────────────────────────────┐\n  │  共享資源：MySQL / Redis                                                         │\n  │  兩個 App 可以同時操作 → 競態！                                                        │\n  └─────────────────────────────────────────────────────────────────────────────┘\n　
n7=&gt;operation:   結論：synchronized 只在同 JVM 內有效，\n        水平擴展後必須用外部分散式鎖。
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p><code>synchronized</code> 只在同 JVM 內有效。</p>
<h2 id="194-分散式鎖要求對應-19411942"><a class="header" href="#194-分散式鎖要求對應-19411942">19.4 分散式鎖要求（對應 19.4.1~19.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-78"><a class="header" href="#本小節示意圖-78">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 分散式鎖五大需求與實現挑戰\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  需求 1：互斥性（Mutual Exclusion）                                   │\n  │  同一時刻只有一個客戶端持有鎖                                               │\n  │  實現：Redis SET NX（Not Exist）原子指令                               │
n2=&gt;operation:   │  挑戰：網路分區時可能出現兩個持有者                                            │\n  └───────────────────────────────────────────────────────────────┘\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  需求 2：不死鎖（No Deadlock）                                        │\n  │  持鎖客戶端崩潰後，鎖必須自動釋放                                             │
n3=&gt;operation:   │  實現：TTL 自動過期（SET NX PX 10000）                                 │\n  │  挑戰：TTL 設定多長？太短 → 任務未完鎖已過期                                    │\n  └───────────────────────────────────────────────────────────────┘\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  需求 3：可重入（Reentrancy）                                         │
n4=&gt;operation:   │  同一客戶端可多次獲取同一把鎖                                               │\n  │  實現：鎖值包含 clientID，每次重入計數                                      │\n  │  挑戰：需要 Lua 腳本保證 check-increment 原子性                           │\n  └───────────────────────────────────────────────────────────────┘\n　\n  ┌───────────────────────────────────────────────────────────────┐
n5=&gt;operation:   │  需求 4：高可用（High Availability）                                  │\n  │  鎖服務本身不能是單點                                                   │\n  │  實現：Redis Sentinel / Cluster；ZooKeeper Quorum                 │\n  │  挑戰：主從切換窗口期可能導致鎖丟失                                            │\n  └───────────────────────────────────────────────────────────────┘\n　
n6=&gt;operation:   ┌───────────────────────────────────────────────────────────────┐\n  │  需求 5：可續租（Watchdog / Lease Renewal）                           │\n  │  任務執行時間超過 TTL 時，自動延長鎖的生命週期                                    │\n  │  實現：後台執行緒定期 EXPIRE key new_ttl                                │\n  │  挑戰：續租執行緒本身崩潰 → 鎖不再續租 → 自然過期                                  │\n  └───────────────────────────────────────────────────────────────┘
n7=&gt;operation: 　\n  各需求依賴關係：\n  互斥 ──► NX 指令\n  不死鎖 ──► TTL\n  誤刪保護 ──► UUID value\n  可重入 ──► Lua 原子 check-increment
n8=&gt;operation:   可續租 ──► Watchdog 執行緒
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<ul>
<li>互斥</li>
<li>可釋放（不死鎖）</li>
<li>故障可恢復</li>
<li>最好可重入/可續租</li>
</ul>
<h2 id="195-apcp-取捨對應-19511954"><a class="header" href="#195-apcp-取捨對應-19511954">19.5 AP/CP 取捨（對應 19.5.1~19.5.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-79"><a class="header" href="#本小節示意圖-79">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: CAP 定理與分散式鎖選型\n　\n           一致性 (C)\n              ▲\n              │\n              │   CP 區域
n2=&gt;operation:               │   ZooKeeper ●\n              │   etcd      ●\n              │\n              │\n  ────────────┼────────────────────► 可用性 (A)\n              │
n3=&gt;operation:               │   AP 區域\n              │              ● Redis (主從)\n              │              ● Redis Cluster\n              │\n  (P = 分區容忍，實際分散式系統必須接受 P)\n　
n4=&gt;operation:   ─── Redis (偏 AP) ──────────────────────────────────────────\n　\n  優點：\n  ・極高吞吐（單機 10萬+ QPS）\n  ・低延遲（sub-millisecond）\n  ・部署簡單
n5=&gt;operation: 　\n  弱點：\n  ・主從複製非同步 → 主節點掛掉切換期間，新主可能無鎖記錄\n  ・Cluster 模式 → SET NX 無法跨 slot 原子操作\n  ・Redlock 演算法有爭議（時鐘漂移問題）\n　
n6=&gt;operation:   適用：電商庫存、快取更新、冪等控制等容忍極短暫鎖丟失的場景\n　\n  ─── ZooKeeper (偏 CP) ──────────────────────────────────────\n　\n  優點：\n  ・強一致性（Zab 協議 Quorum 提交）
n7=&gt;operation:   ・臨時節點 + Watcher 天然支援鎖失效通知\n  ・公平鎖（順序節點）\n　\n  弱點：\n  ・寫入延遲高（需要多數節點確認）\n  ・單機 QPS 約 1 萬（vs Redis 10 萬+）
n8=&gt;operation:   ・ZooKeeper 本身是有狀態的複雜系統\n　\n  適用：金融交易、配置管理、Leader 選舉等強一致性要求的場景\n　\n  ┌──────────────────────────────────────────────────────────┐\n  │  選型建議：                                                   │
n9=&gt;operation:   │  ・高吞吐 + 可接受極短暫不一致 → Redis                                │\n  │  ・強一致 + 低吞吐可接受     → ZooKeeper / etcd                    │\n  └──────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>Redis 常偏 AP；ZooKeeper 常偏 CP。</p>
<h2 id="196-redis-鎖演進對應-196119612"><a class="header" href="#196-redis-鎖演進對應-196119612">19.6 Redis 鎖演進（對應 19.6.1~19.6.12）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-80"><a class="header" href="#本小節示意圖-80">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Redis 分散式鎖四代演進\n　\n  ─────────────────────────────────────────────────────────────\n  V1：SET NX（最簡版）\n  ─────────────────────────────────────────────────────────────\n　
n2=&gt;operation:   SET lock_key 1 NX\n       │\n       ▼\n  ✓ 獲得鎖\n  DEL lock_key  ← 崩潰時沒執行 → 鎖永久存在 → 死鎖！\n　
n3=&gt;operation:   問題：無 TTL，崩潰後永不釋放\n　\n  ─────────────────────────────────────────────────────────────\n  V2：SET NX PX ttl（加 TTL）\n  ─────────────────────────────────────────────────────────────\n　
n4=&gt;operation:   SET lock_key 1 NX PX 10000\n       │\n       ▼\n  ✓ 獲得鎖（10秒後自動過期）\n  DEL lock_key  ← 若任務執行時間 &gt; 10s，鎖已被其他人拿走\n                  此時 DEL 刪掉別人的鎖！→ 誤刪！
n5=&gt;operation: 　\n  問題：鎖的 value 沒有身份，誰都可以刪\n　\n  ─────────────────────────────────────────────────────────────\n  V3：SET NX PX + Lua 原子 check-delete（加身份驗證）\n  ─────────────────────────────────────────────────────────────
n6=&gt;operation: 　\n  SET lock_key {uuid} NX PX 10000\n       │\n       ▼\n  ✓ 獲得鎖\n  解鎖時執行 Lua 腳本（原子）：
n7=&gt;operation:   ┌──────────────────────────────────────────────────────────────┐\n  │  if redis.call('GET', key) == uuid then                      │\n  │      return redis.call('DEL', key)                           │\n  │  else                                                        │\n  │      return 0  -- 不是我的鎖，不刪                                   │\n  │  end                                                         │
n8=&gt;operation:   └──────────────────────────────────────────────────────────────┘\n　\n  問題：任務執行超過 TTL → 鎖過期 → 他人取鎖 → 兩個持有者！\n　\n  ─────────────────────────────────────────────────────────────\n  V4：Lua + Watchdog 續租（完整版）
n9=&gt;operation:   ─────────────────────────────────────────────────────────────\n　\n  ┌──────────────────────────────────────────────────────────────┐\n  │                                                              │\n  │  主執行緒                   Watchdog 執行緒                         │\n  │  ──────────────────────     ────────────────────────         │
n10=&gt;operation:   │  SET lock {uuid} NX PX 30s                                   │\n  │  開始執行業務邏輯 ─────────► 每 10s 執行：                               │\n  │                             EXPIRE lock 30s (續租)             │\n  │  業務完成                   ↑ 確保鎖不過期                             │\n  │  Lua check-delete ─────────► Watchdog 停止                     │\n  │                                                              │
n11=&gt;operation:   │  若主執行緒崩潰：                                                    │\n  │  Watchdog 也停止 → 鎖 TTL 自然倒數 → 30s 後自動釋放                       │\n  └──────────────────────────────────────────────────────────────┘\n　\n  演進總結：\n  ┌──────┬──────────────────┬────────────────────────────────────┐
n12=&gt;operation:   │  版本  │  解決的問題         │  引入的問題                               │\n  ├──────┼──────────────────┼────────────────────────────────────┤\n  │  V1  │  互斥            │  崩潰 → 死鎖                             │\n  │  V2  │  死鎖（TTL）       │  誤刪他人的鎖                              │\n  │  V3  │  誤刪（UUID+Lua）  │  任務超時鎖過期                             │\n  │  V4  │  超時（Watchdog）  │  Watchdog 複雜度增加                      │
n13=&gt;operation:   └──────┴──────────────────┴────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
n10-&gt;n11
n11-&gt;n12
n12-&gt;n13
</code></pre>
<ol>
<li><code>SET key val NX PX ttl</code></li>
<li><code>finally</code> 解鎖</li>
<li>用 Lua 比對 value 再刪（防誤刪）</li>
<li>看門狗續租（避免任務未完鎖先過期）</li>
</ol>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: ClientA set lock=uuidA ttl=10s\nClientB 不能覆蓋\nunlock 必須檢查 value==uuidA
st-&gt;n1
</code></pre>
<h2 id="示意圖-13"><a class="header" href="#示意圖-13">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: App1 --SET NX PX-→ Redis(lock:order)\nApp2 --SET NX PX-→ fail (已被占用)\nApp1 --Lua check value then del-→ unlock
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-18"><a class="header" href="#跨語言完整範例-18">跨語言完整範例</a></h2>
<h3 id="c--mockredis-模擬-set-nx-px--lua-check-delete"><a class="header" href="#c--mockredis-模擬-set-nx-px--lua-check-delete">C — MockRedis 模擬 SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;pthread.h&gt;

#define KEY_MAX 64
#define VAL_MAX 64

typedef struct {
    char key[KEY_MAX];
    char val[VAL_MAX];
    long expire_ms;        /* UNIX 毫秒時間戳，0 表示無記錄 */
    int  used;
} RedisEntry;

#define STORE_SIZE 16
static RedisEntry store[STORE_SIZE];
static pthread_mutex_t store_mu = PTHREAD_MUTEX_INITIALIZER;

static long now_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &amp;ts);
    return ts.tv_sec * 1000L + ts.tv_nsec / 1000000L;
}

/* SET key val NX PX ttl → 1: 成功, 0: 已存在 */
int redis_set_nx_px(const char *key, const char *val, int ttl_ms) {
    pthread_mutex_lock(&amp;store_mu);
    long now = now_ms();
    int slot = -1;
    for (int i = 0; i &lt; STORE_SIZE; i++) {
        if (store[i].used &amp;&amp; strcmp(store[i].key, key) == 0) {
            if (store[i].expire_ms &gt; now) { /* 鎖仍有效 */
                pthread_mutex_unlock(&amp;store_mu);
                return 0;
            }
            slot = i;  /* 已過期，可覆蓋 */
            break;
        }
        if (!store[i].used &amp;&amp; slot == -1) slot = i;
    }
    if (slot == -1) { pthread_mutex_unlock(&amp;store_mu); return 0; }
    strncpy(store[slot].key, key, KEY_MAX - 1);
    strncpy(store[slot].val, val, VAL_MAX - 1);
    store[slot].expire_ms = now + ttl_ms;
    store[slot].used = 1;
    pthread_mutex_unlock(&amp;store_mu);
    return 1;
}

/* Lua: if GET(key)==val then DEL(key) end → 1: 刪成功, 0: 不是自己的鎖 */
int redis_lua_unlock(const char *key, const char *val) {
    pthread_mutex_lock(&amp;store_mu);
    for (int i = 0; i &lt; STORE_SIZE; i++) {
        if (store[i].used &amp;&amp; strcmp(store[i].key, key) == 0) {
            if (strcmp(store[i].val, val) == 0) {
                store[i].used = 0;
                pthread_mutex_unlock(&amp;store_mu);
                return 1;
            }
            break;
        }
    }
    pthread_mutex_unlock(&amp;store_mu);
    return 0;
}

int main(void) {
    const char *key = "lock:order";
    const char *uuid_a = "client-A-uuid";
    const char *uuid_b = "client-B-uuid";

    int ok = redis_set_nx_px(key, uuid_a, 10000);
    printf("Client A 加鎖: %s\n", ok ? "成功" : "失敗");

    ok = redis_set_nx_px(key, uuid_b, 10000);
    printf("Client B 加鎖: %s (應為失敗)\n", ok ? "成功" : "失敗");

    /* Client B 嘗試刪 Client A 的鎖 → 應失敗 */
    ok = redis_lua_unlock(key, uuid_b);
    printf("Client B 解鎖: %s (應為失敗)\n", ok ? "成功" : "失敗");

    ok = redis_lua_unlock(key, uuid_a);
    printf("Client A 解鎖: %s (應為成功)\n", ok ? "成功" : "失敗");

    ok = redis_set_nx_px(key, uuid_b, 10000);
    printf("Client B 再次加鎖: %s (應為成功)\n", ok ? "成功" : "失敗");
    return 0;
}
</code></pre>
<h3 id="c--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#c--mockredis-set-nx-px--lua-check-delete">C++ — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
#include &lt;string&gt;

class MockRedis {
    struct Entry { std::string val; long long expire_ms; };
    std::unordered_map&lt;std::string, Entry&gt; store_;
    std::mutex mu_;

    long long now_ms() {
        using namespace std::chrono;
        return duration_cast&lt;milliseconds&gt;(
            steady_clock::now().time_since_epoch()).count();
    }
public:
    bool set_nx_px(const std::string &amp;key, const std::string &amp;val, int ttl_ms) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        auto it = store_.find(key);
        if (it != store_.end() &amp;&amp; it-&gt;second.expire_ms &gt; now_ms())
            return false;
        store_[key] = {val, now_ms() + ttl_ms};
        return true;
    }
    bool lua_unlock(const std::string &amp;key, const std::string &amp;val) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        auto it = store_.find(key);
        if (it != store_.end() &amp;&amp; it-&gt;second.val == val) {
            store_.erase(it);
            return true;
        }
        return false;
    }
};

int main() {
    MockRedis redis;
    std::string key = "lock:order";
    std::string uuid_a = "client-A-uuid";
    std::string uuid_b = "client-B-uuid";

    std::cout &lt;&lt; "A 加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_a, 10000) &lt;&lt; "\n";
    std::cout &lt;&lt; "B 加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_b, 10000)
              &lt;&lt; " (應為0)\n";
    std::cout &lt;&lt; "B 解鎖: " &lt;&lt; redis.lua_unlock(key, uuid_b)
              &lt;&lt; " (應為0，誤刪保護生效)\n";
    std::cout &lt;&lt; "A 解鎖: " &lt;&lt; redis.lua_unlock(key, uuid_a) &lt;&lt; "\n";
    std::cout &lt;&lt; "B 再加鎖: " &lt;&lt; redis.set_nx_px(key, uuid_b, 10000) &lt;&lt; "\n";
}
</code></pre>
<h3 id="rust--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#rust--mockredis-set-nx-px--lua-check-delete">Rust — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

struct MockRedis {
    store: Mutex&lt;HashMap&lt;String, (String, Instant)&gt;&gt;,
}

impl MockRedis {
    fn new() -&gt; Self {
        MockRedis { store: Mutex::new(HashMap::new()) }
    }
    fn set_nx_px(&amp;self, key: &amp;str, val: &amp;str, ttl_ms: u64) -&gt; bool {
        let mut store = self.store.lock().unwrap();
        if let Some((_, exp)) = store.get(key) {
            if exp.elapsed() &lt; Duration::from_millis(0) {
                return false; // still valid
            }
        }
        let entry = store.entry(key.to_string()).or_insert_with(|| {
            (String::new(), Instant::now())
        });
        if entry.1.elapsed().as_millis() == 0 &amp;&amp; !entry.0.is_empty() {
            return false;
        }
        *entry = (val.to_string(), Instant::now() + Duration::from_millis(ttl_ms));
        true
    }
    fn lua_unlock(&amp;self, key: &amp;str, val: &amp;str) -&gt; bool {
        let mut store = self.store.lock().unwrap();
        if let Some((v, _)) = store.get(key) {
            if v == val {
                store.remove(key);
                return true;
            }
        }
        false
    }
}

fn main() {
    let redis = Arc::new(MockRedis::new());
    println!("A 加鎖: {}", redis.set_nx_px("lock:order", "uuid-a", 10000));
    println!("B 加鎖: {} (應為false)", redis.set_nx_px("lock:order", "uuid-b", 10000));
    println!("B 解鎖: {} (應為false，誤刪保護)", redis.lua_unlock("lock:order", "uuid-b"));
    println!("A 解鎖: {}", redis.lua_unlock("lock:order", "uuid-a"));
    println!("B 再加鎖: {}", redis.set_nx_px("lock:order", "uuid-b", 10000));
}</code></pre></pre>
<h3 id="go--mockredis-set-nx-px--lua-check-delete"><a class="header" href="#go--mockredis-set-nx-px--lua-check-delete">Go — MockRedis SET NX PX + Lua check-delete</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "time"
)

type entry struct {
    val    string
    expiry time.Time
}

type MockRedis struct {
    mu    sync.Mutex
    store map[string]entry
}

func NewMockRedis() *MockRedis {
    return &amp;MockRedis{store: make(map[string]entry)}
}

func (r *MockRedis) SetNXPX(key, val string, ttl time.Duration) bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    if e, ok := r.store[key]; ok &amp;&amp; time.Now().Before(e.expiry) {
        return false
    }
    r.store[key] = entry{val, time.Now().Add(ttl)}
    return true
}

// LuaUnlock 模擬原子 check-delete
func (r *MockRedis) LuaUnlock(key, val string) bool {
    r.mu.Lock()
    defer r.mu.Unlock()
    if e, ok := r.store[key]; ok &amp;&amp; e.val == val {
        delete(r.store, key)
        return true
    }
    return false
}

func main() {
    redis := NewMockRedis()
    ttl := 10 * time.Second
    fmt.Println("A 加鎖:", redis.SetNXPX("lock:order", "uuid-a", ttl))
    fmt.Println("B 加鎖:", redis.SetNXPX("lock:order", "uuid-b", ttl), "(應為false)")
    fmt.Println("B 解鎖:", redis.LuaUnlock("lock:order", "uuid-b"), "(應為false，誤刪保護)")
    fmt.Println("A 解鎖:", redis.LuaUnlock("lock:order", "uuid-a"))
    fmt.Println("B 再加鎖:", redis.SetNXPX("lock:order", "uuid-b", ttl))
}
</code></pre>
<h3 id="python--mockredis-set-nx-px--lua-check-delete多執行緒驗證"><a class="header" href="#python--mockredis-set-nx-px--lua-check-delete多執行緒驗證">Python — MockRedis SET NX PX + Lua check-delete（多執行緒驗證）</a></h3>
<pre><code class="language-python">"""Chapter 19: distributed lock protocol — MockRedis NX PX + Lua check-delete."""
import threading
import time
import uuid


class MockRedis:
    """模擬 Redis SET NX PX 與 Lua 原子解鎖。"""

    def __init__(self):
        self._store = {}          # key → (value, expire_time)
        self._mu = threading.Lock()

    def set_nx_px(self, key: str, val: str, ttl_ms: int) -&gt; bool:
        """SET key val NX PX ttl → True: 成功取鎖"""
        deadline = time.monotonic() + ttl_ms / 1000
        with self._mu:
            cur = self._store.get(key)
            if cur and cur[1] &gt; time.monotonic():
                return False       # 鎖仍有效，NX 失敗
            self._store[key] = (val, deadline)
            return True

    def lua_unlock(self, key: str, val: str) -&gt; bool:
        """原子 check-and-delete：只有 value 匹配才刪除"""
        with self._mu:
            cur = self._store.get(key)
            if cur and cur[0] == val:
                del self._store[key]
                return True
            return False           # 不是自己的鎖，拒絕刪除


def acquire_and_work(redis: MockRedis, client_id: str, results: list):
    lock_key = "lock:order"
    token = f"{client_id}:{uuid.uuid4()}"
    ok = redis.set_nx_px(lock_key, token, 3000)
    results.append((client_id, "acquired" if ok else "failed"))
    if ok:
        time.sleep(0.05)          # 模擬業務處理
        released = redis.lua_unlock(lock_key, token)
        results.append((client_id, "released" if released else "release_failed"))


def main():
    redis = MockRedis()

    # 基本流程測試
    uuid_a = "client-A"
    ok = redis.set_nx_px("lock:order", uuid_a, 5000)
    print(f"A 加鎖: {ok}")                          # True
    ok = redis.set_nx_px("lock:order", "client-B", 5000)
    print(f"B 加鎖: {ok} (應為 False)")             # False
    ok = redis.lua_unlock("lock:order", "client-B")
    print(f"B 解鎖: {ok} (應為 False，誤刪保護)")   # False
    ok = redis.lua_unlock("lock:order", uuid_a)
    print(f"A 解鎖: {ok}")                          # True

    # 並發競爭測試
    print("\n並發競爭測試（10 客戶端搶同一把鎖）：")
    results = []
    threads = [
        threading.Thread(target=acquire_and_work,
                         args=(redis, f"client-{i}", results))
        for i in range(10)
    ]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    acquired = [r for r in results if r[1] == "acquired"]
    print(f"成功取鎖數量: {len(acquired)} (應為 1，互斥保證)")
    assert len(acquired) == 1, "互斥性失敗！"
    print("通過：分散式鎖互斥性正確")


if __name__ == "__main__":
    main()
</code></pre>
<h2 id="完整專案級範例python-18"><a class="header" href="#完整專案級範例python-18">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch19.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch19.py
</code></pre>
<pre><code class="language-python">"""Chapter 19: distributed lock protocol (mocked redis)."""
import time


class MockRedis:
    def __init__(self):
        self.store = {}

    def set_nx_px(self, key: str, val: str, ttl_ms: int) -&gt; bool:
        now = time.time() * 1000
        cur = self.store.get(key)
        if cur and cur[1] &gt; now:
            return False
        self.store[key] = (val, now + ttl_ms)
        return True

    def unlock_if_value(self, key: str, val: str) -&gt; bool:
        cur = self.store.get(key)
        if cur and cur[0] == val:
            del self.store[key]
            return True
        return False


if __name__ == "__main__":
    r = MockRedis()
    owner = "uuid-a"
    ok = r.set_nx_px("lock:order", owner, 3000)
    print("lock acquired", ok)
    print("unlock", r.unlock_if_value("lock:order", owner))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第20章-秒殺系統架構"><a class="header" href="#第20章-秒殺系統架構">第20章 秒殺系統架構</a></h1>
<h2 id="201-電商基礎架構"><a class="header" href="#201-電商基礎架構">20.1 電商基礎架構</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-81"><a class="header" href="#本小節示意圖-81">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 電商系統分層架構\n　\n  使用者請求\n       │\n       ▼\n  ┌──────────────────────────────────────────────────────────────────────┐
n2=&gt;operation:   │  接入層                                                                 │\n  │  ┌──────────────┐    ┌──────────────┐                                │\n  │  │     CDN          │    │    Nginx       │                          │\n  │  │  靜態資源            │    │  反向代理          │                          │\n  │  │  快取              │    │  負載均衡          │                          │\n  │  └──────────────┘    └──────────────┘                                │
n3=&gt;operation:   └────────────────────────────┬─────────────────────────────────────────┘\n                               │ 動態請求\n                               ▼\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  閘道層                                                                 │\n  │  ┌──────────────┐    ┌──────────────┐                                │
n4=&gt;operation:   │  │  限流              │    │  認證/鑑權         │                          │\n  │  │  Token Bucket    │    │  JWT / Session │                          │\n  │  └──────────────┘    └──────────────┘                                │\n  └────────────────────────────┬─────────────────────────────────────────┘\n                               │\n                               ▼
n5=&gt;operation:   ┌──────────────────────────────────────────────────────────────────────┐\n  │  業務層                                                                 │\n  │  ┌──────────────────┐  ┌──────────────────┐                          │\n  │  │    訂單服務          │  │    庫存服務          │                          │\n  │  │  OrderService    │  │  StockService    │                          │\n  │  │  防重 / 支付         │  │  扣減 / 補償         │                          │
n6=&gt;operation:   │  └────────┬─────────┘  └────────┬─────────┘                          │\n  └───────────┼─────────────────────┼────────────────────────────────────┘\n              │                     │\n              ▼                     ▼\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  快取層                                                                 │
n7=&gt;operation:   │  ┌──────────────────────────────────────┐                            │\n  │  │  Redis Cluster                       │                            │\n  │  │  ・庫存計數（stock:sku:001 = 1000）         │                            │\n  │  │  ・防重 Token（setnx order:uid）          │                            │\n  │  │  ・限流計數器                              │                            │\n  │  └──────────────────────────────────────┘                            │
n8=&gt;operation:   └────────────────────────────┬─────────────────────────────────────────┘\n                               │ 讀未命中 / 最終持久化\n                               ▼\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  資料層                                                                 │\n  │  ┌──────────────────────────────────────┐                            │
n9=&gt;operation:   │  │  MySQL（主從分離）                         │                            │\n  │  │  ・訂單表 / 庫存表                          │                            │\n  │  │  ・對賬記錄                               │                            │\n  │  └──────────────────────────────────────┘                            │\n  └──────────────────────────────────────────────────────────────────────┘\n              │                     ↑
n10=&gt;operation:               ▼                     │ Consumer 消費\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  異步層                                                                 │\n  │  ┌──────────────────┐  ┌──────────────────┐                          │\n  │  │  MQ（Kafka/RMQ）   │  │  Consumer Worker │                          │\n  │  │  削峰平滑流量          │  │  非同步落庫           │                          │
n11=&gt;operation:   │  └──────────────────┘  └──────────────────┘                          │\n  └──────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
n10-&gt;n11
</code></pre>
<p>入口層、業務層、資料層、異步層缺一不可。</p>
<h2 id="202-秒殺特性對應-20212022"><a class="header" href="#202-秒殺特性對應-20212022">20.2 秒殺特性（對應 20.2.1~20.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-82"><a class="header" href="#本小節示意圖-82">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 正常流量 vs 秒殺瞬間流量對比\n　\n  QPS\n  (萬)\n  100 │         ▐█▌\n      │         ███
n2=&gt;operation:       │         ███\n   50 │         ███\n      │         ███\n      │         ███\n   10 │─────────███──────────────────────────────────── 正常基線\n    1 │         ███████████████████████
n3=&gt;operation:       │         ████████████████████████████\n    0 └─────────┼──────────────────────────────────────► 時間\n              秒殺   ←── 持續約 5 分鐘 ───►  流量回落\n              開始\n              T0\n　
n4=&gt;operation:   ┌──────────────────────────────────────────────────────────┐\n  │  秒殺瞬間特性：                                                 │\n  │                                                          │\n  │  ・流量是平時的 100x（10萬 QPS vs 正常 1000 QPS）                    │\n  │  ・熱點 key：少數 SKU 被高頻存取（Redis 熱點問題）                        │\n  │  ・超賣風險：多節點並發扣減同一庫存                                       │
n5=&gt;operation:   │  ・重複下單：用戶多次點擊「搶購」按鈕                                      │\n  │  ・容錯窗口極短：5 分鐘內必須解決，無法慢慢修                                 │\n  └──────────────────────────────────────────────────────────┘\n　\n  關鍵挑戰：\n  ┌─────────────────┬────────────────────────────────────────┐
n6=&gt;operation:   │  問題            │  應對策略                                   │\n  ├─────────────────┼────────────────────────────────────────┤\n  │  熱點 key        │  庫存分段（多個 Redis key 分散）                  │\n  │  超賣            │  Lua 原子扣減 + 回滾                          │\n  │  重複下單        │  SETNX 冪等 Token                           │\n  │  DB 打爆         │  異步 MQ 削峰                               │
n7=&gt;operation:   └─────────────────┴────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>高峰值、瞬時流量、熱點資料、低容錯窗口。</p>
<h2 id="203-活動前中後對應-20312032"><a class="header" href="#203-活動前中後對應-20312032">20.3 活動前中後（對應 20.3.1~20.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-83"><a class="header" href="#本小節示意圖-83">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 秒殺活動生命週期時間軸\n　\n  ─── 活動前（T0 之前）───────────────────────────────────────\n　\n  T-24h    T-1h      T-10min   T0（秒殺開始）\n    │         │           │         │
n2=&gt;operation:     ▼         ▼           ▼         ▼\n  [庫存    [壓測       [暖機      [流量\n   資料     模擬        Redis      湧入]\n   預熱]    100x        庫存]\n            流量]                ← 必須在 T0 前完成所有準備\n　
n3=&gt;operation:   預熱快取：\n  ・提前 SET stock:sku:001 1000（庫存寫入 Redis）\n  ・提前載入商品詳情到快取（避免秒殺時打 DB）\n　\n  壓測：\n  ・使用 wrk/JMeter 模擬 10萬 QPS
n4=&gt;operation:   ・確認系統瓶頸、調整連線池/執行緒池\n　\n  擴容：\n  ・水平擴展應用層（K8s 預先 scale out）\n  ・Redis 記憶體確認充裕\n　
n5=&gt;operation:   ─── 秒殺進行中（T0 ~ T0+5min）──────────────────────────────\n　\n  T0              T0+1min         T0+5min\n   │                 │                │\n   ▼                 ▼                ▼\n  [限流閘道]      [庫存售罄]      [流量回落]
n6=&gt;operation:   [MQ 緩衝]       [標記售罄標誌]  [等待 MQ 消化]\n  [降級靜態頁]     [拒絕後續請求]\n　\n  ─── 活動後（T0+5min 之後）─────────────────────────────────\n　\n  T0+5min      T0+1h         T0+24h
n7=&gt;operation:       │            │               │\n      ▼            ▼               ▼\n  [Consumer   [對賬：         [縮容：\n   消化 MQ]    Redis庫存      釋放多餘\n  [落庫訂單]   vs DB庫存]    應用實例]\n               [補償異常單]
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<ul>
<li>前：預熱快取、壓測、擴容</li>
<li>中：限流、降級、削峰</li>
<li>後：對賬、補償、回放</li>
</ul>
<h2 id="204-同步與異步下單對應-20412042"><a class="header" href="#204-同步與異步下單對應-20412042">20.4 同步與異步下單（對應 20.4.1~20.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-84"><a class="header" href="#本小節示意圖-84">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 同步下單 vs 異步下單對比\n　\n  ─── 同步下單（直接寫 DB）───────────────────────────────────\n　\n  User ──► API Server ──► MySQL DB\n                │                              │
n2=&gt;operation:                 │             │ 每次請求直接寫 DB\n                │◄────────────┘ 響應 200ms~2s\n                │\n  問題：\n  ・10 萬 QPS → DB 無法承受（通常 MySQL 上限 1000~5000 QPS）\n  ・響應時間長 → 連線池耗盡 → 雪崩
n3=&gt;operation: 　\n  時間軸：\n  Req1 ──► [API] ──────[DB寫]──► 回應\n  Req2 ──► [API] ──────[DB寫]──► 回應\n  ...\n  Req1000 ──► [API] ──► DB 超載！逾時！
n4=&gt;operation: 　\n  ─── 異步下單（MQ 削峰）──────────────────────────────────────\n　\n  User ──► API Server ──► MQ (Kafka) ──► Consumer ──► MySQL DB\n                │              │               │\n                │              │ 毫秒級入隊    │ 按 DB 速率消費
n5=&gt;operation:                 │◄─────────────┘               │ （平滑寫入）\n                │ 立即返回「搶購成功，訂單處理中」\n　\n  時間軸：\n  T=0:   User 請求 API → 入 MQ → 立即返回（&lt; 10ms）\n  T=1s:  Consumer 消費 MQ → 寫 DB（每秒 5000 條）
n6=&gt;operation:   T=20s: 所有訂單落庫完成\n　\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  比較                                                                  │\n  │  ┌──────────────┬────────────────┬────────────────────┐              │\n  │  │              │  同步下單       │  異步下單              │                 │
n7=&gt;operation:   │  ├──────────────┼────────────────┼────────────────────┤              │\n  │  │  響應時間        │  200ms~2s      │  &lt; 10ms             │             │\n  │  │  DB 峰值壓力     │  = 用戶 QPS    │  Consumer 速率控制    │                 │\n  │  │  用戶體驗        │  等待結果       │  樂觀返回+通知           │                 │\n  │  │  複雜度         │  低            │  高（需 MQ+補償）      │                 │\n  │  └──────────────┴────────────────┴────────────────────┘              │
n8=&gt;operation:   └──────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>同步直寫簡單但容易打爆；異步用 MQ 平滑流量。</p>
<h2 id="205-扣庫存策略對應-20512055"><a class="header" href="#205-扣庫存策略對應-20512055">20.5 扣庫存策略（對應 20.5.1~20.5.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-85"><a class="header" href="#本小節示意圖-85">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 三種扣庫存時機比較\n　\n  ─── 策略一：下單時扣庫存 ──────────────────────────────────\n　\n  用戶下單 ─► 扣減 stock ─► 建立訂單 ─► 等待支付 ─► 支付完成\n                │
n2=&gt;operation:                 └► 若超時未支付 → 需要定時任務歸還庫存\n　\n  優點：超賣風險低（下單即鎖定）\n  缺點：惡意用戶可佔庫存不付款；持鎖時間長\n　\n  ─── 策略二：付款時扣庫存 ──────────────────────────────────
n3=&gt;operation: 　\n  用戶下單 ─► 建立訂單(不扣庫存) ─► 支付完成 ─► 扣減 stock\n                                                   │\n                                                   └► 可能已無庫存\n                                                      → 超賣！\n　
n4=&gt;operation:   優點：庫存利用率高\n  缺點：超賣風險高（多人下單 → 同時支付 → 最後才扣庫存）\n　\n  ─── 策略三：預扣 + 支付確認（最安全）────────────────────\n　\n  用戶下單
n5=&gt;operation:        │\n       ▼\n  Redis 預扣：DECR stock:sku:001\n       │\n       ├── 成功（&gt;= 0）─► 建立預訂單（鎖定庫存）\n       │                          │
n6=&gt;operation:        │                   ▼\n       │             用戶支付\n       │                          │\n       │             ┌─────┴──────┐\n       │             │            │\n       │          支付成功      支付失敗/超時
n7=&gt;operation:        │             │            │\n       │          DB 落庫      補償：INCR stock 歸還\n       │\n       └── 失敗（&lt; 0）─► INCR 回滾 ─► 返回售罄\n　\n  ┌─────────────────────────────────────────────────────────────────┐
n8=&gt;operation:   │  策略對比                                                           │\n  │  ┌──────────┬──────────┬──────────┬──────────────────┐          │\n  │  │  策略    │  超賣風險   │  持鎖時間    │  補償複雜度       │                 │\n  │  ├──────────┼──────────┼──────────┼──────────────────┤          │\n  │  │  下單扣   │  低       │  長       │  定時任務歸還     │                 │\n  │  │  付款扣   │  高       │  短       │  超賣後補        │                │
n9=&gt;operation:   │  │  預扣+確認 │ 極低      │  中       │  INCR 補償       │               │\n  │  └──────────┴──────────┴──────────┴──────────────────┘          │\n  └─────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>下單扣、付款扣、預扣各有一致性風險。</p>
<h2 id="206-redis-庫存與防超賣對應-20612064"><a class="header" href="#206-redis-庫存與防超賣對應-20612064">20.6 Redis 庫存與防超賣（對應 20.6.1~20.6.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-86"><a class="header" href="#本小節示意圖-86">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Redis Lua 原子扣減防超賣 + SETNX 防重下單\n　\n  ─── Lua 原子扣減流程 ─────────────────────────────────────\n　\n  用戶請求\n       │
n2=&gt;operation:        ▼\n  ┌───────────────────────────────────────────────────────┐\n  │  Lua 腳本（原子執行，不被中斷）                                    │\n  │                                                       │\n  │  local stock = redis.call('DECR', KEYS[1])            │\n  │                                                       │
n3=&gt;operation:   │  if stock &gt;= 0 then                                   │\n  │      return 1  -- 扣減成功                                │\n  │  else                                                 │\n  │      redis.call('INCR', KEYS[1])  -- 回滾               │\n  │      return 0  -- 售罄                                  │\n  │  end                                                  │
n4=&gt;operation:   └───────────────────────────────────────────────────────┘\n       │ 返回 1 or 0\n       │\n       ├── 1（成功）──► 進入下單流程\n       │\n       └── 0（售罄）──► 返回「已售罄」頁面
n5=&gt;operation: 　\n  ─── SETNX 防重下單 ───────────────────────────────────────\n　\n  用戶 uid=1001 點擊搶購\n       │\n       ▼
n6=&gt;operation:   SETNX order:1001:sku:001 "1"  EX 300\n       │\n       ├── 成功（首次）──► 允許下單\n       │\n       └── 失敗（已有）──► 返回「您已下單，請勿重複」\n　
n7=&gt;operation:   ─── 整體防超賣流程 ───────────────────────────────────────\n　\n  請求進入\n       │\n       ▼\n  [限流檢查：令牌桶]
n8=&gt;operation:        │ 通過\n       ▼\n  [防重檢查：SETNX order:uid:sku]\n       │ 非重複\n       ▼\n  [Lua 原子扣庫存：DECR stock:sku]
n9=&gt;operation:        │ stock &gt;= 0\n       ▼\n  [入 MQ 異步落庫]\n       │\n       ▼\n  [返回：「搶購成功」]
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>原子扣減 + 分段庫存 + 防重 + 風控。</p>
<h2 id="207-系統與網路優化對應-20712074"><a class="header" href="#207-系統與網路優化對應-20712074">20.7 系統與網路優化（對應 20.7.1~20.7.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-87"><a class="header" href="#本小節示意圖-87">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 系統調優清單\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  OS 層優化                                                       │\n  │                                                               │\n  │  ・ulimit -n 65535   → 增大最大檔案/連線數                              │
n2=&gt;operation:   │  ・/proc/sys/net/core/somaxconn → 增大 listen backlog            │\n  │  ・TCP_NODELAY → 關閉 Nagle 算法，降低延遲                              │\n  │  ・vm.swappiness=1 → 減少 swap，避免延遲尖刺                            │\n  └───────────────────────────────────────────────────────────────┘\n　\n  ┌───────────────────────────────────────────────────────────────┐
n3=&gt;operation:   │  網路層優化                                                        │\n  │                                                               │\n  │  ・TCP keepalive → 複用連線，避免頻繁三次握手                               │\n  │  ・SO_REUSEPORT → 多個 worker 共用同一 port，核心分流                     │\n  │                                                               │\n  │    ┌──────────┐  ┌──────────┐  ┌──────────┐                   │
n4=&gt;operation:   │    │ Worker 1 │  │ Worker 2 │  │ Worker 3 │                   │\n  │    │  :8080   │  │  :8080   │  │  :8080   │                   │\n  │    └──────────┘  └──────────┘  └──────────┘                   │\n  │         ↑              ↑              ↑                       │\n  │    核心按 CPU 親和性分發連線（SO_REUSEPORT）                              │\n  └───────────────────────────────────────────────────────────────┘
n5=&gt;operation: 　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  連線池優化                                                        │\n  │                                                               │\n  │  DB 連線池：                                                      │\n  │  ・pool_size = CPU核數 × 2（避免過多上下文切換）                            │
n6=&gt;operation:   │  ・max_overflow = pool_size × 2                                │\n  │  ・pool_timeout = 30s（避免無限等待）                                  │\n  │                                                               │\n  │  Redis 連線池：                                                   │\n  │  ・每個應用節點保持 10~50 個長連線                                         │\n  │  ・避免頻繁 connect/disconnect                                     │
n7=&gt;operation:   └───────────────────────────────────────────────────────────────┘\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  CDN 與靜態資源                                                    │\n  │                                                               │\n  │  用戶 ──► CDN（命中） ──► 直接返回靜態頁（不過業務層）                            │
n8=&gt;operation:   │       └── CDN（未命中）──► 回源 Nginx ──► 快取                         │\n  │                                                               │\n  │  秒殺頁面應 100% 靜態化：                                              │\n  │  ・商品詳情頁：提前生成 HTML                                             │\n  │  ・圖片/JS/CSS：CDN 邊緣節點快取                                        │\n  │  ・倒計時：前端 JS 本地計算，不請求後端                                        │
n9=&gt;operation:   └───────────────────────────────────────────────────────────────┘\n　\n  整體優化效益：\n　\n  項目          優化前      優化後\n  ────────────────────────────────
n10=&gt;operation:   最大 QPS      1萬         20萬\n  P99 延遲      500ms       20ms\n  DB 壓力       100%        10%（MQ 削峰）\n  CPU 使用率    90%（白旋） 60%（有效計算）
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<p>OS 參數、連線池、TCP 調優、機房拓樸都影響上限。</p>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: User → Gateway → RateLimit → MQ → OrderSvc → Stock(Redis/DB)
st-&gt;n1
</code></pre>
<h2 id="示意圖-14"><a class="header" href="#示意圖-14">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Client → Gateway → RateLimiter → MQ → OrderWorker → RedisStock → DB\n高峰流量先削峰，再異步消化
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例-19"><a class="header" href="#跨語言完整範例-19">跨語言完整範例</a></h2>
<h3 id="c--秒殺核心原子庫存扣減--防重--令牌桶限流"><a class="header" href="#c--秒殺核心原子庫存扣減--防重--令牌桶限流">C — 秒殺核心：原子庫存扣減 + 防重 + 令牌桶限流</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define MAX_USERS   100
#define INIT_STOCK  5

/* ── 令牌桶限流 ── */
typedef struct {
    atomic_int tokens;
    int capacity;
    pthread_mutex_t mu;
} TokenBucket;

void bucket_init(TokenBucket *b, int cap) {
    atomic_init(&amp;b-&gt;tokens, cap);
    b-&gt;capacity = cap;
    pthread_mutex_init(&amp;b-&gt;mu, NULL);
}

int bucket_take(TokenBucket *b) {
    int t = atomic_fetch_sub(&amp;b-&gt;tokens, 1);
    return t &gt; 0;
}

/* ── 防重（冪等）表 ── */
static int order_submitted[MAX_USERS];
static pthread_mutex_t idem_mu = PTHREAD_MUTEX_INITIALIZER;

int check_and_mark(int uid) {
    pthread_mutex_lock(&amp;idem_mu);
    int dup = order_submitted[uid];
    if (!dup) order_submitted[uid] = 1;
    pthread_mutex_unlock(&amp;idem_mu);
    return !dup;  /* 1: 首次, 0: 重複 */
}

/* ── 庫存原子扣減 ── */
static atomic_int stock = ATOMIC_VAR_INIT(INIT_STOCK);

int deduct_stock(void) {
    int cur = atomic_fetch_sub(&amp;stock, 1);
    if (cur &gt; 0) return 1;
    atomic_fetch_add(&amp;stock, 1);  /* 回滾 */
    return 0;
}

/* ── 秒殺主流程 ── */
typedef struct { int uid; TokenBucket *bucket; int *results; } Task;

void *seckill(void *arg) {
    Task *t = (Task *)arg;
    int uid = t-&gt;uid;
    /* 限流 */
    if (!bucket_take(t-&gt;bucket)) { t-&gt;results[uid] = -1; return NULL; }
    /* 防重 */
    if (!check_and_mark(uid)) { t-&gt;results[uid] = -2; return NULL; }
    /* 扣庫存 */
    t-&gt;results[uid] = deduct_stock() ? 1 : 0;
    return NULL;
}

int main(void) {
    TokenBucket bucket;
    bucket_init(&amp;bucket, 20);  /* 限流：每批最多 20 個請求 */

    int results[MAX_USERS] = {0};
    pthread_t tids[MAX_USERS];
    Task tasks[MAX_USERS];

    for (int i = 0; i &lt; MAX_USERS; i++) {
        tasks[i] = (Task){i, &amp;bucket, results};
        pthread_create(&amp;tids[i], NULL, seckill, &amp;tasks[i]);
    }
    for (int i = 0; i &lt; MAX_USERS; i++) pthread_join(tids[i], NULL);

    int success = 0;
    for (int i = 0; i &lt; MAX_USERS; i++) if (results[i] == 1) success++;
    printf("成功購買人數: %d (初始庫存 %d)\n", success, INIT_STOCK);
    printf("剩餘庫存: %d (應為 0)\n", atomic_load(&amp;stock));
    return 0;
}
</code></pre>
<h3 id="c--秒殺核心原子庫存--防重--令牌桶"><a class="header" href="#c--秒殺核心原子庫存--防重--令牌桶">C++ — 秒殺核心：原子庫存 + 防重 + 令牌桶</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

class TokenBucket {
    std::atomic&lt;int&gt; tokens_;
public:
    TokenBucket(int cap) : tokens_(cap) {}
    bool take() {
        int t = tokens_.fetch_sub(1, std::memory_order_acq_rel);
        return t &gt; 0;
    }
};

class IdempotentGuard {
    std::unordered_set&lt;int&gt; seen_;
    std::mutex mu_;
public:
    bool mark_first(int uid) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        return seen_.insert(uid).second;
    }
};

class StockManager {
    std::atomic&lt;int&gt; stock_;
public:
    StockManager(int init) : stock_(init) {}
    bool deduct() {
        int cur = stock_.fetch_sub(1, std::memory_order_acq_rel);
        if (cur &gt; 0) return true;
        stock_.fetch_add(1, std::memory_order_acq_rel);  /* 回滾 */
        return false;
    }
    int remaining() const { return stock_.load(); }
};

int main() {
    const int USER_COUNT = 100;
    const int INIT_STOCK = 5;

    TokenBucket bucket(20);
    IdempotentGuard idem;
    StockManager stock(INIT_STOCK);
    std::atomic&lt;int&gt; success_count{0};

    auto seckill = [&amp;](int uid) {
        if (!bucket.take()) return;          /* 限流 */
        if (!idem.mark_first(uid)) return;   /* 防重 */
        if (stock.deduct()) {
            success_count.fetch_add(1, std::memory_order_relaxed);
        }
    };

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; USER_COUNT; i++)
        threads.emplace_back(seckill, i);
    for (auto &amp;t : threads) t.join();

    std::cout &lt;&lt; "成功購買人數: " &lt;&lt; success_count.load()
              &lt;&lt; " (初始庫存 " &lt;&lt; INIT_STOCK &lt;&lt; ")\n";
    std::cout &lt;&lt; "剩餘庫存: " &lt;&lt; stock.remaining() &lt;&lt; " (應為 0)\n";
}
</code></pre>
<h3 id="rust--秒殺核心atomici32-原子庫存--hashset-防重"><a class="header" href="#rust--秒殺核心atomici32-原子庫存--hashset-防重">Rust — 秒殺核心：AtomicI32 原子庫存 + HashSet 防重</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;
use std::sync::{Arc, Mutex, atomic::{AtomicI32, Ordering}};
use std::thread;

struct Seckill {
    stock: AtomicI32,
    seen: Mutex&lt;HashSet&lt;u32&gt;&gt;,
    tokens: AtomicI32,
}

impl Seckill {
    fn new(init_stock: i32, rate_limit: i32) -&gt; Self {
        Seckill {
            stock: AtomicI32::new(init_stock),
            seen: Mutex::new(HashSet::new()),
            tokens: AtomicI32::new(rate_limit),
        }
    }
    fn try_buy(&amp;self, uid: u32) -&gt; &amp;'static str {
        if self.tokens.fetch_sub(1, Ordering::AcqRel) &lt;= 0 {
            self.tokens.fetch_add(1, Ordering::AcqRel);
            return "限流拒絕";
        }
        {
            let mut seen = self.seen.lock().unwrap();
            if !seen.insert(uid) { return "重複下單"; }
        }
        let cur = self.stock.fetch_sub(1, Ordering::AcqRel);
        if cur &gt; 0 { "購買成功" } else {
            self.stock.fetch_add(1, Ordering::AcqRel);
            "售罄"
        }
    }
}

fn main() {
    let sk = Arc::new(Seckill::new(5, 20));
    let mut handles = vec![];
    for uid in 0..100u32 {
        let sk = Arc::clone(&amp;sk);
        handles.push(thread::spawn(move || {
            let result = sk.try_buy(uid);
            if result == "購買成功" {
                println!("uid={} 購買成功", uid);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("剩餘庫存: {} (應為 0)", sk.stock.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--秒殺核心syncatomic-庫存--syncmap-防重"><a class="header" href="#go--秒殺核心syncatomic-庫存--syncmap-防重">Go — 秒殺核心：sync/atomic 庫存 + sync.Map 防重</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var (
    stock      int64 = 5
    tokens     int64 = 20
    orderSeen  sync.Map
    successCnt int64
)

func rateLimitPass() bool {
    t := atomic.AddInt64(&amp;tokens, -1)
    return t &gt;= 0
}

func markFirst(uid int) bool {
    _, loaded := orderSeen.LoadOrStore(uid, struct{}{})
    return !loaded
}

func deductStock() bool {
    cur := atomic.AddInt64(&amp;stock, -1)
    if cur &gt;= 0 {
        return true
    }
    atomic.AddInt64(&amp;stock, 1) // 回滾
    return false
}

func seckill(uid int, wg *sync.WaitGroup) {
    defer wg.Done()
    if !rateLimitPass() {
        return
    }
    if !markFirst(uid) {
        return
    }
    if deductStock() {
        atomic.AddInt64(&amp;successCnt, 1)
    }
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go seckill(i, &amp;wg)
    }
    wg.Wait()
    fmt.Printf("成功購買人數: %d (初始庫存 5)\n", atomic.LoadInt64(&amp;successCnt))
    fmt.Printf("剩餘庫存: %d (應為 0)\n", atomic.LoadInt64(&amp;stock))
}
</code></pre>
<h3 id="python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流"><a class="header" href="#python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流">Python — 秒殺核心：MockRedis Lua 原子扣減 + SETNX 防重 + 限流</a></h3>
<pre><code class="language-python">"""Chapter 20: seckill core — atomic stock deduct + idempotent + rate limit."""
import threading
import time


class MockRedis:
    """模擬 Redis 的原子操作：DECR（Lua）與 SETNX。"""

    def __init__(self):
        self._data = {}
        self._mu = threading.Lock()

    def set(self, key: str, value):
        with self._mu:
            self._data[key] = value

    def setnx(self, key: str, value) -&gt; bool:
        """SET key value NX → True: 首次設置成功"""
        with self._mu:
            if key in self._data:
                return False
            self._data[key] = value
            return True

    def lua_deduct_stock(self, key: str) -&gt; bool:
        """原子：DECR key → if &lt; 0: INCR (回滾) return False"""
        with self._mu:
            cur = self._data.get(key, 0)
            if cur &lt;= 0:
                return False
            self._data[key] = cur - 1
            return True

    def get(self, key: str):
        with self._mu:
            return self._data.get(key)


class TokenBucket:
    def __init__(self, capacity: int, refill_per_sec: int):
        self._tokens = capacity
        self._capacity = capacity
        self._refill_rate = refill_per_sec
        self._last_refill = time.monotonic()
        self._mu = threading.Lock()

    def take(self) -&gt; bool:
        with self._mu:
            now = time.monotonic()
            elapsed = now - self._last_refill
            self._tokens = min(
                self._capacity,
                self._tokens + int(elapsed * self._refill_rate)
            )
            self._last_refill = now
            if self._tokens &gt; 0:
                self._tokens -= 1
                return True
            return False


def run_seckill(user_count: int = 100, init_stock: int = 5):
    redis = MockRedis()
    bucket = TokenBucket(capacity=20, refill_per_sec=10)

    redis.set("stock:sku:001", init_stock)

    results = {"success": 0, "sold_out": 0, "limited": 0, "dup": 0}
    results_lock = threading.Lock()

    def buyer(uid: int):
        # 步驟 1：限流
        if not bucket.take():
            with results_lock:
                results["limited"] += 1
            return

        # 步驟 2：防重下單（SETNX）
        order_key = f"order:{uid}:sku:001"
        if not redis.setnx(order_key, "1"):
            with results_lock:
                results["dup"] += 1
            return

        # 步驟 3：Lua 原子扣庫存
        if redis.lua_deduct_stock("stock:sku:001"):
            with results_lock:
                results["success"] += 1
        else:
            with results_lock:
                results["sold_out"] += 1

    threads = [threading.Thread(target=buyer, args=(uid,)) for uid in range(user_count)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    remaining = redis.get("stock:sku:001")
    print(f"初始庫存: {init_stock}")
    print(f"成功購買: {results['success']} (應 &lt;= {init_stock})")
    print(f"售罄拒絕: {results['sold_out']}")
    print(f"限流拒絕: {results['limited']}")
    print(f"重複下單: {results['dup']}")
    print(f"剩餘庫存: {remaining} (應為 0 或正數，不能為負)")
    assert results["success"] &lt;= init_stock, "超賣！"
    assert remaining &gt;= 0, "庫存為負數！"
    print("通過：原子扣減防止超賣，SETNX 防止重複下單")


if __name__ == "__main__":
    run_seckill(user_count=100, init_stock=5)
</code></pre>
<h2 id="完整專案級範例python-19"><a class="header" href="#完整專案級範例python-19">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch20.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch20.py
</code></pre>
<pre><code class="language-python">"""Chapter 20: seckill pipeline demo."""
import queue
import threading

stock = 5
q: queue.Queue[str] = queue.Queue()
mu = threading.Lock()


def worker():
    global stock
    while True:
        user = q.get()
        if user == "STOP":
            return
        with mu:
            if stock &gt; 0:
                stock -= 1
                print(user, "success, left", stock)
            else:
                print(user, "sold out")


if __name__ == "__main__":
    t = threading.Thread(target=worker)
    t.start()
    for i in range(10):
        q.put(f"u{i}")
    q.put("STOP")
    t.join()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附錄ccrustgopython-對照速查"><a class="header" href="#附錄ccrustgopython-對照速查">附錄：C/C++/Rust/Go/Python 對照速查</a></h1>
<div class="table-wrapper"><table><thead><tr><th>主題</th><th>C/C++</th><th>Rust</th><th>Go</th><th>Python</th></tr></thead><tbody>
<tr><td>執行單元</td><td>pthread / std::thread</td><td>std::thread / tokio::spawn</td><td>goroutine</td><td>threading.Thread</td></tr>
<tr><td>互斥鎖</td><td>pthread_mutex / std::mutex</td><td>Mutex&lt;T&gt;</td><td>sync.Mutex</td><td>threading.Lock()</td></tr>
<tr><td>讀寫鎖</td><td>pthread_rwlock / std::shared_mutex</td><td>RwLock&lt;T&gt;</td><td>sync.RWMutex</td><td>threading.RLock()</td></tr>
<tr><td>條件變數</td><td>pthread_cond / condition_variable</td><td>Condvar</td><td>sync.Cond</td><td>threading.Condition</td></tr>
<tr><td>原子操作</td><td>stdatomic.h / std::atomic</td><td>Atomic* (SeqCst/Acquire/Release)</td><td>sync/atomic</td><td>threading.Lock()(模擬)</td></tr>
<tr><td>信號量</td><td>sem_t / counting_semaphore</td><td>Mutex+Condvar / tokio::Semaphore</td><td>channel(buffered)</td><td>threading.Semaphore</td></tr>
<tr><td>執行緒本地</td><td>__thread / thread_local</td><td>thread_local!</td><td>context.Context(顯式傳遞)</td><td>threading.local()</td></tr>
<tr><td>執行緒池</td><td>自建 / OpenMP</td><td>rayon::ThreadPool / tokio</td><td>worker+channel 慣例</td><td>ThreadPoolExecutor</td></tr>
<tr><td>中斷/取消</td><td>stop flag / std::stop_token</td><td>無內建，用 channel</td><td>context.WithCancel</td><td>threading.Event</td></tr>
<tr><td>記憶體順序</td><td>memory_order_*</td><td>Ordering::*</td><td>sync/atomic (無細粒度)</td><td>GIL 保證(CPython)</td></tr>
<tr><td>無鎖計數器</td><td>atomic_fetch_add</td><td>fetch_add(Ordering)</td><td>atomic.AddInt64</td><td>需 Lock(GIL 不保證)</td></tr>
<tr><td>分散式鎖</td><td>不內建</td><td>不內建</td><td>不內建</td><td>不內建(需 Redis 等)</td></tr>
</tbody></table>
</div>
<h2 id="一個跨語言都成立的原則"><a class="header" href="#一個跨語言都成立的原則">一個跨語言都成立的原則</a></h2>
<p>先保證正確性，再談吞吐。</p>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 正確性(資料不錯) → 可用性(不死鎖) → 效能(夠快)
st-&gt;n1
</code></pre>
<h2 id="共同最小模板"><a class="header" href="#共同最小模板">共同最小模板</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 1) 先用 atomic 解決單變數競態\n2) 需要複合一致性時改用 lock\n3) 併發量大再加 queue/pool/backpressure
st-&gt;n1
</code></pre>
<pre><code class="language-c">// C: atomic -&gt; mutex 升級路徑
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
atomic_int counter = 0;          // 單變數競態 → atomic
pthread_mutex_t mu;              // 複合操作 → mutex
</code></pre>
<pre><code class="language-cpp">// C++: atomic -&gt; mutex 升級路徑
#include &lt;atomic&gt;
#include &lt;mutex&gt;
std::atomic&lt;int&gt; counter{0};    // 單變數
std::mutex mu;                  // 複合操作
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust: Atomic* -&gt; Mutex/RwLock
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::{Mutex, RwLock};
static COUNTER: AtomicI32 = AtomicI32::new(0);  // 單變數
let shared = Mutex::new(HashMap::new());         // 複合操作
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-go">// Go: sync/atomic -&gt; sync.Mutex/RWMutex
import "sync/atomic"
import "sync"
var counter atomic.Int64          // 單變數
var mu sync.Mutex                 // 複合操作
</code></pre>
<pre><code class="language-python"># Python: Lock 保護複合操作（CPython GIL 不保證原子性）
import threading
lock = threading.Lock()
counter = 0                       # 不安全（GIL 不保證 counter += 1）
with lock:                        # 安全的複合操作
    counter += 1
</code></pre>
<h2 id="python-特別說明"><a class="header" href="#python-特別說明">Python 特別說明</a></h2>
<div class="table-wrapper"><table><thead><tr><th>項目</th><th>CPython 行為</th><th>注意事項</th></tr></thead><tbody>
<tr><td>GIL（全域直譯器鎖）</td><td>同一時刻只有一個執行緒跑 Python bytecode</td><td>I/O 密集可受益，CPU 密集用 multiprocessing</td></tr>
<tr><td><code>counter += 1</code></td><td><strong>不是原子</strong>（3 條 bytecode：LOAD/BINARY_ADD/STORE）</td><td>需加 Lock</td></tr>
<tr><td><code>threading.Lock</code></td><td>OS mutex 封裝</td><td>可跨執行緒互斥</td></tr>
<tr><td><code>threading.RLock</code></td><td>可重入鎖</td><td>同執行緒可多次 acquire</td></tr>
<tr><td>真正並行</td><td><code>multiprocessing</code> / <code>concurrent.futures.ProcessPoolExecutor</code></td><td>各自有獨立 GIL</td></tr>
<tr><td>異步並發</td><td><code>asyncio</code>（單執行緒事件迴圈）</td><td>適合 I/O 密集，非多核並行</td></tr>
</tbody></table>
</div>
<h2 id="選型快速決策"><a class="header" href="#選型快速決策">選型快速決策</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 需要多核 CPU 並行運算？\n  ├─ 是 → C/C++/Rust/Go（Python 用 multiprocessing）\n  └─ 否（I/O 密集）→ 各語言都行，Python asyncio 亦可\n　\n需要極低延遲無 GC？\n  └─ C/C++/Rust
n2=&gt;operation: 　\n需要記憶體安全無 data race 編譯期保證？\n  └─ Rust\n　\n需要最簡單的並發模型？\n  └─ Go（goroutine + channel）
n3=&gt;operation: 　\n需要快速腳本/原型？\n  └─ Python（注意 GIL 限制）
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/flowchart-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
