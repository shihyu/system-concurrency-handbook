<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第15章 手寫線程池實戰 - 高並發編程通用概念（跨 Java/C++/Rust/Go）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ascii-diagram.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">高並發編程通用概念（跨 Java/C++/Rust/Go）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第15章-手寫線程池實戰"><a class="header" href="#第15章-手寫線程池實戰">第15章 手寫線程池實戰</a></h1>
<h2 id="151-結構設計"><a class="header" href="#151-結構設計">15.1 結構設計</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖"><a class="header" href="#本小節示意圖">本小節示意圖</a></h3>
<pre><code class="language-text">  ThreadPool 核心組件圖

  ┌─────────────────────────────────────────────────────────────────┐
  │                        ThreadPool                               │
  │                                                                 │
  │  ┌─────────────────────────────────────────────────────────┐   │
  │  │  state: AtomicInteger                                   │   │
  │  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────┐ │   │
  │  │  │ RUNNING  │→ │SHUTDOWN  │→ │  STOP    │→ │TERMINATED│ │   │
  │  │  └──────────┘  └──────────┘  └──────────┘  └────────┘ │   │
  │  └─────────────────────────────────────────────────────────┘   │
  │                              │ 控制                             │
  │  ┌──────────────────┐        │        ┌──────────────────┐     │
  │  │  task_queue      │        │        │  workers         │     │
  │  │  BlockingQueue   │◄───────┴───────►│  Set&lt;Thread&gt;     │     │
  │  │                  │    協作          │                  │     │
  │  │  [Task][Task]    │  ─poll()─►      │  [W1][W2][W3][W4]│     │
  │  │  [Task][Task]    │                 │   ↑執行任務↑      │     │
  │  └──────────────────┘                 └──────────────────┘     │
  │          ▲ submit()                                             │
  │          │                   飽和時觸發                          │
  │  ┌───────┴──────┐        ┌──────────────────────────────┐      │
  │  │   外部呼叫方  │        │  reject_policy               │      │
  │  │  (Producer)  │        │  RejectedExecutionHandler    │      │
  │  └──────────────┘        │  Abort / CallerRuns / Discard│      │
  │                           └──────────────────────────────┘      │
  │                                                                 │
  │  組件職責：                                                      │
  │  • task_queue：緩衝待執行任務，解耦生產者與消費者               │
  │  • workers：實際執行任務的執行緒集合，數量在 [core, max] 間調整 │
  │  • state：協調關閉流程，防止競態                                 │
  │  • reject_policy：佇列+執行緒都滿時的降級策略                   │
  └─────────────────────────────────────────────────────────────────┘
</code></pre>
<p>需要的核心欄位：</p>
<ul>
<li><strong>任務佇列（task_queue）</strong>：BlockingQueue，生產者 submit 入佇，worker 出佇執行</li>
<li><strong>worker 集合（workers）</strong>：追蹤所有活躍執行緒，用於關閉時中斷</li>
<li><strong>運行狀態（state）</strong>：AtomicInteger，防止在關閉中繼續接受任務</li>
<li><strong>拒絕策略（reject_policy）</strong>：飽和時的處理方式，預設拋出例外</li>
</ul>
<h2 id="152-worker-邏輯"><a class="header" href="#152-worker-邏輯">15.2 Worker 邏輯</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-1"><a class="header" href="#本小節示意圖-1">本小節示意圖</a></h3>
<pre><code class="language-text">  Worker 主循環流程圖

  Worker 執行緒啟動
        │
        ▼
  ┌─────────────────────┐
  │  loop（主循環）      │ ◄────────────────────────────┐
  └──────────┬──────────┘                               │
             │                                          │
             ▼                                          │
  ┌─────────────────────────────────────┐               │
  │  task = queue.poll(keepAliveTime)   │               │
  │  （等待最多 keepAliveTime 超時）     │               │
  └──────────────┬──────────────────────┘               │
                 │                                       │
        task != null?                                    │
        ┌────────┴────────┐                             │
        │是               │否（等待超時）                │
        ▼                 ▼                             │
  ┌───────────┐   是否為核心執行緒？                     │
  │ execute() │   ┌────────┴────────┐                   │
  │  task     │   │是               │否（非核心）         │
  └─────┬─────┘   ▼                 ▼                   │
        │   繼續等待，        workers.size &gt; core?        │
        │   不退出            ┌────────┴────────┐        │
        │                    │是               │否       │
        │                    ▼                 ▼         │
        │             ┌─────────────┐    繼續等待        │
        │             │ 退出 loop   │    不退出 ─────────►│
        │             │ workers.    │
        │             │ remove(this)│
        └─────────────►            │ ←──────────── shutdown?
                      └─────────────┘                   ▲
                                                        │
                               pool.state == SHUTDOWN  ─┘
                               且 queue 已空 → 退出
</code></pre>
<p>worker 持續從佇列取任務執行，遇到關閉訊號退出。</p>
<p>Worker 的關鍵設計點：</p>
<ol>
<li><strong>keepAlive 超時</strong>：非核心執行緒等待超過 keepAliveTime 後縮容退出，避免資源浪費</li>
<li><strong>中斷響應</strong>：<code>shutdownNow()</code> 時送出中斷，worker 的 <code>poll()</code> 會拋出 <code>InterruptedException</code> 並退出</li>
<li><strong>退出清理</strong>：worker 退出前從 <code>workers</code> 集合中移除自己，並在必要時判斷是否需要觸發 <code>TERMINATED</code> 狀態</li>
</ol>
<h2 id="153-提交與關閉對應-15311536"><a class="header" href="#153-提交與關閉對應-15311536">15.3 提交與關閉（對應 15.3.1~15.3.6）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-2"><a class="header" href="#本小節示意圖-2">本小節示意圖</a></h3>
<pre><code class="language-text">  submit(task) 流程圖

  submit(task)
       │
       ▼
  ┌──────────────────────────┐
  │ state == RUNNING ?        │
  └──────────┬───────────────┘
       是 │           │ 否（SHUTDOWN/STOP）
          ▼           ▼
  ┌──────────────┐  ┌─────────────────────┐
  │ queue.offer  │  │ reject(task)        │
  │ (task) 成功? │  │ RejectedExecution   │
  └──────┬───────┘  └─────────────────────┘
    是 │     │ 否（佇列滿）
       ▼     ▼
  ┌──────┐  ┌────────────────────────────┐
  │ 返回 │  │ workers.size &lt; maxPoolSize? │
  └──────┘  └────────────┬───────────────┘
                  是 │           │ 否
                     ▼           ▼
             ┌──────────────┐  ┌─────────────────────┐
             │ 新建 Worker  │  │ reject(task)        │
             │ 執行此任務   │  │（飽和拒絕）          │
             └──────────────┘  └─────────────────────┘

  ─────────────────────────────────────────────────────────────────

  shutdown() 流程圖

  shutdown()
       │
       ├─► 1. 原子設定 state = SHUTDOWN
       │
       ├─► 2. 中斷所有閒置 workers（喚醒正在 poll() 等待的執行緒）
       │
       ├─► 3. 不再接受新的 submit()
       │
       └─► 4. 等待佇列排空 + workers 歸零 → 轉入 TERMINATED
            （可用 awaitTermination() 阻塞等待）
</code></pre>
<ul>
<li><strong>submit</strong>：放入佇列或觸發拒絕</li>
<li><strong>shutdown</strong>：停止收新任務，排空後結束</li>
</ul>
<p>關閉的正確姿勢是先呼叫 <code>shutdown()</code>，再以迴圈呼叫 <code>awaitTermination()</code> 直到返回 <code>true</code> 或超時強制中斷（<code>shutdownNow()</code>）。</p>
<h2 id="154-測試"><a class="header" href="#154-測試">15.4 測試</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-3"><a class="header" href="#本小節示意圖-3">本小節示意圖</a></h3>
<pre><code class="language-text">  測試場景清單與期望行為

  ┌─────────────────────────────────────────────────────────────────┐
  │  場景 1：正常提交                                                │
  │  操作：提交 N 個任務（N ≤ queue capacity）                      │
  │  期望：所有任務按完成，無例外，result 集合 size == N             │
  ├─────────────────────────────────────────────────────────────────┤
  │  場景 2：飽和拒絕                                                │
  │  操作：workers 全忙 + 佇列滿時繼續提交                          │
  │  期望：觸發 RejectedExecutionException（或自定義策略動作）       │
  │  驗證：已進入佇列的任務仍能正常完成                              │
  ├─────────────────────────────────────────────────────────────────┤
  │  場景 3：優雅關閉（shutdown）                                    │
  │  操作：提交 N 個任務後立即 shutdown()                           │
  │  期望：所有已提交任務執行完畢，awaitTermination 返回 true       │
  │  禁止：shutdown 後再 submit 拋出 RejectedExecutionException     │
  ├─────────────────────────────────────────────────────────────────┤
  │  場景 4：強制中斷（shutdownNow）                                 │
  │  操作：任務執行中呼叫 shutdownNow()                             │
  │  期望：返回未執行任務列表，正在執行的任務收到中斷訊號           │
  │  驗證：list.size == 未執行任務數量                               │
  ├─────────────────────────────────────────────────────────────────┤
  │  場景 5：keepAlive 縮容                                          │
  │  操作：高峰期超過 coreSize，低峰期閒置超過 keepAliveTime        │
  │  期望：非核心執行緒自動退出，workers.size 降回 coreSize         │
  │  驗證：等待 keepAliveTime + buffer 後檢查 activeCount           │
  └─────────────────────────────────────────────────────────────────┘

  壓測指標：
  ┌─────────────┬──────────────────────────────────────────────────┐
  │  吞吐量     │ tasks/second，對比序列執行的加速比               │
  │  延遲 P99   │ 第 99 百分位任務完成時間，反映長尾效能           │
  │  拒絕比例   │ rejected / total，評估參數設定是否合理           │
  │  佇列水位   │ queue.size() 峰值，評估是否需要擴容              │
  └─────────────┴──────────────────────────────────────────────────┘
</code></pre>
<p>壓測觀察吞吐、延遲、拒絕比例。</p>
<p>測試線程池時需涵蓋正常路徑和各種邊界情況。特別注意關閉時的競態：<code>shutdown()</code> 和最後一個任務完成之間存在時間視窗，測試需等待 <code>awaitTermination()</code> 返回 <code>true</code> 才能斷言結果。</p>
<pre><code class="language-text">while (running) {
  task = queue.pop()
  run(task)
}
</code></pre>
<h2 id="跨語言完整範例"><a class="header" href="#跨語言完整範例">跨語言完整範例</a></h2>
<p>最簡執行緒池：channel 做佇列，N 個 goroutine/thread 做 worker，展示核心機制。</p>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<pre><code class="language-c">/* 編譯: gcc -O2 -pthread -o ch15_c ch15.c &amp;&amp; ./ch15_c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdatomic.h&gt;

#define WORKERS   4
#define TASKS     20
#define QCAP      64

typedef struct { int id; } Task;

/* 環形緩衝佇列 */
typedef struct {
    Task        buf[QCAP];
    int         head, tail, size;
    pthread_mutex_t mu;
    pthread_cond_t  not_empty;
    atomic_int  shutdown;
    atomic_int  completed;
} Pool;

static Pool pool;

static void pool_init(void) {
    pool.head = pool.tail = pool.size = 0;
    atomic_store(&amp;pool.shutdown, 0);
    atomic_store(&amp;pool.completed, 0);
    pthread_mutex_init(&amp;pool.mu, NULL);
    pthread_cond_init(&amp;pool.not_empty, NULL);
}

static void pool_submit(int task_id) {
    pthread_mutex_lock(&amp;pool.mu);
    pool.buf[pool.tail] = (Task){task_id};
    pool.tail = (pool.tail + 1) % QCAP;
    pool.size++;
    pthread_cond_signal(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);
}

static void *worker_loop(void *arg) {
    int wid = *(int *)arg;
    for (;;) {
        pthread_mutex_lock(&amp;pool.mu);
        while (pool.size == 0 &amp;&amp; !atomic_load(&amp;pool.shutdown))
            pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
        if (pool.size == 0) {           /* shutdown + 空佇列 */
            pthread_mutex_unlock(&amp;pool.mu);
            break;
        }
        Task t = pool.buf[pool.head];
        pool.head = (pool.head + 1) % QCAP;
        pool.size--;
        pthread_mutex_unlock(&amp;pool.mu);

        usleep(20000);                  /* 模擬 20ms 工作 */
        int done = atomic_fetch_add(&amp;pool.completed, 1) + 1;
        printf("Worker%d finished task %2d (total done: %d)\n",
               wid, t.id, done);
    }
    return NULL;
}

int main(void) {
    pool_init();
    pthread_t threads[WORKERS];
    int ids[WORKERS];
    for (int i = 0; i &lt; WORKERS; i++) {
        ids[i] = i;
        pthread_create(&amp;threads[i], NULL, worker_loop, &amp;ids[i]);
    }
    for (int i = 0; i &lt; TASKS; i++) {
        pool_submit(i);
    }
    /* 等佇列排空後再 shutdown */
    pthread_mutex_lock(&amp;pool.mu);
    while (pool.size &gt; 0)
        pthread_cond_wait(&amp;pool.not_empty, &amp;pool.mu);
    atomic_store(&amp;pool.shutdown, 1);
    pthread_cond_broadcast(&amp;pool.not_empty);
    pthread_mutex_unlock(&amp;pool.mu);

    for (int i = 0; i &lt; WORKERS; i++) pthread_join(threads[i], NULL);
    printf("All %d tasks done.\n", atomic_load(&amp;pool.completed));
    return 0;
}
</code></pre>
<h3 id="c-1"><a class="header" href="#c-1">C++</a></h3>
<pre><code class="language-cpp">// 編譯: g++ -std=c++17 -O2 -pthread -o ch15_cpp ch15.cpp &amp;&amp; ./ch15_cpp
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;atomic&gt;

class SimpleThreadPool {
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::vector&lt;std::thread&gt; workers;
    std::mutex mu;
    std::condition_variable cv;
    bool stopped = false;
    std::atomic&lt;int&gt; completed{0};

public:
    explicit SimpleThreadPool(int n) {
        for (int i = 0; i &lt; n; i++) {
            workers.emplace_back([this, i] {
                for (;;) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock lk(mu);
                        cv.wait(lk, [this]{ return stopped || !tasks.empty(); });
                        if (stopped &amp;&amp; tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                    completed++;
                }
            });
        }
    }

    void submit(std::function&lt;void()&gt; f) {
        { std::lock_guard lk(mu); tasks.push(std::move(f)); }
        cv.notify_one();
    }

    int done_count() const { return completed.load(); }

    void shutdown() {
        { std::lock_guard lk(mu); stopped = true; }
        cv.notify_all();
        for (auto &amp;t : workers) t.join();
    }
};

int main() {
    SimpleThreadPool pool(4);
    std::mutex print_mu;

    for (int i = 0; i &lt; 20; i++) {
        pool.submit([i, &amp;print_mu, &amp;pool] {
            std::this_thread::sleep_for(std::chrono::milliseconds(20));
            std::lock_guard lk(print_mu);
            std::cout &lt;&lt; "Task " &lt;&lt; std::setw(2) &lt;&lt; i
                      &lt;&lt; " done, total=" &lt;&lt; pool.done_count() + 1 &lt;&lt; "\n";
        });
    }
    pool.shutdown();
    std::cout &lt;&lt; "All tasks completed, total=" &lt;&lt; pool.done_count() &lt;&lt; "\n";
    return 0;
}
</code></pre>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<pre><pre class="playground"><code class="language-rust">// 執行: cargo run 或 rustc ch15.rs -o ch15 &amp;&amp; ./ch15
use std::sync::{Arc, Mutex, Condvar};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;
use std::collections::VecDeque;

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

struct SimplePool {
    queue:     Mutex&lt;VecDeque&lt;Option&lt;Job&gt;&gt;&gt;,
    cv:        Condvar,
    completed: AtomicUsize,
}

impl SimplePool {
    fn new() -&gt; Arc&lt;Self&gt; {
        Arc::new(SimplePool {
            queue:     Mutex::new(VecDeque::new()),
            cv:        Condvar::new(),
            completed: AtomicUsize::new(0),
        })
    }

    fn submit(self: &amp;Arc&lt;Self&gt;, f: impl FnOnce() + Send + 'static) {
        self.queue.lock().unwrap().push_back(Some(Box::new(f)));
        self.cv.notify_one();
    }

    fn spawn_workers(self: &amp;Arc&lt;Self&gt;, n: usize) -&gt; Vec&lt;thread::JoinHandle&lt;()&gt;&gt; {
        (0..n).map(|_| {
            let pool = Arc::clone(self);
            thread::spawn(move || loop {
                let job = {
                    let mut q = pool.cv
                        .wait_while(pool.queue.lock().unwrap(), |q| q.is_empty())
                        .unwrap();
                    q.pop_front().unwrap()
                };
                match job {
                    Some(f) =&gt; { f(); pool.completed.fetch_add(1, Ordering::Relaxed); }
                    None    =&gt; break,
                }
            })
        }).collect()
    }

    fn shutdown(self: &amp;Arc&lt;Self&gt;, handles: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;, n: usize) {
        for _ in 0..n {
            self.queue.lock().unwrap().push_back(None);
            self.cv.notify_one();
        }
        for h in handles { h.join().unwrap(); }
    }
}

fn main() {
    const WORKERS: usize = 4;
    const TASKS:   usize = 20;

    let pool = SimplePool::new();
    let handles = pool.spawn_workers(WORKERS);

    for i in 0..TASKS {
        let p = Arc::clone(&amp;pool);
        pool.submit(move || {
            thread::sleep(std::time::Duration::from_millis(20));
            let done = p.completed.load(Ordering::Relaxed) + 1;
            println!("Task {:2} done, completed so far: {}", i, done);
        });
    }
    pool.shutdown(handles, WORKERS);
    println!("Total completed: {}", pool.completed.load(Ordering::Relaxed));
}</code></pre></pre>
<h3 id="go"><a class="header" href="#go">Go</a></h3>
<pre><code class="language-go">// 執行: go run ch15.go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
	"time"
)

// SimplePool：channel 作為任務佇列，goroutine 作為 worker
type SimplePool struct {
	jobs      chan func()
	wg        sync.WaitGroup
	completed int64
}

func NewPool(workers, queueSize int) *SimplePool {
	p := &amp;SimplePool{jobs: make(chan func(), queueSize)}
	for i := 0; i &lt; workers; i++ {
		workerID := i
		go func() {
			for job := range p.jobs {
				job()
				atomic.AddInt64(&amp;p.completed, 1)
				fmt.Printf("  Worker%d: task done (total=%d)\n",
					workerID, atomic.LoadInt64(&amp;p.completed))
			}
		}()
	}
	return p
}

func (p *SimplePool) Submit(f func()) {
	p.wg.Add(1)
	p.jobs &lt;- func() {
		defer p.wg.Done()
		f()
	}
}

func (p *SimplePool) Shutdown() {
	p.wg.Wait()
	close(p.jobs)
}

func main() {
	const numWorkers = 4
	const numTasks   = 20

	pool := NewPool(numWorkers, 64)
	for i := 0; i &lt; numTasks; i++ {
		taskID := i
		pool.Submit(func() {
			time.Sleep(20 * time.Millisecond)
			_ = taskID
		})
	}
	pool.Shutdown()
	fmt.Printf("All done, completed=%d\n", atomic.LoadInt64(&amp;pool.completed))
}
</code></pre>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<pre><code class="language-python"># 執行: python3 ch15.py
import queue
import threading
import time
from typing import Callable


class SimpleThreadPool:
    """最簡執行緒池：queue 做佇列，Thread 做 worker。"""

    def __init__(self, num_workers: int, queue_size: int = 64):
        self._queue = queue.Queue(maxsize=queue_size)
        self._completed = 0
        self._lock = threading.Lock()
        self._workers = [
            threading.Thread(target=self._worker_loop, name=f"Worker-{i}",
                             daemon=True)
            for i in range(num_workers)
        ]
        for w in self._workers:
            w.start()

    def _worker_loop(self):
        """Worker 主循環：不斷從佇列取任務並執行。"""
        while True:
            task = self._queue.get()
            if task is None:        # None 作為關閉訊號
                self._queue.task_done()
                break
            try:
                task()
                with self._lock:
                    self._completed += 1
                    print(f"{threading.current_thread().name}: "
                          f"task done (total={self._completed})")
            finally:
                self._queue.task_done()

    def submit(self, fn: Callable):
        self._queue.put(fn)

    def shutdown(self):
        """等待所有任務完成後關閉。"""
        self._queue.join()          # 等佇列排空
        for _ in self._workers:
            self._queue.put(None)   # 每個 worker 一個停止訊號
        for w in self._workers:
            w.join()
        return self._completed


if __name__ == "__main__":
    pool = SimpleThreadPool(num_workers=4, queue_size=64)

    for i in range(20):
        def make_task(task_id):
            def task():
                time.sleep(0.02)
                _ = task_id     # 實際工作
            return task
        pool.submit(make_task(i))

    total = pool.shutdown()
    print(f"All tasks completed, total={total}")
</code></pre>
<h2 id="完整專案級範例python"><a class="header" href="#完整專案級範例python">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch15.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch15.py
</code></pre>
<pre><code class="language-python">"""Chapter 15: custom thread pool — 手動實作執行緒池的核心機制。"""
import queue
import threading

q = queue.Queue()
stop = object()              # 哨兵值，用來通知 worker 退出


def worker():
    """Worker 主循環：取任務執行，遇到 stop 哨兵則退出。"""
    while True:
        task = q.get()
        if task is stop:
            q.task_done()
            return
        try:
            task()
        finally:
            q.task_done()


if __name__ == "__main__":
    num_workers = 3
    workers = [threading.Thread(target=worker, daemon=True)
               for _ in range(num_workers)]
    for w in workers: w.start()

    # 提交 5 個任務
    for i in range(5):
        task_id = i
        q.put(lambda tid=task_id: print(f"task {tid} on {threading.current_thread().name}"))

    # 等所有任務完成，再送停止訊號
    q.join()
    for _ in workers: q.put(stop)
    for w in workers: w.join()
    print("pool shutdown complete")
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch14-threadlocal.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch16-cas-spinlock-practice.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch14-threadlocal.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch16-cas-spinlock-practice.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
