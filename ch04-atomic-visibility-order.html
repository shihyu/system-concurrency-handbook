<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第4章 本質問題：原子性、可見性、有序性 - 高並發編程通用概念（跨 Java/C++/Rust/Go）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ascii-diagram.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">高並發編程通用概念（跨 Java/C++/Rust/Go）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第4章-本質問題原子性可見性有序性"><a class="header" href="#第4章-本質問題原子性可見性有序性">第4章 本質問題：原子性、可見性、有序性</a></h1>
<h2 id="41-背景對應-411415"><a class="header" href="#41-背景對應-411415">4.1 背景（對應 4.1.1~4.1.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖"><a class="header" href="#本小節示意圖">本小節示意圖</a></h3>
<pre><code class="language-text">程式從源碼到執行的完整路徑，每個階段都可能引入問題：

  ┌──────────────────────────────────────────────────────────────────────────┐
  │  源碼（Source Code）                                                      │
  │  int x = 0;                                                              │
  │  x++;                                                                    │
  └───────────────────────────┬──────────────────────────────────────────────┘
                              │
                    ┌─────────▼──────────┐
                    │  編譯器優化          │  ← 潛在問題：指令重排、死碼刪除
                    │  (Compiler)         │     volatile/memory_order 可控制
                    └─────────┬──────────┘
                              │
                    ┌─────────▼──────────┐
                    │  機器碼              │  ← 一條 x++ 變成三條指令：
                    │  (Machine Code)     │     LOAD r1, [x]
                    └─────────┬──────────┘     ADD r1, 1
                              │                STORE [x], r1
                    ┌─────────▼──────────┐
                    │  CPU 亂序執行        │  ← 潛在問題：Out-of-Order Execution
                    │  (OoOE Pipeline)    │     CPU 可調整指令執行順序提升效率
                    └─────────┬──────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
    ┌─────────▼──────┐ ┌──────▼─────┐ ┌──────▼──────┐
    │  Store Buffer  │ │  L1 Cache  │ │  L2 Cache  │  ← 潛在問題：可見性
    │  (寫入緩衝)     │ │  (核心私有) │ │  (核心私有) │     一個核心的寫入
    └────────────────┘ └────────────┘ └────────────┘     對其他核心不立即可見
                              │
                    ┌─────────▼──────────┐
                    │  L3 Cache           │  ← 所有核心共享，但同步有延遲
                    └─────────┬──────────┘
                              │
                    ┌─────────▼──────────┐
                    │  Main Memory (RAM)  │  ← 最終一致，但時序不保證
                    └────────────────────┘

  結論：你以為的「按順序、立即可見」在並發環境中都是假設！
</code></pre>
<p>CPU、快取、編譯器優化都會讓「你以為的順序」和實際執行不同。</p>
<h2 id="42-原子性對應-421424"><a class="header" href="#42-原子性對應-421424">4.2 原子性（對應 4.2.1~4.2.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-1"><a class="header" href="#本小節示意圖-1">本小節示意圖</a></h3>
<pre><code class="language-text">x++ 非原子性拆解（Read-Modify-Write 三步）：

  高層語義（你寫的）：
  ┌─────────────────┐
  │    x++          │  ← 看起來是一個操作
  └─────────────────┘

  實際機器碼（三個獨立步驟）：
  ┌──────────┐    ┌──────────┐    ┌──────────┐
  │ LOAD(x)  │──► │ ADD(1)   │──► │ STORE(x) │
  │ r1 = x   │    │ r1 = r1+1│    │ x = r1   │
  └──────────┘    └──────────┘    └──────────┘
       ①               ②               ③
       ▲               ▲               ▲
  任何兩步之間都可能被其他執行緒打斷！

  兩個執行緒交錯導致丟失更新（Lost Update）：

  初始狀態：x = 0

  時間  Thread T1                    Thread T2
  ──── ──────────────────────────── ────────────────────────────
   t1  ① LOAD  r1_T1 = x = 0
   t2                               ① LOAD  r1_T2 = x = 0
   t3  ② ADD   r1_T1 = 0 + 1 = 1
   t4                               ② ADD   r1_T2 = 0 + 1 = 1
   t5  ③ STORE x = r1_T1 = 1
   t6                               ③ STORE x = r1_T2 = 1

  預期結果：x = 2
  實際結果：x = 1  ← T1 的遞增被 T2 覆蓋，一次更新永久丟失！

  解法：原子指令（LOCK XADD / fetch_add）確保三步不可分割
  ┌──────────────────────────────────────────────────────────┐
  │  LOCK XADD [x], 1  ← 一條不可分割的原子指令               │
  │  等價於：原子地 x = x + 1，中間態對其他 CPU 不可見          │
  └──────────────────────────────────────────────────────────┘
</code></pre>
<p><code>x++</code> 不是原子，實際是讀、改、寫三步。</p>
<h2 id="43-可見性對應-431434"><a class="header" href="#43-可見性對應-431434">4.3 可見性（對應 4.3.1~4.3.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-2"><a class="header" href="#本小節示意圖-2">本小節示意圖</a></h3>
<pre><code class="language-text">快取不一致導致可見性問題：

  ┌─────────────────────────────┐     ┌─────────────────────────────┐
  │         Core 0              │     │         Core 1              │
  │                             │     │                             │
  │  Thread T1（寫入方）         │     │  Thread T2（讀取方）         │
  │                             │     │                             │
  │  x = 42;                    │     │  while (x == 0) { }        │
  │                             │     │  // 期望讀到 42              │
  │  ┌─────────────────────┐    │     │    ┌─────────────────────┐  │
  │  │  L1 Cache           │    │     │    │  L1 Cache           │  │
  │  │  ┌───────────────┐  │    │     │    │  ┌───────────────┐  │  │
  │  │  │  x = 42  (新) │  │    │     │    │  │  x = 0   (舊) │  │  │
  │  │  └───────────────┘  │    │     │    │  └───────────────┘  │  │
  │  └─────────────────────┘    │     │    └─────────────────────┘  │
  └──────────────┬──────────────┘     └─────────────────────────────┘
                 │                                  ▲
                 │  cache coherence 協議             │  Core1 讀到的是舊值！
                 │  （MESI 狀態機）                  │  可能永遠看不到 x=42
                 │                                  │
                 └──────────────────────────────────┘
                        需要 memory barrier 刷新

  MESI 快取一致性協議狀態：

  ┌────────────┬───────────────────────────────────────────────────┐
  │  狀態      │  含義                                              │
  ├────────────┼───────────────────────────────────────────────────┤
  │  Modified  │  本核心有最新值，其他核心的副本無效                    │
  │  Exclusive │  只有本核心有此快取行，且與記憶體一致                   │
  │  Shared    │  多個核心都有此快取行，且與記憶體一致                   │
  │  Invalid   │  此快取行無效，需要重新從記憶體/其他核心讀取            │
  └────────────┴───────────────────────────────────────────────────┘

  解法：使用 volatile（Java）/ atomic store（C++/Rust/Go）
  強制寫入時刷到記憶體，讀取時從記憶體重新讀。
</code></pre>
<p>A 執行緒改值，B 不一定立刻看得到，可能讀到舊快取。</p>
<h2 id="44-有序性對應-441444"><a class="header" href="#44-有序性對應-441444">4.4 有序性（對應 4.4.1~4.4.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-3"><a class="header" href="#本小節示意圖-3">本小節示意圖</a></h3>
<pre><code class="language-text">指令重排導致有序性問題：

  程式員視角（期望的執行順序）：

  Writer 執行緒             Reader 執行緒
  ──────────────────────    ───────────────────────
  ① data = 42              ③ if (ready == true)
  ② ready = true           ④     print(data)  // 期望印出 42

  CPU/編譯器重排後（實際可能的執行順序）：

  Writer 執行緒             Reader 執行緒
  ──────────────────────    ───────────────────────
  ② ready = true    ←─ ① 和 ② 被重排！
  ①' data = 42             ③ if (ready == true)   ← 看到 ready=true
                           ④     print(data)       ← 但 data 還是舊值！

  時間軸視角：

  時間 ─────────────────────────────────────────────────────►

  Writer: [ready=true] ...... [data=42]  ← 重排後 ready 先寫
                ↓
  Reader:       [讀到 ready=true] → [讀 data] ← 此時 data 可能還是 0！

  為什麼 CPU 會重排？
  ┌────────────────────────────────────────────────────────────┐
  │  CPU 保證：單執行緒內的語義不變（as-if-serial）               │
  │  CPU 不保證：跨執行緒的全域可見順序                           │
  │                                                            │
  │  data 和 ready 在單執行緒內沒有依賴關係                       │
  │  → CPU/編譯器認為可以任意調換順序                             │
  └────────────────────────────────────────────────────────────┘

  解法：Memory Barrier（記憶體屏障）

  Writer:  data = 42
           ┌─────────────────────────────────────────┐
           │  StoreStore Barrier（禁止跨屏障的寫重排）  │
           └─────────────────────────────────────────┘
           ready = true

  Reader:  if (ready)
           ┌─────────────────────────────────────────┐
           │  LoadLoad Barrier（禁止跨屏障的讀重排）   │
           └─────────────────────────────────────────┘
           print(data)   ← 現在保證讀到正確的 data
</code></pre>
<p>指令可能重排，只要單執行緒語義不變，編譯器就可能調整。</p>
<h2 id="45-綜合解法對應-451452"><a class="header" href="#45-綜合解法對應-451452">4.5 綜合解法（對應 4.5.1~4.5.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-4"><a class="header" href="#本小節示意圖-4">本小節示意圖</a></h3>
<pre><code class="language-text">三種問題 vs 三種解法對比：

  ┌──────────────────┬────────────────────────────────────────────────────────────┐
  │  解法             │  原子性 ✓/✗   可見性 ✓/✗   有序性 ✓/✗   適用場景         │
  ├──────────────────┼────────────────────────────────────────────────────────────┤
  │  原子類型          │    ✓           ✓           部分✓         計數器、狀態旗標  │
  │  (atomic int等)  │  CAS/fetch_add  強制刷新   依 memory_order  無鎖演算法      │
  ├──────────────────┼────────────────────────────────────────────────────────────┤
  │  互斥鎖            │    ✓           ✓            ✓           複雜臨界區         │
  │  (mutex/lock)    │  鎖保護整段     解鎖時刷新   鎖保證 HB 關係  讀寫都有的情況   │
  ├──────────────────┼────────────────────────────────────────────────────────────┤
  │  記憶體屏障         │    ✗           ✓            ✓           底層程式庫開發     │
  │  (memory_order)  │  不解決原子性   禁止快取優化  禁止重排       硬體驅動開發     │
  └──────────────────┴────────────────────────────────────────────────────────────┘

  選擇指引：

  需要原子計數/旗標？
      └──► 優先選 atomic（零鎖開銷）

  臨界區有多個操作需要一起保護？
      └──► 必須選 mutex（原子類型只能保護單個變數）

  寫底層庫、需要精細控制記憶體順序？
      └──► 結合 atomic + 精確的 memory_order

  producer-consumer 資料傳遞？
      └──► atomic flag（ready） + 適當 memory_order，或直接用 channel/queue
</code></pre>
<ul>
<li>原子類 + CAS</li>
<li>鎖</li>
<li>記憶體屏障/語言記憶體模型規則</li>
</ul>
<h2 id="示意圖"><a class="header" href="#示意圖">示意圖</a></h2>
<pre><code class="language-text">完整問題場景（寫端/讀端的可見性與有序性）：

  Writer:
    data = 42;     // Step 1：寫資料
    ready = true;  // Step 2：設旗標

  Reader:
    if (ready)     // Step 3：讀旗標
        print(data) // Step 4：讀資料

  若重排/不可見：可能讀到 ready=true 但 data=舊值（0 或垃圾值）
  解法：ready 使用 atomic，並在 writer 側加 release 屏障，reader 側加 acquire 屏障
</code></pre>
<h2 id="跨語言完整範例"><a class="header" href="#跨語言完整範例">跨語言完整範例</a></h2>
<p>用 atomic flag 安全地在兩個執行緒間傳遞數據（producer-consumer with ready flag）。</p>
<h3 id="cgcc-__atomic-內建函式"><a class="header" href="#cgcc-__atomic-內建函式">C（GCC __atomic 內建函式）</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;unistd.h&gt;

int data = 0;
atomic_int ready = 0;

void *writer(void *arg) {
    data = 42;                                       /* 先寫資料 */
    atomic_store_explicit(&amp;ready, 1,                 /* 再設旗標，release 語意 */
                          memory_order_release);
    return NULL;
}

void *reader(void *arg) {
    while (!atomic_load_explicit(&amp;ready,             /* 等待旗標，acquire 語意 */
                                 memory_order_acquire))
        ;                                            /* 自旋等待 */
    printf("reader got data = %d\n", data);          /* 保證看到 data=42 */
    return NULL;
}

int main(void) {
    pthread_t w, r;
    pthread_create(&amp;r, NULL, reader, NULL);
    usleep(10000);
    pthread_create(&amp;w, NULL, writer, NULL);
    pthread_join(w, NULL);
    pthread_join(r, NULL);
    return 0;
}
</code></pre>
<pre><code class="language-bash">gcc -std=c11 -o ready ready.c -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="cstdatomic-with-memory_order"><a class="header" href="#cstdatomic-with-memory_order">C++（std::atomic with memory_order）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;

int data = 0;
std::atomic&lt;bool&gt; ready{false};

void writer() {
    data = 42;                                     // 先寫資料
    ready.store(true, std::memory_order_release);  // release：之前的寫對 acquire 端可見
}

void reader() {
    while (!ready.load(std::memory_order_acquire)) // acquire：保證讀到 writer 的所有寫入
        std::this_thread::yield();
    std::cout &lt;&lt; "reader got data = " &lt;&lt; data &lt;&lt; "\n";
}

int main() {
    std::thread r(reader);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::thread w(writer);
    w.join();
    r.join();
}
</code></pre>
<pre><code class="language-bash">g++ -std=c++17 -o ready ready.cpp -lpthread &amp;&amp; ./ready
</code></pre>
<h3 id="ruststdsyncatomic-with-ordering"><a class="header" href="#ruststdsyncatomic-with-ordering">Rust（std::sync::atomic with Ordering）</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread;
use std::time::Duration;

static mut DATA: i32 = 0;
static READY: AtomicBool = AtomicBool::new(false);

fn main() {
    let reader = thread::spawn(|| {
        while !READY.load(Ordering::Acquire) {
            thread::yield_now();
        }
        let val = unsafe { DATA };
        println!("reader got data = {}", val);
    });

    thread::sleep(Duration::from_millis(10));

    let writer = thread::spawn(|| {
        unsafe { DATA = 42; }                       // 先寫資料
        READY.store(true, Ordering::Release);        // release 屏障後設旗標
    });

    writer.join().unwrap();
    reader.join().unwrap();
}</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<h3 id="gosyncatomic--channel-作為-ready-信號"><a class="header" href="#gosyncatomic--channel-作為-ready-信號">Go（sync/atomic + channel 作為 ready 信號）</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

var (
    data  int32
    ready atomic.Bool
)

func writer() {
    atomic.StoreInt32(&amp;data, 42)  // 寫資料
    ready.Store(true)             // 設旗標（Go atomic 已包含適當 memory barrier）
}

func reader() {
    for !ready.Load() {           // 等待旗標
        time.Sleep(time.Microsecond)
    }
    fmt.Printf("reader got data = %d\n", atomic.LoadInt32(&amp;data))
}

func main() {
    go reader()
    time.Sleep(10 * time.Millisecond)
    go writer()
    time.Sleep(100 * time.Millisecond) // 等兩個 goroutine 完成
}
</code></pre>
<pre><code class="language-bash">go run main.go
</code></pre>
<h3 id="pythonthreadingevent-作為-ready-信號"><a class="header" href="#pythonthreadingevent-作為-ready-信號">Python（threading.Event 作為 ready 信號）</a></h3>
<pre><code class="language-python">import threading
import time

data = {"value": None}
ready = threading.Event()   # Event 內建 happens-before 語意

def writer():
    data["value"] = 42      # 先寫資料
    ready.set()             # 設旗標（Event.set() 保證可見性）

def reader():
    ready.wait()            # 阻塞等待旗標（比自旋更節省 CPU）
    print(f"reader got data = {data['value']}")

if __name__ == "__main__":
    t_reader = threading.Thread(target=reader)
    t_reader.start()
    time.sleep(0.02)
    t_writer = threading.Thread(target=writer)
    t_writer.start()
    t_writer.join()
    t_reader.join()
</code></pre>
<pre><code class="language-bash">python3 ready.py
</code></pre>
<h2 id="完整專案級範例python"><a class="header" href="#完整專案級範例python">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch04.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch04.py
</code></pre>
<pre><code class="language-python">"""Chapter 04: visibility/order via event.

展示：
1. Writer 先寫資料，再設旗標（模擬正確的 release 語意）
2. Reader 等待旗標後讀資料（模擬正確的 acquire 語意）
3. threading.Event 內建 happens-before 保證，確保讀到正確值
"""
import threading
import time

ready = threading.Event()
data = {"value": None}


def writer():
    data["value"] = 42      # Step 1：先寫資料
    ready.set()             # Step 2：設旗標（之後的 reader 保證看到 data=42）


def reader():
    ready.wait()            # 等待旗標（阻塞直到 writer 呼叫 set()）
    print("read value =", data["value"])   # 保證印出 42


if __name__ == "__main__":
    t1 = threading.Thread(target=writer)
    t2 = threading.Thread(target=reader)
    t2.start()
    time.sleep(0.02)
    t1.start()
    t1.join()
    t2.join()
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-core-problems.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch05-atomic-foundation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-core-problems.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch05-atomic-foundation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
