<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第20章 秒殺系統架構 - 高並發編程通用概念（跨 Java/C++/Rust/Go）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/beautiful-mermaid.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">高並發編程通用概念（跨 Java/C++/Rust/Go）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第20章-秒殺系統架構"><a class="header" href="#第20章-秒殺系統架構">第20章 秒殺系統架構</a></h1>
<h2 id="201-電商基礎架構"><a class="header" href="#201-電商基礎架構">20.1 電商基礎架構</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖"><a class="header" href="#本小節示意圖">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["電商系統分層架構"]
  N2["使用者請求"]
  N3["接入層"]
  N4["CDN Nginx"]
  N5["靜態資源 反向代理"]
  N6["快取 負載均衡"]
  N7["動態請求"]
  N8["閘道層"]
  N9["限流 認證/鑑權"]
  N10["Token Bucket JWT / Session"]
  N11["業務層"]
  N12["訂單服務 庫存服務"]
  N13["OrderService StockService"]
  N14["防重 / 支付 扣減 / 補償"]
  N15["快取層"]
  N16["Redis Cluster"]
  N17["・庫存計數（stock:sku:001 = 1000）"]
  N18["・防重 Token（setnx order:uid）"]
  N19["・限流計數器"]
  N20["讀未命中 / 最終持久化"]
  N21["資料層"]
  N22["MySQL（主從分離）"]
  N23["・訂單表 / 庫存表"]
  N24["・對賬記錄"]
  N25["Consumer 消費"]
  N26["異步層"]
  N27["MQ（Kafka/RMQ） Consumer Worker"]
  N28["削峰平滑流量 非同步落庫"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N6 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N19 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N24 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
</code></pre>
<p>入口層、業務層、資料層、異步層缺一不可。</p>
<h2 id="202-秒殺特性對應-20212022"><a class="header" href="#202-秒殺特性對應-20212022">20.2 秒殺特性（對應 20.2.1~20.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-1"><a class="header" href="#本小節示意圖-1">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["正常流量 vs 秒殺瞬間流量對比"]
  N2["QPS"]
  N3["(萬)"]
  N4["100"]
  N5["50"]
  N6["10 正常基線"]
  N7["1"]
  N8["0 時間"]
  N9["秒殺 持續約 5 分鐘 流量回落"]
  N10["開始"]
  N11["T0"]
  N12["秒殺瞬間特性"]
  N13["・流量是平時的 100x（10萬 QPS vs 正常 1000 QPS）"]
  N14["・熱點 key: 少數 SKU 被高頻存取（Redis 熱點問題）"]
  N15["・超賣風險: 多節點並發扣減同一庫存"]
  N16["・重複下單: 用戶多次點擊「搶購」按鈕"]
  N17["・容錯窗口極短: 5 分鐘內必須解決，無法慢慢修"]
  N18["關鍵挑戰"]
  N19["問題 應對策略"]
  N20["熱點 key 庫存分段（多個 Redis key 分散）"]
  N21["超賣 Lua 原子扣減 + 回滾"]
  N22["重複下單 SETNX 冪等 Token"]
  N23["DB 打爆 異步 MQ 削峰"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N4 --&gt; N5
  N4 --&gt; N6
  N6 --&gt; N7
  N6 --&gt; N8
  N8 --&gt; N9
  N8 --&gt; N10
  N8 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
</code></pre>
<p>高峰值、瞬時流量、熱點資料、低容錯窗口。</p>
<h2 id="203-活動前中後對應-20312032"><a class="header" href="#203-活動前中後對應-20312032">20.3 活動前中後（對應 20.3.1~20.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-2"><a class="header" href="#本小節示意圖-2">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["秒殺活動生命週期時間軸"]
  N2["活動前（T0 之前）"]
  N3["T-24h T-1h T-10min T0（秒殺開始）"]
  N4["[庫存 [壓測 [暖機 [流量"]
  N5["資料 模擬 Redis 湧入]"]
  N6["預熱] 100x 庫存]"]
  N7["流量] 必須在 T0 前完成所有準備"]
  N8["預熱快取"]
  N9["・提前 SET stock:sku:001 1000（庫存寫入 Redis）"]
  N10["・提前載入商品詳情到快取（避免秒殺時打 DB）"]
  N11["壓測"]
  N12["・使用 wrk/JMeter 模擬 10萬 QPS"]
  N13["・確認系統瓶頸、調整連線池/執行緒池"]
  N14["擴容"]
  N15["・水平擴展應用層（K8s 預先 scale out）"]
  N16["・Redis 記憶體確認充裕"]
  N17["秒殺進行中（T0 ~ T0+5min）"]
  N18["T0 T0+1min T0+5min"]
  N19["[限流閘道] [庫存售罄] [流量回落]"]
  N20["[MQ 緩衝] [標記售罄標誌] [等待 MQ 消化]"]
  N21["[降級靜態頁] [拒絕後續請求]"]
  N22["活動後（T0+5min 之後）"]
  N23["T0+5min T0+1h T0+24h"]
  N24["[Consumer [對賬: [縮容"]
  N25["消化 MQ] Redis庫存 釋放多餘"]
  N26["[落庫訂單] vs DB庫存] 應用實例]"]
  N27["[補償異常單]"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N4 --&gt; N5
  N4 --&gt; N6
  N6 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N24 --&gt; N25
  N1 --&gt; N26
  N26 --&gt; N27
</code></pre>
<ul>
<li>前：預熱快取、壓測、擴容</li>
<li>中：限流、降級、削峰</li>
<li>後：對賬、補償、回放</li>
</ul>
<h2 id="204-同步與異步下單對應-20412042"><a class="header" href="#204-同步與異步下單對應-20412042">20.4 同步與異步下單（對應 20.4.1~20.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-3"><a class="header" href="#本小節示意圖-3">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["同步下單 vs 異步下單對比"]
  N2["同步下單（直接寫 DB）"]
  N3["User API Server MySQL DB"]
  N4["每次請求直接寫 DB"]
  N5["響應 200ms~2s"]
  N6["問題"]
  N7["・10 萬 QPS DB 無法承受（通常 MySQL 上限 1000~5000 QPS）"]
  N8["・響應時間長 連線池耗盡 雪崩"]
  N9["時間軸"]
  N10["Req1 [API] [DB寫] 回應"]
  N11["Req2 [API] [DB寫] 回應"]
  N12["Req1000 [API] DB 超載！逾時！"]
  N13["異步下單（MQ 削峰）"]
  N14["User API Server MQ (Kafka) Consumer MySQL DB"]
  N15["毫秒級入隊 按 DB 速率消費"]
  N16["（平滑寫入）"]
  N17["立即返回「搶購成功，訂單處理中」"]
  N18["時間軸"]
  N19["T=0: User 請求 API 入 MQ 立即返回（&amp;lt; 10ms）"]
  N20["T=1s: Consumer 消費 MQ 寫 DB（每秒 5000 條）"]
  N21["T=20s: 所有訂單落庫完成"]
  N22["比較"]
  N23["同步下單 異步下單"]
  N24["響應時間 200ms~2s &amp;lt; 10ms"]
  N25["DB 峰值壓力 = 用戶 QPS Consumer 速率控制"]
  N26["用戶體驗 等待結果 樂觀返回+通知"]
  N27["複雜度 低 高（需 MQ+補償）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N3 --&gt; N4
  N3 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N14 --&gt; N15
  N14 --&gt; N16
  N14 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
</code></pre>
<p>同步直寫簡單但容易打爆；異步用 MQ 平滑流量。</p>
<h2 id="205-扣庫存策略對應-20512055"><a class="header" href="#205-扣庫存策略對應-20512055">20.5 扣庫存策略（對應 20.5.1~20.5.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-4"><a class="header" href="#本小節示意圖-4">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["三種扣庫存時機比較"]
  N2["策略一: 下單時扣庫存"]
  N3["用戶下單 扣減 stock 建立訂單 等待支付 支付完成"]
  N4["若超時未支付 需要定時任務歸還庫存"]
  N5["優點: 超賣風險低（下單即鎖定）"]
  N6["缺點: 惡意用戶可佔庫存不付款；持鎖時間長"]
  N7["策略二: 付款時扣庫存"]
  N8["用戶下單 建立訂單(不扣庫存) 支付完成 扣減 stock"]
  N9["可能已無庫存"]
  N10["超賣！"]
  N11["優點: 庫存利用率高"]
  N12["缺點: 超賣風險高（多人下單 同時支付 最後才扣庫存）"]
  N13["策略三: 預扣 + 支付確認（最安全）"]
  N14["用戶下單"]
  N15["Redis 預扣: DECR stock:sku:001"]
  N16["成功（&amp;gt;= 0） 建立預訂單（鎖定庫存）"]
  N17["用戶支付"]
  N18["支付成功 支付失敗/超時"]
  N19["DB 落庫 補償: INCR stock 歸還"]
  N20["失敗（&amp;lt; 0） INCR 回滾 返回售罄"]
  N21["策略對比"]
  N22["策略 超賣風險 持鎖時間 補償複雜度"]
  N23["下單扣 低 長 定時任務歸還"]
  N24["付款扣 高 短 超賣後補"]
  N25["預扣+確認 極低 中 INCR 補償"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N3 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N8 --&gt; N9
  N9 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N15 --&gt; N16
  N15 --&gt; N17
  N15 --&gt; N18
  N15 --&gt; N19
  N15 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
</code></pre>
<p>下單扣、付款扣、預扣各有一致性風險。</p>
<h2 id="206-redis-庫存與防超賣對應-20612064"><a class="header" href="#206-redis-庫存與防超賣對應-20612064">20.6 Redis 庫存與防超賣（對應 20.6.1~20.6.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-5"><a class="header" href="#本小節示意圖-5">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["Redis Lua 原子扣減防超賣 + SETNX 防重下單"]
  N2["Lua 原子扣減流程"]
  N3["用戶請求"]
  N4["Lua 腳本（原子執行，不被中斷）"]
  N5["local stock = redis.call('DECR', KEYS[1])"]
  N6["if stock &amp;gt;= 0 then"]
  N7["return 1 -- 扣減成功"]
  N8["else"]
  N9["redis.call('INCR', KEYS[1]) -- 回滾"]
  N10["return 0 -- 售罄"]
  N11["end"]
  N12["返回 1 or 0"]
  N13["1（成功） 進入下單流程"]
  N14["0（售罄） 返回「已售罄」頁面"]
  N15["SETNX 防重下單"]
  N16["用戶 uid=1001 點擊搶購"]
  N17["SETNX order:1001:sku:001 \"1\" EX 300"]
  N18["成功（首次） 允許下單"]
  N19["失敗（已有） 返回「您已下單，請勿重複」"]
  N20["整體防超賣流程"]
  N21["請求進入"]
  N22["[限流檢查: 令牌桶]"]
  N23["通過"]
  N24["[防重檢查: SETNX order:uid:sku]"]
  N25["非重複"]
  N26["[Lua 原子扣庫存: DECR stock:sku]"]
  N27["stock &amp;gt;= 0"]
  N28["[入 MQ 異步落庫]"]
  N29["[返回: 「搶購成功」]"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N11 --&gt; N12
  N11 --&gt; N13
  N11 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N17 --&gt; N18
  N17 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N22 --&gt; N23
  N1 --&gt; N24
  N24 --&gt; N25
  N1 --&gt; N26
  N26 --&gt; N27
  N1 --&gt; N28
  N1 --&gt; N29
</code></pre>
<p>原子扣減 + 分段庫存 + 防重 + 風控。</p>
<h2 id="207-系統與網路優化對應-20712074"><a class="header" href="#207-系統與網路優化對應-20712074">20.7 系統與網路優化（對應 20.7.1~20.7.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-6"><a class="header" href="#本小節示意圖-6">本小節示意圖</a></h3>
<pre><code class="language-mermaid">flowchart TD
  N0["本小節示意圖"]
  N1["系統調優清單"]
  N2["OS 層優化"]
  N3["・ulimit -n 65535 增大最大檔案/連線數"]
  N4["・/proc/sys/net/core/somaxconn 增大 listen backlog"]
  N5["・TCP_NODELAY 關閉 Nagle 算法，降低延遲"]
  N6["・vm.swappiness=1 減少 swap，避免延遲尖刺"]
  N7["網路層優化"]
  N8["・TCP keepalive 複用連線，避免頻繁三次握手"]
  N9["・SO_REUSEPORT 多個 worker 共用同一 port，核心分流"]
  N10["Worker 1 Worker 2 Worker 3"]
  N11["8080 :8080 :8080"]
  N12["核心按 CPU 親和性分發連線（SO_REUSEPORT）"]
  N13["連線池優化"]
  N14["DB 連線池"]
  N15["・pool_size = CPU核數 × 2（避免過多上下文切換）"]
  N16["・max_overflow = pool_size × 2"]
  N17["・pool_timeout = 30s（避免無限等待）"]
  N18["Redis 連線池"]
  N19["・每個應用節點保持 10~50 個長連線"]
  N20["・避免頻繁 connect/disconnect"]
  N21["CDN 與靜態資源"]
  N22["用戶 CDN（命中） 直接返回靜態頁（不過業務層）"]
  N23["CDN（未命中） 回源 Nginx 快取"]
  N24["秒殺頁面應 100% 靜態化"]
  N25["・商品詳情頁: 提前生成 HTML"]
  N26["・圖片/JS/CSS: CDN 邊緣節點快取"]
  N27["・倒計時: 前端 JS 本地計算，不請求後端"]
  N28["整體優化效益"]
  N29["項目 優化前 優化後"]
  N30["最大 QPS 1萬 20萬"]
  N31["P99 延遲 500ms 20ms"]
  N32["DB 壓力 100% 10%（MQ 削峰）"]
  N33["CPU 使用率 90%（白旋） 60%（有效計算）"]
  N0 --&gt; N1
  N1 --&gt; N2
  N1 --&gt; N3
  N1 --&gt; N4
  N1 --&gt; N5
  N1 --&gt; N6
  N1 --&gt; N7
  N1 --&gt; N8
  N1 --&gt; N9
  N1 --&gt; N10
  N1 --&gt; N11
  N1 --&gt; N12
  N1 --&gt; N13
  N1 --&gt; N14
  N1 --&gt; N15
  N1 --&gt; N16
  N1 --&gt; N17
  N1 --&gt; N18
  N1 --&gt; N19
  N1 --&gt; N20
  N1 --&gt; N21
  N1 --&gt; N22
  N1 --&gt; N23
  N1 --&gt; N24
  N1 --&gt; N25
  N1 --&gt; N26
  N1 --&gt; N27
  N1 --&gt; N28
  N1 --&gt; N29
  N1 --&gt; N30
  N1 --&gt; N31
  N1 --&gt; N32
  N1 --&gt; N33
</code></pre>
<p>OS 參數、連線池、TCP 調優、機房拓樸都影響上限。</p>
<pre><code class="language-text">User -&gt; Gateway -&gt; RateLimit -&gt; MQ -&gt; OrderSvc -&gt; Stock(Redis/DB)
</code></pre>
<h2 id="示意圖"><a class="header" href="#示意圖">示意圖</a></h2>
<pre><code class="language-text">Client -&gt; Gateway -&gt; RateLimiter -&gt; MQ -&gt; OrderWorker -&gt; RedisStock -&gt; DB
高峰流量先削峰，再異步消化
</code></pre>
<h2 id="跨語言完整範例"><a class="header" href="#跨語言完整範例">跨語言完整範例</a></h2>
<h3 id="c--秒殺核心原子庫存扣減--防重--令牌桶限流"><a class="header" href="#c--秒殺核心原子庫存扣減--防重--令牌桶限流">C — 秒殺核心：原子庫存扣減 + 防重 + 令牌桶限流</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define MAX_USERS   100
#define INIT_STOCK  5

/* ── 令牌桶限流 ── */
typedef struct {
    atomic_int tokens;
    int capacity;
    pthread_mutex_t mu;
} TokenBucket;

void bucket_init(TokenBucket *b, int cap) {
    atomic_init(&amp;b-&gt;tokens, cap);
    b-&gt;capacity = cap;
    pthread_mutex_init(&amp;b-&gt;mu, NULL);
}

int bucket_take(TokenBucket *b) {
    int t = atomic_fetch_sub(&amp;b-&gt;tokens, 1);
    return t &gt; 0;
}

/* ── 防重（冪等）表 ── */
static int order_submitted[MAX_USERS];
static pthread_mutex_t idem_mu = PTHREAD_MUTEX_INITIALIZER;

int check_and_mark(int uid) {
    pthread_mutex_lock(&amp;idem_mu);
    int dup = order_submitted[uid];
    if (!dup) order_submitted[uid] = 1;
    pthread_mutex_unlock(&amp;idem_mu);
    return !dup;  /* 1: 首次, 0: 重複 */
}

/* ── 庫存原子扣減 ── */
static atomic_int stock = ATOMIC_VAR_INIT(INIT_STOCK);

int deduct_stock(void) {
    int cur = atomic_fetch_sub(&amp;stock, 1);
    if (cur &gt; 0) return 1;
    atomic_fetch_add(&amp;stock, 1);  /* 回滾 */
    return 0;
}

/* ── 秒殺主流程 ── */
typedef struct { int uid; TokenBucket *bucket; int *results; } Task;

void *seckill(void *arg) {
    Task *t = (Task *)arg;
    int uid = t-&gt;uid;
    /* 限流 */
    if (!bucket_take(t-&gt;bucket)) { t-&gt;results[uid] = -1; return NULL; }
    /* 防重 */
    if (!check_and_mark(uid)) { t-&gt;results[uid] = -2; return NULL; }
    /* 扣庫存 */
    t-&gt;results[uid] = deduct_stock() ? 1 : 0;
    return NULL;
}

int main(void) {
    TokenBucket bucket;
    bucket_init(&amp;bucket, 20);  /* 限流：每批最多 20 個請求 */

    int results[MAX_USERS] = {0};
    pthread_t tids[MAX_USERS];
    Task tasks[MAX_USERS];

    for (int i = 0; i &lt; MAX_USERS; i++) {
        tasks[i] = (Task){i, &amp;bucket, results};
        pthread_create(&amp;tids[i], NULL, seckill, &amp;tasks[i]);
    }
    for (int i = 0; i &lt; MAX_USERS; i++) pthread_join(tids[i], NULL);

    int success = 0;
    for (int i = 0; i &lt; MAX_USERS; i++) if (results[i] == 1) success++;
    printf("成功購買人數: %d (初始庫存 %d)\n", success, INIT_STOCK);
    printf("剩餘庫存: %d (應為 0)\n", atomic_load(&amp;stock));
    return 0;
}
</code></pre>
<h3 id="c--秒殺核心原子庫存--防重--令牌桶"><a class="header" href="#c--秒殺核心原子庫存--防重--令牌桶">C++ — 秒殺核心：原子庫存 + 防重 + 令牌桶</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

class TokenBucket {
    std::atomic&lt;int&gt; tokens_;
public:
    TokenBucket(int cap) : tokens_(cap) {}
    bool take() {
        int t = tokens_.fetch_sub(1, std::memory_order_acq_rel);
        return t &gt; 0;
    }
};

class IdempotentGuard {
    std::unordered_set&lt;int&gt; seen_;
    std::mutex mu_;
public:
    bool mark_first(int uid) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        return seen_.insert(uid).second;
    }
};

class StockManager {
    std::atomic&lt;int&gt; stock_;
public:
    StockManager(int init) : stock_(init) {}
    bool deduct() {
        int cur = stock_.fetch_sub(1, std::memory_order_acq_rel);
        if (cur &gt; 0) return true;
        stock_.fetch_add(1, std::memory_order_acq_rel);  /* 回滾 */
        return false;
    }
    int remaining() const { return stock_.load(); }
};

int main() {
    const int USER_COUNT = 100;
    const int INIT_STOCK = 5;

    TokenBucket bucket(20);
    IdempotentGuard idem;
    StockManager stock(INIT_STOCK);
    std::atomic&lt;int&gt; success_count{0};

    auto seckill = [&amp;](int uid) {
        if (!bucket.take()) return;          /* 限流 */
        if (!idem.mark_first(uid)) return;   /* 防重 */
        if (stock.deduct()) {
            success_count.fetch_add(1, std::memory_order_relaxed);
        }
    };

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; USER_COUNT; i++)
        threads.emplace_back(seckill, i);
    for (auto &amp;t : threads) t.join();

    std::cout &lt;&lt; "成功購買人數: " &lt;&lt; success_count.load()
              &lt;&lt; " (初始庫存 " &lt;&lt; INIT_STOCK &lt;&lt; ")\n";
    std::cout &lt;&lt; "剩餘庫存: " &lt;&lt; stock.remaining() &lt;&lt; " (應為 0)\n";
}
</code></pre>
<h3 id="rust--秒殺核心atomici32-原子庫存--hashset-防重"><a class="header" href="#rust--秒殺核心atomici32-原子庫存--hashset-防重">Rust — 秒殺核心：AtomicI32 原子庫存 + HashSet 防重</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;
use std::sync::{Arc, Mutex, atomic::{AtomicI32, Ordering}};
use std::thread;

struct Seckill {
    stock: AtomicI32,
    seen: Mutex&lt;HashSet&lt;u32&gt;&gt;,
    tokens: AtomicI32,
}

impl Seckill {
    fn new(init_stock: i32, rate_limit: i32) -&gt; Self {
        Seckill {
            stock: AtomicI32::new(init_stock),
            seen: Mutex::new(HashSet::new()),
            tokens: AtomicI32::new(rate_limit),
        }
    }
    fn try_buy(&amp;self, uid: u32) -&gt; &amp;'static str {
        if self.tokens.fetch_sub(1, Ordering::AcqRel) &lt;= 0 {
            self.tokens.fetch_add(1, Ordering::AcqRel);
            return "限流拒絕";
        }
        {
            let mut seen = self.seen.lock().unwrap();
            if !seen.insert(uid) { return "重複下單"; }
        }
        let cur = self.stock.fetch_sub(1, Ordering::AcqRel);
        if cur &gt; 0 { "購買成功" } else {
            self.stock.fetch_add(1, Ordering::AcqRel);
            "售罄"
        }
    }
}

fn main() {
    let sk = Arc::new(Seckill::new(5, 20));
    let mut handles = vec![];
    for uid in 0..100u32 {
        let sk = Arc::clone(&amp;sk);
        handles.push(thread::spawn(move || {
            let result = sk.try_buy(uid);
            if result == "購買成功" {
                println!("uid={} 購買成功", uid);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("剩餘庫存: {} (應為 0)", sk.stock.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--秒殺核心syncatomic-庫存--syncmap-防重"><a class="header" href="#go--秒殺核心syncatomic-庫存--syncmap-防重">Go — 秒殺核心：sync/atomic 庫存 + sync.Map 防重</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var (
    stock      int64 = 5
    tokens     int64 = 20
    orderSeen  sync.Map
    successCnt int64
)

func rateLimitPass() bool {
    t := atomic.AddInt64(&amp;tokens, -1)
    return t &gt;= 0
}

func markFirst(uid int) bool {
    _, loaded := orderSeen.LoadOrStore(uid, struct{}{})
    return !loaded
}

func deductStock() bool {
    cur := atomic.AddInt64(&amp;stock, -1)
    if cur &gt;= 0 {
        return true
    }
    atomic.AddInt64(&amp;stock, 1) // 回滾
    return false
}

func seckill(uid int, wg *sync.WaitGroup) {
    defer wg.Done()
    if !rateLimitPass() {
        return
    }
    if !markFirst(uid) {
        return
    }
    if deductStock() {
        atomic.AddInt64(&amp;successCnt, 1)
    }
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go seckill(i, &amp;wg)
    }
    wg.Wait()
    fmt.Printf("成功購買人數: %d (初始庫存 5)\n", atomic.LoadInt64(&amp;successCnt))
    fmt.Printf("剩餘庫存: %d (應為 0)\n", atomic.LoadInt64(&amp;stock))
}
</code></pre>
<h3 id="python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流"><a class="header" href="#python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流">Python — 秒殺核心：MockRedis Lua 原子扣減 + SETNX 防重 + 限流</a></h3>
<pre><code class="language-python">"""Chapter 20: seckill core — atomic stock deduct + idempotent + rate limit."""
import threading
import time


class MockRedis:
    """模擬 Redis 的原子操作：DECR（Lua）與 SETNX。"""

    def __init__(self):
        self._data = {}
        self._mu = threading.Lock()

    def set(self, key: str, value):
        with self._mu:
            self._data[key] = value

    def setnx(self, key: str, value) -&gt; bool:
        """SET key value NX → True: 首次設置成功"""
        with self._mu:
            if key in self._data:
                return False
            self._data[key] = value
            return True

    def lua_deduct_stock(self, key: str) -&gt; bool:
        """原子：DECR key → if &lt; 0: INCR (回滾) return False"""
        with self._mu:
            cur = self._data.get(key, 0)
            if cur &lt;= 0:
                return False
            self._data[key] = cur - 1
            return True

    def get(self, key: str):
        with self._mu:
            return self._data.get(key)


class TokenBucket:
    def __init__(self, capacity: int, refill_per_sec: int):
        self._tokens = capacity
        self._capacity = capacity
        self._refill_rate = refill_per_sec
        self._last_refill = time.monotonic()
        self._mu = threading.Lock()

    def take(self) -&gt; bool:
        with self._mu:
            now = time.monotonic()
            elapsed = now - self._last_refill
            self._tokens = min(
                self._capacity,
                self._tokens + int(elapsed * self._refill_rate)
            )
            self._last_refill = now
            if self._tokens &gt; 0:
                self._tokens -= 1
                return True
            return False


def run_seckill(user_count: int = 100, init_stock: int = 5):
    redis = MockRedis()
    bucket = TokenBucket(capacity=20, refill_per_sec=10)

    redis.set("stock:sku:001", init_stock)

    results = {"success": 0, "sold_out": 0, "limited": 0, "dup": 0}
    results_lock = threading.Lock()

    def buyer(uid: int):
        # 步驟 1：限流
        if not bucket.take():
            with results_lock:
                results["limited"] += 1
            return

        # 步驟 2：防重下單（SETNX）
        order_key = f"order:{uid}:sku:001"
        if not redis.setnx(order_key, "1"):
            with results_lock:
                results["dup"] += 1
            return

        # 步驟 3：Lua 原子扣庫存
        if redis.lua_deduct_stock("stock:sku:001"):
            with results_lock:
                results["success"] += 1
        else:
            with results_lock:
                results["sold_out"] += 1

    threads = [threading.Thread(target=buyer, args=(uid,)) for uid in range(user_count)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    remaining = redis.get("stock:sku:001")
    print(f"初始庫存: {init_stock}")
    print(f"成功購買: {results['success']} (應 &lt;= {init_stock})")
    print(f"售罄拒絕: {results['sold_out']}")
    print(f"限流拒絕: {results['limited']}")
    print(f"重複下單: {results['dup']}")
    print(f"剩餘庫存: {remaining} (應為 0 或正數，不能為負)")
    assert results["success"] &lt;= init_stock, "超賣！"
    assert remaining &gt;= 0, "庫存為負數！"
    print("通過：原子扣減防止超賣，SETNX 防止重複下單")


if __name__ == "__main__":
    run_seckill(user_count=100, init_stock=5)
</code></pre>
<h2 id="完整專案級範例python"><a class="header" href="#完整專案級範例python">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch20.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch20.py
</code></pre>
<pre><code class="language-python">"""Chapter 20: seckill pipeline demo."""
import queue
import threading

stock = 5
q: queue.Queue[str] = queue.Queue()
mu = threading.Lock()


def worker():
    global stock
    while True:
        user = q.get()
        if user == "STOP":
            return
        with mu:
            if stock &gt; 0:
                stock -= 1
                print(user, "success, left", stock)
            else:
                print(user, "sold out")


if __name__ == "__main__":
    t = threading.Thread(target=worker)
    t.start()
    for i in range(10):
        q.put(f"u{i}")
    q.put("STOP")
    t.join()
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-distributed-lock.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="appendix-language-map.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-distributed-lock.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="appendix-language-map.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/beautiful-mermaid.js"></script>



    </div>
    </body>
</html>
