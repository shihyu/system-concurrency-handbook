<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第20章 秒殺系統架構 - 高並發編程通用概念（跨 Java/C++/Rust/Go）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/flowchart.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">高並發編程通用概念（跨 Java/C++/Rust/Go）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第20章-秒殺系統架構"><a class="header" href="#第20章-秒殺系統架構">第20章 秒殺系統架構</a></h1>
<h2 id="201-電商基礎架構"><a class="header" href="#201-電商基礎架構">20.1 電商基礎架構</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖"><a class="header" href="#本小節示意圖">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 電商系統分層架構\n　\n  使用者請求\n       │\n       ▼\n  ┌──────────────────────────────────────────────────────────────────────┐
n2=&gt;operation:   │  接入層                                                                 │\n  │  ┌──────────────┐    ┌──────────────┐                                │\n  │  │     CDN          │    │    Nginx       │                          │\n  │  │  靜態資源            │    │  反向代理          │                          │\n  │  │  快取              │    │  負載均衡          │                          │\n  │  └──────────────┘    └──────────────┘                                │
n3=&gt;operation:   └────────────────────────────┬─────────────────────────────────────────┘\n                               │ 動態請求\n                               ▼\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  閘道層                                                                 │\n  │  ┌──────────────┐    ┌──────────────┐                                │
n4=&gt;operation:   │  │  限流              │    │  認證/鑑權         │                          │\n  │  │  Token Bucket    │    │  JWT / Session │                          │\n  │  └──────────────┘    └──────────────┘                                │\n  └────────────────────────────┬─────────────────────────────────────────┘\n                               │\n                               ▼
n5=&gt;operation:   ┌──────────────────────────────────────────────────────────────────────┐\n  │  業務層                                                                 │\n  │  ┌──────────────────┐  ┌──────────────────┐                          │\n  │  │    訂單服務          │  │    庫存服務          │                          │\n  │  │  OrderService    │  │  StockService    │                          │\n  │  │  防重 / 支付         │  │  扣減 / 補償         │                          │
n6=&gt;operation:   │  └────────┬─────────┘  └────────┬─────────┘                          │\n  └───────────┼─────────────────────┼────────────────────────────────────┘\n              │                     │\n              ▼                     ▼\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  快取層                                                                 │
n7=&gt;operation:   │  ┌──────────────────────────────────────┐                            │\n  │  │  Redis Cluster                       │                            │\n  │  │  ・庫存計數（stock:sku:001 = 1000）         │                            │\n  │  │  ・防重 Token（setnx order:uid）          │                            │\n  │  │  ・限流計數器                              │                            │\n  │  └──────────────────────────────────────┘                            │
n8=&gt;operation:   └────────────────────────────┬─────────────────────────────────────────┘\n                               │ 讀未命中 / 最終持久化\n                               ▼\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  資料層                                                                 │\n  │  ┌──────────────────────────────────────┐                            │
n9=&gt;operation:   │  │  MySQL（主從分離）                         │                            │\n  │  │  ・訂單表 / 庫存表                          │                            │\n  │  │  ・對賬記錄                               │                            │\n  │  └──────────────────────────────────────┘                            │\n  └──────────────────────────────────────────────────────────────────────┘\n              │                     ↑
n10=&gt;operation:               ▼                     │ Consumer 消費\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  異步層                                                                 │\n  │  ┌──────────────────┐  ┌──────────────────┐                          │\n  │  │  MQ（Kafka/RMQ）   │  │  Consumer Worker │                          │\n  │  │  削峰平滑流量          │  │  非同步落庫           │                          │
n11=&gt;operation:   │  └──────────────────┘  └──────────────────┘                          │\n  └──────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
n10-&gt;n11
</code></pre>
<p>入口層、業務層、資料層、異步層缺一不可。</p>
<h2 id="202-秒殺特性對應-20212022"><a class="header" href="#202-秒殺特性對應-20212022">20.2 秒殺特性（對應 20.2.1~20.2.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-1"><a class="header" href="#本小節示意圖-1">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 正常流量 vs 秒殺瞬間流量對比\n　\n  QPS\n  (萬)\n  100 │         ▐█▌\n      │         ███
n2=&gt;operation:       │         ███\n   50 │         ███\n      │         ███\n      │         ███\n   10 │─────────███──────────────────────────────────── 正常基線\n    1 │         ███████████████████████
n3=&gt;operation:       │         ████████████████████████████\n    0 └─────────┼──────────────────────────────────────► 時間\n              秒殺   ←── 持續約 5 分鐘 ───►  流量回落\n              開始\n              T0\n　
n4=&gt;operation:   ┌──────────────────────────────────────────────────────────┐\n  │  秒殺瞬間特性：                                                 │\n  │                                                          │\n  │  ・流量是平時的 100x（10萬 QPS vs 正常 1000 QPS）                    │\n  │  ・熱點 key：少數 SKU 被高頻存取（Redis 熱點問題）                        │\n  │  ・超賣風險：多節點並發扣減同一庫存                                       │
n5=&gt;operation:   │  ・重複下單：用戶多次點擊「搶購」按鈕                                      │\n  │  ・容錯窗口極短：5 分鐘內必須解決，無法慢慢修                                 │\n  └──────────────────────────────────────────────────────────┘\n　\n  關鍵挑戰：\n  ┌─────────────────┬────────────────────────────────────────┐
n6=&gt;operation:   │  問題            │  應對策略                                   │\n  ├─────────────────┼────────────────────────────────────────┤\n  │  熱點 key        │  庫存分段（多個 Redis key 分散）                  │\n  │  超賣            │  Lua 原子扣減 + 回滾                          │\n  │  重複下單        │  SETNX 冪等 Token                           │\n  │  DB 打爆         │  異步 MQ 削峰                               │
n7=&gt;operation:   └─────────────────┴────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<p>高峰值、瞬時流量、熱點資料、低容錯窗口。</p>
<h2 id="203-活動前中後對應-20312032"><a class="header" href="#203-活動前中後對應-20312032">20.3 活動前中後（對應 20.3.1~20.3.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-2"><a class="header" href="#本小節示意圖-2">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 秒殺活動生命週期時間軸\n　\n  ─── 活動前（T0 之前）───────────────────────────────────────\n　\n  T-24h    T-1h      T-10min   T0（秒殺開始）\n    │         │           │         │
n2=&gt;operation:     ▼         ▼           ▼         ▼\n  [庫存    [壓測       [暖機      [流量\n   資料     模擬        Redis      湧入]\n   預熱]    100x        庫存]\n            流量]                ← 必須在 T0 前完成所有準備\n　
n3=&gt;operation:   預熱快取：\n  ・提前 SET stock:sku:001 1000（庫存寫入 Redis）\n  ・提前載入商品詳情到快取（避免秒殺時打 DB）\n　\n  壓測：\n  ・使用 wrk/JMeter 模擬 10萬 QPS
n4=&gt;operation:   ・確認系統瓶頸、調整連線池/執行緒池\n　\n  擴容：\n  ・水平擴展應用層（K8s 預先 scale out）\n  ・Redis 記憶體確認充裕\n　
n5=&gt;operation:   ─── 秒殺進行中（T0 ~ T0+5min）──────────────────────────────\n　\n  T0              T0+1min         T0+5min\n   │                 │                │\n   ▼                 ▼                ▼\n  [限流閘道]      [庫存售罄]      [流量回落]
n6=&gt;operation:   [MQ 緩衝]       [標記售罄標誌]  [等待 MQ 消化]\n  [降級靜態頁]     [拒絕後續請求]\n　\n  ─── 活動後（T0+5min 之後）─────────────────────────────────\n　\n  T0+5min      T0+1h         T0+24h
n7=&gt;operation:       │            │               │\n      ▼            ▼               ▼\n  [Consumer   [對賬：         [縮容：\n   消化 MQ]    Redis庫存      釋放多餘\n  [落庫訂單]   vs DB庫存]    應用實例]\n               [補償異常單]
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
</code></pre>
<ul>
<li>前：預熱快取、壓測、擴容</li>
<li>中：限流、降級、削峰</li>
<li>後：對賬、補償、回放</li>
</ul>
<h2 id="204-同步與異步下單對應-20412042"><a class="header" href="#204-同步與異步下單對應-20412042">20.4 同步與異步下單（對應 20.4.1~20.4.2）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-3"><a class="header" href="#本小節示意圖-3">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 同步下單 vs 異步下單對比\n　\n  ─── 同步下單（直接寫 DB）───────────────────────────────────\n　\n  User ──► API Server ──► MySQL DB\n                │                              │
n2=&gt;operation:                 │             │ 每次請求直接寫 DB\n                │◄────────────┘ 響應 200ms~2s\n                │\n  問題：\n  ・10 萬 QPS → DB 無法承受（通常 MySQL 上限 1000~5000 QPS）\n  ・響應時間長 → 連線池耗盡 → 雪崩
n3=&gt;operation: 　\n  時間軸：\n  Req1 ──► [API] ──────[DB寫]──► 回應\n  Req2 ──► [API] ──────[DB寫]──► 回應\n  ...\n  Req1000 ──► [API] ──► DB 超載！逾時！
n4=&gt;operation: 　\n  ─── 異步下單（MQ 削峰）──────────────────────────────────────\n　\n  User ──► API Server ──► MQ (Kafka) ──► Consumer ──► MySQL DB\n                │              │               │\n                │              │ 毫秒級入隊    │ 按 DB 速率消費
n5=&gt;operation:                 │◄─────────────┘               │ （平滑寫入）\n                │ 立即返回「搶購成功，訂單處理中」\n　\n  時間軸：\n  T=0:   User 請求 API → 入 MQ → 立即返回（&lt; 10ms）\n  T=1s:  Consumer 消費 MQ → 寫 DB（每秒 5000 條）
n6=&gt;operation:   T=20s: 所有訂單落庫完成\n　\n  ┌──────────────────────────────────────────────────────────────────────┐\n  │  比較                                                                  │\n  │  ┌──────────────┬────────────────┬────────────────────┐              │\n  │  │              │  同步下單       │  異步下單              │                 │
n7=&gt;operation:   │  ├──────────────┼────────────────┼────────────────────┤              │\n  │  │  響應時間        │  200ms~2s      │  &lt; 10ms             │             │\n  │  │  DB 峰值壓力     │  = 用戶 QPS    │  Consumer 速率控制    │                 │\n  │  │  用戶體驗        │  等待結果       │  樂觀返回+通知           │                 │\n  │  │  複雜度         │  低            │  高（需 MQ+補償）      │                 │\n  │  └──────────────┴────────────────┴────────────────────┘              │
n8=&gt;operation:   └──────────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
</code></pre>
<p>同步直寫簡單但容易打爆；異步用 MQ 平滑流量。</p>
<h2 id="205-扣庫存策略對應-20512055"><a class="header" href="#205-扣庫存策略對應-20512055">20.5 扣庫存策略（對應 20.5.1~20.5.5）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-4"><a class="header" href="#本小節示意圖-4">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 三種扣庫存時機比較\n　\n  ─── 策略一：下單時扣庫存 ──────────────────────────────────\n　\n  用戶下單 ─► 扣減 stock ─► 建立訂單 ─► 等待支付 ─► 支付完成\n                │
n2=&gt;operation:                 └► 若超時未支付 → 需要定時任務歸還庫存\n　\n  優點：超賣風險低（下單即鎖定）\n  缺點：惡意用戶可佔庫存不付款；持鎖時間長\n　\n  ─── 策略二：付款時扣庫存 ──────────────────────────────────
n3=&gt;operation: 　\n  用戶下單 ─► 建立訂單(不扣庫存) ─► 支付完成 ─► 扣減 stock\n                                                   │\n                                                   └► 可能已無庫存\n                                                      → 超賣！\n　
n4=&gt;operation:   優點：庫存利用率高\n  缺點：超賣風險高（多人下單 → 同時支付 → 最後才扣庫存）\n　\n  ─── 策略三：預扣 + 支付確認（最安全）────────────────────\n　\n  用戶下單
n5=&gt;operation:        │\n       ▼\n  Redis 預扣：DECR stock:sku:001\n       │\n       ├── 成功（&gt;= 0）─► 建立預訂單（鎖定庫存）\n       │                          │
n6=&gt;operation:        │                   ▼\n       │             用戶支付\n       │                          │\n       │             ┌─────┴──────┐\n       │             │            │\n       │          支付成功      支付失敗/超時
n7=&gt;operation:        │             │            │\n       │          DB 落庫      補償：INCR stock 歸還\n       │\n       └── 失敗（&lt; 0）─► INCR 回滾 ─► 返回售罄\n　\n  ┌─────────────────────────────────────────────────────────────────┐
n8=&gt;operation:   │  策略對比                                                           │\n  │  ┌──────────┬──────────┬──────────┬──────────────────┐          │\n  │  │  策略    │  超賣風險   │  持鎖時間    │  補償複雜度       │                 │\n  │  ├──────────┼──────────┼──────────┼──────────────────┤          │\n  │  │  下單扣   │  低       │  長       │  定時任務歸還     │                 │\n  │  │  付款扣   │  高       │  短       │  超賣後補        │                │
n9=&gt;operation:   │  │  預扣+確認 │ 極低      │  中       │  INCR 補償       │               │\n  │  └──────────┴──────────┴──────────┴──────────────────┘          │\n  └─────────────────────────────────────────────────────────────────┘
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>下單扣、付款扣、預扣各有一致性風險。</p>
<h2 id="206-redis-庫存與防超賣對應-20612064"><a class="header" href="#206-redis-庫存與防超賣對應-20612064">20.6 Redis 庫存與防超賣（對應 20.6.1~20.6.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-5"><a class="header" href="#本小節示意圖-5">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Redis Lua 原子扣減防超賣 + SETNX 防重下單\n　\n  ─── Lua 原子扣減流程 ─────────────────────────────────────\n　\n  用戶請求\n       │
n2=&gt;operation:        ▼\n  ┌───────────────────────────────────────────────────────┐\n  │  Lua 腳本（原子執行，不被中斷）                                    │\n  │                                                       │\n  │  local stock = redis.call('DECR', KEYS[1])            │\n  │                                                       │
n3=&gt;operation:   │  if stock &gt;= 0 then                                   │\n  │      return 1  -- 扣減成功                                │\n  │  else                                                 │\n  │      redis.call('INCR', KEYS[1])  -- 回滾               │\n  │      return 0  -- 售罄                                  │\n  │  end                                                  │
n4=&gt;operation:   └───────────────────────────────────────────────────────┘\n       │ 返回 1 or 0\n       │\n       ├── 1（成功）──► 進入下單流程\n       │\n       └── 0（售罄）──► 返回「已售罄」頁面
n5=&gt;operation: 　\n  ─── SETNX 防重下單 ───────────────────────────────────────\n　\n  用戶 uid=1001 點擊搶購\n       │\n       ▼
n6=&gt;operation:   SETNX order:1001:sku:001 "1"  EX 300\n       │\n       ├── 成功（首次）──► 允許下單\n       │\n       └── 失敗（已有）──► 返回「您已下單，請勿重複」\n　
n7=&gt;operation:   ─── 整體防超賣流程 ───────────────────────────────────────\n　\n  請求進入\n       │\n       ▼\n  [限流檢查：令牌桶]
n8=&gt;operation:        │ 通過\n       ▼\n  [防重檢查：SETNX order:uid:sku]\n       │ 非重複\n       ▼\n  [Lua 原子扣庫存：DECR stock:sku]
n9=&gt;operation:        │ stock &gt;= 0\n       ▼\n  [入 MQ 異步落庫]\n       │\n       ▼\n  [返回：「搶購成功」]
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
</code></pre>
<p>原子扣減 + 分段庫存 + 防重 + 風控。</p>
<h2 id="207-系統與網路優化對應-20712074"><a class="header" href="#207-系統與網路優化對應-20712074">20.7 系統與網路優化（對應 20.7.1~20.7.4）</a></h2>
<!-- subsection-diagram -->
<h3 id="本小節示意圖-6"><a class="header" href="#本小節示意圖-6">本小節示意圖</a></h3>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: 系統調優清單\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  OS 層優化                                                       │\n  │                                                               │\n  │  ・ulimit -n 65535   → 增大最大檔案/連線數                              │
n2=&gt;operation:   │  ・/proc/sys/net/core/somaxconn → 增大 listen backlog            │\n  │  ・TCP_NODELAY → 關閉 Nagle 算法，降低延遲                              │\n  │  ・vm.swappiness=1 → 減少 swap，避免延遲尖刺                            │\n  └───────────────────────────────────────────────────────────────┘\n　\n  ┌───────────────────────────────────────────────────────────────┐
n3=&gt;operation:   │  網路層優化                                                        │\n  │                                                               │\n  │  ・TCP keepalive → 複用連線，避免頻繁三次握手                               │\n  │  ・SO_REUSEPORT → 多個 worker 共用同一 port，核心分流                     │\n  │                                                               │\n  │    ┌──────────┐  ┌──────────┐  ┌──────────┐                   │
n4=&gt;operation:   │    │ Worker 1 │  │ Worker 2 │  │ Worker 3 │                   │\n  │    │  :8080   │  │  :8080   │  │  :8080   │                   │\n  │    └──────────┘  └──────────┘  └──────────┘                   │\n  │         ↑              ↑              ↑                       │\n  │    核心按 CPU 親和性分發連線（SO_REUSEPORT）                              │\n  └───────────────────────────────────────────────────────────────┘
n5=&gt;operation: 　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  連線池優化                                                        │\n  │                                                               │\n  │  DB 連線池：                                                      │\n  │  ・pool_size = CPU核數 × 2（避免過多上下文切換）                            │
n6=&gt;operation:   │  ・max_overflow = pool_size × 2                                │\n  │  ・pool_timeout = 30s（避免無限等待）                                  │\n  │                                                               │\n  │  Redis 連線池：                                                   │\n  │  ・每個應用節點保持 10~50 個長連線                                         │\n  │  ・避免頻繁 connect/disconnect                                     │
n7=&gt;operation:   └───────────────────────────────────────────────────────────────┘\n　\n  ┌───────────────────────────────────────────────────────────────┐\n  │  CDN 與靜態資源                                                    │\n  │                                                               │\n  │  用戶 ──► CDN（命中） ──► 直接返回靜態頁（不過業務層）                            │
n8=&gt;operation:   │       └── CDN（未命中）──► 回源 Nginx ──► 快取                         │\n  │                                                               │\n  │  秒殺頁面應 100% 靜態化：                                              │\n  │  ・商品詳情頁：提前生成 HTML                                             │\n  │  ・圖片/JS/CSS：CDN 邊緣節點快取                                        │\n  │  ・倒計時：前端 JS 本地計算，不請求後端                                        │
n9=&gt;operation:   └───────────────────────────────────────────────────────────────┘\n　\n  整體優化效益：\n　\n  項目          優化前      優化後\n  ────────────────────────────────
n10=&gt;operation:   最大 QPS      1萬         20萬\n  P99 延遲      500ms       20ms\n  DB 壓力       100%        10%（MQ 削峰）\n  CPU 使用率    90%（白旋） 60%（有效計算）
st-&gt;n1
n1-&gt;n2
n2-&gt;n3
n3-&gt;n4
n4-&gt;n5
n5-&gt;n6
n6-&gt;n7
n7-&gt;n8
n8-&gt;n9
n9-&gt;n10
</code></pre>
<p>OS 參數、連線池、TCP 調優、機房拓樸都影響上限。</p>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: User → Gateway → RateLimit → MQ → OrderSvc → Stock(Redis/DB)
st-&gt;n1
</code></pre>
<h2 id="示意圖"><a class="header" href="#示意圖">示意圖</a></h2>
<pre><code class="language-flowchart">st=&gt;start: 示意圖
n1=&gt;operation: Client → Gateway → RateLimiter → MQ → OrderWorker → RedisStock → DB\n高峰流量先削峰，再異步消化
st-&gt;n1
</code></pre>
<h2 id="跨語言完整範例"><a class="header" href="#跨語言完整範例">跨語言完整範例</a></h2>
<h3 id="c--秒殺核心原子庫存扣減--防重--令牌桶限流"><a class="header" href="#c--秒殺核心原子庫存扣減--防重--令牌桶限流">C — 秒殺核心：原子庫存扣減 + 防重 + 令牌桶限流</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdatomic.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define MAX_USERS   100
#define INIT_STOCK  5

/* ── 令牌桶限流 ── */
typedef struct {
    atomic_int tokens;
    int capacity;
    pthread_mutex_t mu;
} TokenBucket;

void bucket_init(TokenBucket *b, int cap) {
    atomic_init(&amp;b-&gt;tokens, cap);
    b-&gt;capacity = cap;
    pthread_mutex_init(&amp;b-&gt;mu, NULL);
}

int bucket_take(TokenBucket *b) {
    int t = atomic_fetch_sub(&amp;b-&gt;tokens, 1);
    return t &gt; 0;
}

/* ── 防重（冪等）表 ── */
static int order_submitted[MAX_USERS];
static pthread_mutex_t idem_mu = PTHREAD_MUTEX_INITIALIZER;

int check_and_mark(int uid) {
    pthread_mutex_lock(&amp;idem_mu);
    int dup = order_submitted[uid];
    if (!dup) order_submitted[uid] = 1;
    pthread_mutex_unlock(&amp;idem_mu);
    return !dup;  /* 1: 首次, 0: 重複 */
}

/* ── 庫存原子扣減 ── */
static atomic_int stock = ATOMIC_VAR_INIT(INIT_STOCK);

int deduct_stock(void) {
    int cur = atomic_fetch_sub(&amp;stock, 1);
    if (cur &gt; 0) return 1;
    atomic_fetch_add(&amp;stock, 1);  /* 回滾 */
    return 0;
}

/* ── 秒殺主流程 ── */
typedef struct { int uid; TokenBucket *bucket; int *results; } Task;

void *seckill(void *arg) {
    Task *t = (Task *)arg;
    int uid = t-&gt;uid;
    /* 限流 */
    if (!bucket_take(t-&gt;bucket)) { t-&gt;results[uid] = -1; return NULL; }
    /* 防重 */
    if (!check_and_mark(uid)) { t-&gt;results[uid] = -2; return NULL; }
    /* 扣庫存 */
    t-&gt;results[uid] = deduct_stock() ? 1 : 0;
    return NULL;
}

int main(void) {
    TokenBucket bucket;
    bucket_init(&amp;bucket, 20);  /* 限流：每批最多 20 個請求 */

    int results[MAX_USERS] = {0};
    pthread_t tids[MAX_USERS];
    Task tasks[MAX_USERS];

    for (int i = 0; i &lt; MAX_USERS; i++) {
        tasks[i] = (Task){i, &amp;bucket, results};
        pthread_create(&amp;tids[i], NULL, seckill, &amp;tasks[i]);
    }
    for (int i = 0; i &lt; MAX_USERS; i++) pthread_join(tids[i], NULL);

    int success = 0;
    for (int i = 0; i &lt; MAX_USERS; i++) if (results[i] == 1) success++;
    printf("成功購買人數: %d (初始庫存 %d)\n", success, INIT_STOCK);
    printf("剩餘庫存: %d (應為 0)\n", atomic_load(&amp;stock));
    return 0;
}
</code></pre>
<h3 id="c--秒殺核心原子庫存--防重--令牌桶"><a class="header" href="#c--秒殺核心原子庫存--防重--令牌桶">C++ — 秒殺核心：原子庫存 + 防重 + 令牌桶</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

class TokenBucket {
    std::atomic&lt;int&gt; tokens_;
public:
    TokenBucket(int cap) : tokens_(cap) {}
    bool take() {
        int t = tokens_.fetch_sub(1, std::memory_order_acq_rel);
        return t &gt; 0;
    }
};

class IdempotentGuard {
    std::unordered_set&lt;int&gt; seen_;
    std::mutex mu_;
public:
    bool mark_first(int uid) {
        std::lock_guard&lt;std::mutex&gt; lk(mu_);
        return seen_.insert(uid).second;
    }
};

class StockManager {
    std::atomic&lt;int&gt; stock_;
public:
    StockManager(int init) : stock_(init) {}
    bool deduct() {
        int cur = stock_.fetch_sub(1, std::memory_order_acq_rel);
        if (cur &gt; 0) return true;
        stock_.fetch_add(1, std::memory_order_acq_rel);  /* 回滾 */
        return false;
    }
    int remaining() const { return stock_.load(); }
};

int main() {
    const int USER_COUNT = 100;
    const int INIT_STOCK = 5;

    TokenBucket bucket(20);
    IdempotentGuard idem;
    StockManager stock(INIT_STOCK);
    std::atomic&lt;int&gt; success_count{0};

    auto seckill = [&amp;](int uid) {
        if (!bucket.take()) return;          /* 限流 */
        if (!idem.mark_first(uid)) return;   /* 防重 */
        if (stock.deduct()) {
            success_count.fetch_add(1, std::memory_order_relaxed);
        }
    };

    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; USER_COUNT; i++)
        threads.emplace_back(seckill, i);
    for (auto &amp;t : threads) t.join();

    std::cout &lt;&lt; "成功購買人數: " &lt;&lt; success_count.load()
              &lt;&lt; " (初始庫存 " &lt;&lt; INIT_STOCK &lt;&lt; ")\n";
    std::cout &lt;&lt; "剩餘庫存: " &lt;&lt; stock.remaining() &lt;&lt; " (應為 0)\n";
}
</code></pre>
<h3 id="rust--秒殺核心atomici32-原子庫存--hashset-防重"><a class="header" href="#rust--秒殺核心atomici32-原子庫存--hashset-防重">Rust — 秒殺核心：AtomicI32 原子庫存 + HashSet 防重</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashSet;
use std::sync::{Arc, Mutex, atomic::{AtomicI32, Ordering}};
use std::thread;

struct Seckill {
    stock: AtomicI32,
    seen: Mutex&lt;HashSet&lt;u32&gt;&gt;,
    tokens: AtomicI32,
}

impl Seckill {
    fn new(init_stock: i32, rate_limit: i32) -&gt; Self {
        Seckill {
            stock: AtomicI32::new(init_stock),
            seen: Mutex::new(HashSet::new()),
            tokens: AtomicI32::new(rate_limit),
        }
    }
    fn try_buy(&amp;self, uid: u32) -&gt; &amp;'static str {
        if self.tokens.fetch_sub(1, Ordering::AcqRel) &lt;= 0 {
            self.tokens.fetch_add(1, Ordering::AcqRel);
            return "限流拒絕";
        }
        {
            let mut seen = self.seen.lock().unwrap();
            if !seen.insert(uid) { return "重複下單"; }
        }
        let cur = self.stock.fetch_sub(1, Ordering::AcqRel);
        if cur &gt; 0 { "購買成功" } else {
            self.stock.fetch_add(1, Ordering::AcqRel);
            "售罄"
        }
    }
}

fn main() {
    let sk = Arc::new(Seckill::new(5, 20));
    let mut handles = vec![];
    for uid in 0..100u32 {
        let sk = Arc::clone(&amp;sk);
        handles.push(thread::spawn(move || {
            let result = sk.try_buy(uid);
            if result == "購買成功" {
                println!("uid={} 購買成功", uid);
            }
        }));
    }
    for h in handles { h.join().unwrap(); }
    println!("剩餘庫存: {} (應為 0)", sk.stock.load(Ordering::SeqCst));
}</code></pre></pre>
<h3 id="go--秒殺核心syncatomic-庫存--syncmap-防重"><a class="header" href="#go--秒殺核心syncatomic-庫存--syncmap-防重">Go — 秒殺核心：sync/atomic 庫存 + sync.Map 防重</a></h3>
<pre><code class="language-go">package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

var (
    stock      int64 = 5
    tokens     int64 = 20
    orderSeen  sync.Map
    successCnt int64
)

func rateLimitPass() bool {
    t := atomic.AddInt64(&amp;tokens, -1)
    return t &gt;= 0
}

func markFirst(uid int) bool {
    _, loaded := orderSeen.LoadOrStore(uid, struct{}{})
    return !loaded
}

func deductStock() bool {
    cur := atomic.AddInt64(&amp;stock, -1)
    if cur &gt;= 0 {
        return true
    }
    atomic.AddInt64(&amp;stock, 1) // 回滾
    return false
}

func seckill(uid int, wg *sync.WaitGroup) {
    defer wg.Done()
    if !rateLimitPass() {
        return
    }
    if !markFirst(uid) {
        return
    }
    if deductStock() {
        atomic.AddInt64(&amp;successCnt, 1)
    }
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i &lt; 100; i++ {
        wg.Add(1)
        go seckill(i, &amp;wg)
    }
    wg.Wait()
    fmt.Printf("成功購買人數: %d (初始庫存 5)\n", atomic.LoadInt64(&amp;successCnt))
    fmt.Printf("剩餘庫存: %d (應為 0)\n", atomic.LoadInt64(&amp;stock))
}
</code></pre>
<h3 id="python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流"><a class="header" href="#python--秒殺核心mockredis-lua-原子扣減--setnx-防重--限流">Python — 秒殺核心：MockRedis Lua 原子扣減 + SETNX 防重 + 限流</a></h3>
<pre><code class="language-python">"""Chapter 20: seckill core — atomic stock deduct + idempotent + rate limit."""
import threading
import time


class MockRedis:
    """模擬 Redis 的原子操作：DECR（Lua）與 SETNX。"""

    def __init__(self):
        self._data = {}
        self._mu = threading.Lock()

    def set(self, key: str, value):
        with self._mu:
            self._data[key] = value

    def setnx(self, key: str, value) -&gt; bool:
        """SET key value NX → True: 首次設置成功"""
        with self._mu:
            if key in self._data:
                return False
            self._data[key] = value
            return True

    def lua_deduct_stock(self, key: str) -&gt; bool:
        """原子：DECR key → if &lt; 0: INCR (回滾) return False"""
        with self._mu:
            cur = self._data.get(key, 0)
            if cur &lt;= 0:
                return False
            self._data[key] = cur - 1
            return True

    def get(self, key: str):
        with self._mu:
            return self._data.get(key)


class TokenBucket:
    def __init__(self, capacity: int, refill_per_sec: int):
        self._tokens = capacity
        self._capacity = capacity
        self._refill_rate = refill_per_sec
        self._last_refill = time.monotonic()
        self._mu = threading.Lock()

    def take(self) -&gt; bool:
        with self._mu:
            now = time.monotonic()
            elapsed = now - self._last_refill
            self._tokens = min(
                self._capacity,
                self._tokens + int(elapsed * self._refill_rate)
            )
            self._last_refill = now
            if self._tokens &gt; 0:
                self._tokens -= 1
                return True
            return False


def run_seckill(user_count: int = 100, init_stock: int = 5):
    redis = MockRedis()
    bucket = TokenBucket(capacity=20, refill_per_sec=10)

    redis.set("stock:sku:001", init_stock)

    results = {"success": 0, "sold_out": 0, "limited": 0, "dup": 0}
    results_lock = threading.Lock()

    def buyer(uid: int):
        # 步驟 1：限流
        if not bucket.take():
            with results_lock:
                results["limited"] += 1
            return

        # 步驟 2：防重下單（SETNX）
        order_key = f"order:{uid}:sku:001"
        if not redis.setnx(order_key, "1"):
            with results_lock:
                results["dup"] += 1
            return

        # 步驟 3：Lua 原子扣庫存
        if redis.lua_deduct_stock("stock:sku:001"):
            with results_lock:
                results["success"] += 1
        else:
            with results_lock:
                results["sold_out"] += 1

    threads = [threading.Thread(target=buyer, args=(uid,)) for uid in range(user_count)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    remaining = redis.get("stock:sku:001")
    print(f"初始庫存: {init_stock}")
    print(f"成功購買: {results['success']} (應 &lt;= {init_stock})")
    print(f"售罄拒絕: {results['sold_out']}")
    print(f"限流拒絕: {results['limited']}")
    print(f"重複下單: {results['dup']}")
    print(f"剩餘庫存: {remaining} (應為 0 或正數，不能為負)")
    assert results["success"] &lt;= init_stock, "超賣！"
    assert remaining &gt;= 0, "庫存為負數！"
    print("通過：原子扣減防止超賣，SETNX 防止重複下單")


if __name__ == "__main__":
    run_seckill(user_count=100, init_stock=5)
</code></pre>
<h2 id="完整專案級範例python"><a class="header" href="#完整專案級範例python">完整專案級範例（Python）</a></h2>
<p>檔案：<code>examples/python/ch20.py</code></p>
<pre><code class="language-bash">python3 examples/python/ch20.py
</code></pre>
<pre><code class="language-python">"""Chapter 20: seckill pipeline demo."""
import queue
import threading

stock = 5
q: queue.Queue[str] = queue.Queue()
mu = threading.Lock()


def worker():
    global stock
    while True:
        user = q.get()
        if user == "STOP":
            return
        with mu:
            if stock &gt; 0:
                stock -= 1
                print(user, "success, left", stock)
            else:
                print(user, "sold out")


if __name__ == "__main__":
    t = threading.Thread(target=worker)
    t.start()
    for i in range(10):
        q.put(f"u{i}")
    q.put("STOP")
    t.join()
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-distributed-lock.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="appendix-language-map.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-distributed-lock.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="appendix-language-map.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/flowchart-init.js"></script>



    </div>
    </body>
</html>
